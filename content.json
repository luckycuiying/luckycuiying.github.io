[{"title":"webpack-base2","slug":"webpack-base2","date":"2019-11-06T07:52:22.000Z","updated":"2019-11-04T07:52:53.551Z","comments":true,"path":"2019/11/06/webpack-base2/","link":"","permalink":"http://yoursite.com/2019/11/06/webpack-base2/","excerpt":"","text":"Webpack中必须掌握的配置loader主要用于把模块原内容按照需求转换成新内容，可以加载非 JS 模块！通过使用不同的Loader，Webpack可以把不同的文件都转成JS文件,比如CSS、ES6/7、JSX等。 我们来看看这些我们必须掌握的loader! 1.loader的编写1.1 loader的使用 test：匹配处理文件的扩展名的正则表达式 use：loader名称，就是你要使用模块的名称 include/exclude:手动指定必须处理的文件夹或屏蔽不需要处理的文件夹 options:为loaders提供额外的设置选项 默认loader的顺序是从下到上、从右向左执行，当然执行顺序也可以手动定义的，接下来我们依次介绍常见的loader，来感受loader的魅力! 我们基于这个基础配置来继续编写:123456789101112131415161718192021222324252627282930313233const path = require(\"path\");const dev = require(\"./webpack.dev\");const prod = require(\"./webpack.prod\");const merge = require(\"webpack-merge\");const HtmlWebpackPlugin = require(\"html-webpack-plugin\");const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');const base = &#123; entry:'./src/index.js', output: &#123; filename: \"[name].js\", path: path.resolve(__dirname, \"../dist\") &#125;, plugins: [ new HtmlWebpackPlugin(&#123; filename: 'index.html', template: path.resolve(__dirname, \"../public/template.html\"), hash: true, minify: &#123; removeAttributeQuotes: true &#125; &#125;), new CleanWebpackPlugin(&#123; cleanOnceBeforeBuildPatterns: [path.resolve('xxxx/*'),'**/*'], &#125;), ]&#125;;module.exports = env =&gt; &#123; if (env.development) &#123; return merge(base, dev); &#125; else &#123; return merge(base, prod); &#125;&#125;; 2.处理CSS文件2.1 解析css样式我们在js文件中引入css样式！1import './index.css'; 再次执行打包时，会提示css无法解析123ERROR in ./src/index.css 1:4Module parse failed: Unexpected token (1:4)You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders 安装loader 1npm install style-loader css-loader --save-dev 12345678module: &#123; rules: [ &#123; test: /\\.css$/, use: [\"style-loader\", \"css-loader\"] &#125; ]&#125; 2.2 抽离样式文件默认只在打包时进行样式抽离123456789module.exports = env =&gt; &#123; let isDev = env.development; const base = &#123;/*source...*/&#125; if (isDev) &#123; return merge(base, dev); &#125; else &#123; return merge(base, prod); &#125;&#125;; 安装抽离插件1npm install mini-css-extract-plugin --save-dev 配置抽离插件1234567891011&#123; test: /\\.css$/, use: [ !isDev &amp;&amp; MiniCssExtractPlugin.loader, isDev &amp;&amp; 'style-loader', \"css-loader\" ].filter(Boolean)&#125;!isDev &amp;&amp; new MiniCssExtractPlugin(&#123; filename: \"css/[name].css\"&#125;) 最终文件配置贴一下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const path = require(\"path\");const dev = require(\"./webpack.dev\");const prod = require(\"./webpack.prod\");const merge = require(\"webpack-merge\");const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\");const HtmlWebpackPlugin = require(\"html-webpack-plugin\");module.exports = env =&gt; &#123; let isDev = env.development; const base = &#123; entry: \"./src/index.js\", output: &#123; filename: \"[name].js\", path: path.resolve(__dirname, \"../dist\") &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, use: [ !isDev &amp;&amp; MiniCssExtractPlugin.loader, isDev &amp;&amp; 'style-loader', \"css-loader\" ].filter(Boolean) &#125; ] &#125;, plugins:[ !isDev &amp;&amp; new MiniCssExtractPlugin(&#123; filename: \"css/[name].css\" &#125;), new HtmlWebpackPlugin(&#123; filename: \"index.html\", template: path.resolve(__dirname, \"../public/template.html\"), hash: true, minify: &#123; removeAttributeQuotes: true &#125; &#125;), ].filter(Boolean) &#125;; if (isDev) &#123; return merge(base, dev); &#125; else &#123; return merge(base, prod); &#125;&#125;; 2.3 css预处理器不同的css预处理器要安装不同的loader来进行解析 sass: sass-loader node-sass less: less-loader less stylus: stylus-loader stylus 使用sass123456789&#123; test:/\\.scss$/, use:[ !isDev &amp;&amp; MiniCssExtractPlugin.loader, isDev &amp;&amp; 'style-loader', \"css-loader\", \"sass-loader\" ].filter(Boolean)&#125; 在css文件中可能会使用@import语法引用css文件,被引用的css文件中可能还会导入scss 1234567891011121314&#123; test: /\\.css$/, use: [ !isDev &amp;&amp; MiniCssExtractPlugin.loader, isDev &amp;&amp; 'style-loader', &#123; loader:\"css-loader\", options:&#123; importLoaders:1 // 引入的文件需要调用sass-loader来处理 &#125; &#125;, \"sass-loader\" ].filter(Boolean)&#125;, 2.4 处理样式前缀使用postcss-loader增加样式前缀1npm install postcss-loader autoprefixer 在处理css前先增加前缀123456789101112131415 &#123; test: /\\.css$/, use: [ !isDev &amp;&amp; MiniCssExtractPlugin.loader, isDev &amp;&amp; 'style-loader', &#123; loader:\"postcss-loader\", options:&#123; plugins:[require('autoprefixer')] &#125; &#125;, \"postcss-loader\", \"sass-loader\" ].filter(Boolean)&#125;, 或者也可以创建postcss的配置文件postcss.config.js12345module.exports = &#123; plugins:[ require('autoprefixer') ]&#125; 可以配置浏览器的兼容性范围 .browserslistrc 1cover 99.5% 2.5 css压缩在生产环境下我们需要压缩css文件,配置minimizer选项,安装压缩插件 1npm i optimize-css-assets-webpack-plugin terser-webpack-plugin --save-dev 在webpack.prod.js文件中配置压缩12345const OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin');const TerserJSPlugin = require('terser-webpack-plugin');optimization:&#123; minimizer:[new TerserJSPlugin(&#123;&#125;), new OptimizeCSSAssetsPlugin(&#123;&#125;)]&#125; 2.6 文件指纹 Hash整个项目的hash值 chunkhash 根据入口产生hash值 contentHash 根据每个文件的内容产生的hash值 我们可以合理的使用hash戳，进行文件的缓存 123!isDev &amp;&amp; new MiniCssExtractPlugin(&#123; filename: \"css/[name].[contentHash].css\"&#125;) 3.处理文件类型3.1 处理引用的图片1234import logo from './webpack.png';let img = document.createElement('img');img.src = logo;document.body.appendChild(img); 使用file-loader,会将图片进行打包，并将打包后的路径返回123456789&#123; test:/\\.jpe?g|png|gif/, use:&#123; loader:'file-loader', options:&#123; name:`img/[name].[ext]` &#125; &#125;&#125; 3.2 处理icon二进制文件也是使用file-loader来打包123456&#123; test:/woff|ttf|eot|svg|otf/, use:&#123; loader:'file-loader' &#125;&#125; 3.3 转化成base64使用url-loader将满足条件的图片转化成base64,不满足条件的url-loader会自动调用file-loader来进行处理12345678910&#123; test:/\\.jpe?g|png|gif/, use:&#123; loader:'url-loader', options:&#123; limit:100*1024, name:`img/[name].[ext]` &#125; &#125;&#125; 4.处理JS模块4.1 将es6代码编译成es5代码代码的转化工作要交给babel来处理 1npm install @babel/core @babel/preset-env babel-loader --save-dev @babel/core是babel中的核心模块，@babel/preset-env 的作用是es6转化es5插件的插件集合，babel-loader是webpack和loader的桥梁。 123const sum = (a, b) =&gt; &#123; return a + b;&#125;; 增加babel的配置文件 .babelrc 12345&#123; \"presets\": [ [\"@babel/preset-env\"] ]&#125; 配置loader 123module: &#123; rules: [&#123; test: /\\.js$/, use: \"babel-loader\" &#125;]&#125;, 现在打包已经可以成功的将es6语法转化成es5语法！ 4.2 解析装饰器1npm i @babel/plugin-proposal-class-properties @babel/plugin-proposal-decorators --save-dev 1234\"plugins\": [ [\"@babel/plugin-proposal-decorators\", &#123; \"legacy\": true &#125;], [\"@babel/plugin-proposal-class-properties\",&#123;\"loose\":true&#125;]] legacy:true表示继续使用装饰器装饰器，loose为false时会采用Object.defineProperty定义属性 Plugin会运行在Preset之前 Plugin 会从第一个开始顺序执行，Preset则是相反的 4.3 polyfill根据.browserslistrc文件，转化使用到的浏览器api123456\"presets\": [ [\"@babel/preset-env\",&#123; \"useBuiltIns\":\"usage\", // 按需加载 \"corejs\":2 // corejs 替代了以前的pollyfill &#125;]] 安装corejs 1npm install core-js@2 --save 使用transform-runtimeA plugin that enables the re-use of Babel’s injected helper code to save on codesize.可以帮我们节省代码 1npm install --save-dev @babel/plugin-transform-runtime @babel/runtime 在.babelrc中配置插件 123\"plugins\": [ \"@babel/plugin-transform-runtime\"] 4.4 添加eslint安装eslint12npm install eslintnpx eslint --init # 初始化配置文件 12345&#123; test:/\\.js/, enforce:&apos;pre&apos;, use:&apos;eslint-loader&apos;&#125;, 配置eslint-loader可以实时校验js文件的正确性,pre表示在所有loader执行前执行 5.source-map eval 生成代码 每个模块都被eval执行,每一个打包后的模块后面都增加了包含sourceURL source-map 产生map文件 inline 不会生成独立的 .map文件,会以dataURL形式插入 cheap 忽略打包后的列信息，不使用loader中的sourcemap module 没有列信息，使用loader中的sourcemap(没有列信息) 1devtool:isDev?'cheap-module-eval-source-map':false 每个库中采用的sourcemap方式不一,可以根据自己的需要自行配置 6.resolve解析想实现使用require或是import的时候,可以自动尝试添加扩展名进行匹配 123resolve: &#123; extensions: [\".js\", \".jsx\", \".json\", \".css\", \".ts\", \".tsx\", \".vue\"]&#125;, 7.拷贝静态文件有些时候在打包时希望将一些静态资源文件进行拷贝,可以使用copy-webpack-plugin 安装插件1npm i copy-webpack-plugin --save-dev 使用拷贝插件1234const CopyWebpackPlugin = require('copy-webpack-plugin');new CopyWebpackPlugin([ &#123;from:path.resolve('./src/static'),to:path.resolve('./dist')&#125;,]) 8.配置TS环境8.1 使用ts-loader使用ts需要安装ts相关配置1npm install typescript ts-loader --save-dev 生成ts的配置文件1npx tsc --init 配置ts-loader12345&#123; test:/\\.tsx?/, use: ['ts-loader'], exclude: /node_modules/&#125; 将入口文件更改成ts文件 12let a:string = 'hello';console.log(a); 执行npm run dev发现已经可以正常的解析ts文件啦！ 8.2 使用 preset-typescript不需要借助typescript1npm install @babel/preset-typescript 1234567891011121314151617&#123; \"presets\": [ [\"@babel/preset-env\",&#123; \"useBuiltIns\":\"usage\", \"corejs\":2 &#125;], \"@babel/preset-react\", [\"@babel/preset-typescript\",&#123; \"allExtensions\": true &#125;] ], \"plugins\": [ [\"@babel/plugin-proposal-decorators\", &#123; \"legacy\": true &#125;], [\"@babel/plugin-proposal-class-properties\",&#123;\"loose\":true&#125;], \"@babel/plugin-transform-runtime\" ]&#125; 9.配置ts+react环境安装react相关模块12npm i @babel/preset-react --save-dev # 解析jsx语法npm i react @types/react @types/react-dom react react-dom typescript 1234567891011121314151617181920import React from 'react';import ReactDOM from 'react-dom';const state = &#123;number:0&#125;;type State = Readonly&lt;typeof state&gt;;class Counter extends React.Component&lt;object,State&gt;&#123; state:State = state handleClick =()=&gt;&#123; this.setState(&#123;number:this.state.number+1&#125;) &#125; render()&#123; const &#123;number&#125; = this.state; return ( &lt;div&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;点击&lt;/button&gt; &#123;number&#125; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;Counter&gt;&lt;/Counter&gt;,document.getElementById('root')); 10.配置ts+vue环境安装vue所需要的模块12npm install vue-loader vue-template-compiler --save-devnpm install vue vue-property-decorator 配置ts-loader12345678910&#123; test: /\\.tsx?/, use: &#123; loader:'ts-loader', options: &#123; appendTsSuffixTo: [/\\.vue$/], &#125;, &#125;, exclude: /node_modules/&#125; 使用vue-loader插件12const VueLoaderPlugin = require('vue-loader/lib/plugin');new VueLoaderPlugin(); 配置解析.vue文件1234&#123; test:/\\.vue$/, use:'vue-loader'&#125; 增加vue-shims.d.ts，可以识别.vue文件1234declare module &apos;*.vue&apos; &#123; import Vue from &apos;vue&apos;; export default Vue;&#125; index.tsx文件12345import Vue from 'vue';import App from './App.vue';let vm = new Vue(&#123; render:h=&gt;h(App)&#125;).$mount('#root') App.vue文件123456789101112&lt;template&gt; &lt;div&gt; &lt;div v-for=\"(todo,index) in todos\" :key=\"index\"&gt;&#123;&#123;todo&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=\"ts\"&gt;import &#123;Component,Vue&#125; from 'vue-property-decorator';@Componentexport default class Todo extends Vue&#123; public todos = ['香蕉','苹果','橘子']&#125;&lt;/script&gt; 11.配置代理设置服务端接口123456const express = require('express');const app = express();app.get('/api/list', (req, res) =&gt; &#123; res.send(['香蕉', '苹果', '橘子']);&#125;);app.listen(4000); 安装axios获取数据1npm install axios --save-dev 配置接口请求1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;div v-for=\"(todo,index) in todos\" :key=\"index\"&gt; &#123;&#123;todo&#125;&#125; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=\"ts\"&gt;import axios from 'axios';import &#123;Component ,Vue&#125; from 'vue-property-decorator';@Componentexport default class Todo extends Vue&#123; public todos:string[] =[]; async mounted()&#123; let &#123; data &#125; = await axios.get('/api/list'); this.todos = data &#125;&#125;&lt;/script&gt; 配置服务器代理路由12345proxy: &#123; '/api': &#123; target: 'http://localhost:4000', &#125;,&#125;","categories":[],"tags":[]},{"title":"webpack-base3","slug":"webpack-base3","date":"2019-11-04T07:30:18.000Z","updated":"2019-11-04T08:03:12.233Z","comments":true,"path":"2019/11/04/webpack-base3/","link":"","permalink":"http://yoursite.com/2019/11/04/webpack-base3/","excerpt":"","text":"webpack各种优化我们来看看如何实现webpack中的优化，我们先来编写最基本的webpack配置，然后依次实现各种优化！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const MiniCssExtractPlugin = require(\"mini-css-extract-plugin\");const HtmlWebpackPlugin = require(\"html-webpack-plugin\");const path = require(\"path\");module.exports = mode =&gt; &#123; return &#123; mode: mode, entry: \"./src/main.js\", output: &#123; filename: \"bundle.js\", path: path.resolve(__dirname, \"dist\") &#125;, module: &#123; rules: [ &#123; test: /\\.(png|jpg|gif)$/, use: \"file-loader\" &#125;, &#123; test: /\\.js$/, use: \"babel-loader\" // .babelrc已经配置支持react &#125;, &#123; test: /\\.css$/, use: [ mode !== \"development\" ? MiniCssExtractPlugin.loader : \"style-loader\", \"css-loader\" ] &#125; ] &#125;, plugins: [ new PurgecssPlugin(&#123; paths: glob.sync(`$&#123;path.join(__dirname, \"src\")&#125;/**/*`, &#123; nodir: true &#125;) // 不匹配目录，只匹配文件 &#125;), mode !== \"development\" &amp;&amp; new MiniCssExtractPlugin(&#123; filename: \"css/[name].css\" &#125;), new HtmlWebpackPlugin(&#123; template: \"./src/template.html\", filename: \"index.html\" &#125;) ].filter(Boolean) &#125;;&#125;; .babelrc配置文件 123456&#123; \"presets\": [ \"@babel/preset-env\", \"@babel/preset-react\" ]&#125; 1.删除无用的Css样式先来看编写的代码1234import './style.css'import React from 'react';import ReactDOM from 'react-dom';ReactDOM.render(&lt;div&gt;hello&lt;/div&gt;,document.getElementById('root')); 123456body&#123; background: red&#125;.class1&#123; background: red&#125; 这里的.class1显然是无用的，我们可以搜索src目录下的文件，删除无用的样式 1234567const glob = require('glob');const PurgecssPlugin = require('purgecss-webpack-plugin');// 需要配合mini-css-extract-plugin插件mode !== \"development\" &amp;&amp; new PurgecssPlugin(&#123; paths: glob.sync(`$&#123;path.join(__dirname, \"src\")&#125;/**/*`, &#123; nodir: true &#125;) // 不匹配目录，只匹配文件&#125;), 2.图片压缩插件将打包后的图片进行优化1npm install image-webpack-loader --save-dev 在file-loader之前使用压缩图片插件12345678910111213141516171819202122loader: \"image-webpack-loader\",options: &#123; mozjpeg: &#123; progressive: true, quality: 65 &#125;, // optipng.enabled: false will disable optipng optipng: &#123; enabled: false, &#125;, pngquant: &#123; quality: [0.90, 0.95], speed: 4 &#125;, gifsicle: &#123; interlaced: false, &#125;, // the webp option will enable WEBP webp: &#123; quality: 75 &#125;&#125; 可以发现图片大小是有了明显的变化 3.CDN加载文件我们希望通过cdn的方式引入资源1234const AddAssetHtmlCdnPlugin = require('add-asset-html-cdn-webpack-plugin')new AddAssetHtmlCdnPlugin(true,&#123; 'jquery':'https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js'&#125;) 但是在代码中还希望引入jquery来获得提示12import $ from 'jquery'console.log('$',$) 但是打包时依然会将jquery进行打包123externals:&#123; 'jquery':'$'&#125; 在配置文件中标注jquery是外部的，这样打包时就不会将jquery进行打包了 4.Tree-shaking &amp;&amp; Scope-Hoisting4.1 Tree-shaking顾名思义就是将没用的内容摇晃掉,来看下面代码 main.js12import &#123; minus &#125; from \"./calc\";console.log(minus(1,1)); calc.js1234567import &#123;test&#125; from './test';export const sum = (a, b) =&gt; &#123; return a + b + 'sum';&#125;;export const minus = (a, b) =&gt; &#123; return a - b + 'minus';&#125;; test.js1234export const test = ()=&gt;&#123; console.log('hello')&#125;console.log(test()); 观察上述代码其实我们主要使用minus方法,test.js代码是有副作用的! 默认mode:production时，会自动tree-shaking,但是打包后&#39;hello&#39;依然会被打印出来,这时候我们需要配置不使用副作用 在package.json中配置1\"sideEffects\":false, 如果这样设置，默认就不会导入css文件啦，因为我们引入css也是通过import &#39;./style.css&#39; 这里重点就来了,tree-shaking主要针对es6模块,我们可以使用require语法导入css,但是这样用起来有点格格不入,所以我们可以配置css文件不是副作用123\"sideEffects\":[ \"**/*.css\"] 在开发环境下默认tree-shaking不会生效,可以配置标识提示123optimization:&#123; usedExports:true &#125; 4.2 Scope Hoisting作用域提升,可以减少代码体积，节约内存12345678let a = 1;let b = 2;let c = 3;let d = a+b+cexport default d;// 引入dimport d from './d';console.log(d) 最终打包后的结果会变成 console.log(6) 代码量明显减少 减少多个函数后内存占用也将减少 5.DllPlugin &amp;&amp; DllReferencePlugin每次构建时第三方模块都需要重新构建，这个性能消耗比较大，我们可以先把第三方库打包成动态链接库，以后构建时只需要查找构建好的库就好了，这样可以大大节约构建时间1234import React from 'react';import ReactDOM from 'react-dom';ReactDOM.render(&lt;h1&gt;hello&lt;/h1&gt;,document.getElementById('root')) 5.1 DllPlugin 这里我们可以先将react、react-dom单独进行打包 单独打包创建webpack.dll.js1234567891011121314151617const path = require('path');const DllPlugin = require('webpack/lib/DllPlugin');module.exports = &#123; entry:['react','react-dom'], mode:'production', output:&#123; filename:'react.dll.js', path:path.resolve(__dirname,'dll'), library:'react' &#125;, plugins:[ new DllPlugin(&#123; name:'react', path:path.resolve(__dirname,'dll/manifest.json') &#125;) ]&#125; 执行&quot;webpack --config webpack.dll.js命令，可以看到dll目录下创建了两个文件分别是manifest.json,react.dll.js 关系是这个酱紫的，到时候我们会通过manifest.json找到react.dll.js文件中的模块进行加载 5.2 DllReferencePlugin在我们的项目中可以引用刚才打包好的动态链接库12345678910const DllReferencePlugin = require('webpack/lib/DllReferencePlugin');const AddAssetHtmlWebpackPlugin = require('add-asset-html-webpack-plugin');// 构建时会引用动态链接库的内容new DllReferencePlugin(&#123; manifest:path.resolve(__dirname,'dll/manifest.json')&#125;),// 需要手动引入react.dll.jsnew AddAssetHtmlWebpackPlugin( &#123; filepath: path.resolve(__dirname,'dll/react.dll.js') &#125;) 使用DllPlugin可以大幅度提高构建速度 6.动态加载实现点击后动态加载文件12345678let btn = document.createElement('button');btn.innerHTML = '点击加载视频';btn.addEventListener('click',()=&gt;&#123; import('./video').then(res=&gt;&#123; console.log(res.default); &#125;);&#125;);document.body.appendChild(btn); 给动态引入的文件增加名字 123456output:&#123; chunkFilename:'[name].min.js'&#125;import(/* webpackChunkName: \"video\" */ './video').then(res=&gt;&#123; console.log(res.default);&#125;) 这样打包后的结果最终的文件就是 video.min.js 7.打包文件分析工具安装webpack-bundle-analyzer插件1npm install --save-dev webpack-bundle-analyzer 使用插件 12const &#123;BundleAnalyzerPlugin&#125; = require('webpack-bundle-analyzer');mode !== \"development\" &amp;&amp; new BundleAnalyzerPlugin() 默认就会展现当前应用的分析图表 8.SplitChunks我们在来看下SplitChunks这个配置，他可以在编译时抽离第三方模块、公共模块 将项目配置成多入口文件1234entry:&#123; a:'./src/a.js', b:'./src/b.js'&#125; 我们让a,b两个模块同时引用jquery,别忘了去掉之前的externals配置 配置SplitChunks插件 默认配置在此，我一个个描述下含义12345678910111213141516171819202122splitChunks: &#123; chunks: 'async', // 分割异步模块 minSize: 30000, // 分割的文件最小大小 maxSize: 0, minChunks: 1, // 引用次数 maxAsyncRequests: 5, // 最大异步请求数 maxInitialRequests: 3, // 最大初始化请求数 automaticNameDelimiter: '~', // 抽离的命名分隔符 automaticNameMaxLength: 30, // 名字最大长度 name: true, cacheGroups: &#123; // 缓存组 vendors: &#123; // 先抽离第三方 test: /[\\\\/]node_modules[\\\\/]/, priority: -10 &#125;, default: &#123; minChunks: 2, priority: -20, // 优先级 reuseExistingChunk: true &#125; &#125;&#125; 我们将async改为initial 我们在为每个文件动态导入lodash库,并且改成async1import('lodash') 为每个入口引入c.js,并且改造配置文件 123456789101112131415splitChunks: &#123; chunks: 'all', name: true, cacheGroups: &#123; vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, priority: -10 &#125;, default: &#123; minSize:1, // 不是第三方模块，被引入两次也会被抽离 minChunks: 2, priority: -20, &#125; &#125;&#125; 这样再反过来看chunks的参数是不是就了然于胸啦！ 9.热更新模块热替换（HMR - Hot Module Replacement）是 webpack 提供的最有用的功能之一。它允许在运行时替换，添加，删除各种模块，而无需进行完全刷新重新加载整个页面 保留在完全重新加载页面时丢失的应用程序的状态 只更新改变的内容，以节省开发时间 调整样式更加快速，几乎等同于就在浏览器调试器中更改样式 启用热更新，默认样式可以支持热更新，如果不支持热更新则采用强制刷新1234devServer:&#123; hot:true&#125;new webpack.NamedModulesPlugin(), 让js支持热更新 12345import sum from './sum';console.log(sum(1,2));if(module.hot)&#123; // 如果支持热更新 module.hot.accept(); // 当入口文件变化后重新执行当前入口文件&#125; 10.IgnorePlugin忽略 import和require语法1new webpack.IgnorePlugin(/^\\.\\/locale$/, /moment$/) 11.费时分析可以计算每一步执行的运行速度1234const SpeedMeasureWebpackPlugin = require('speed-measure-webpack-plugin');const smw = new SpeedMeasureWebpackPlugin(); module.exports =smw.wrap(&#123;&#125;); 12.noParsemodule.noParse，对类似jq这类依赖库，内部不会引用其他库，我们在打包的时候就没有必要去解析，这样能够增加打包速率1noParse:/jquery/ 13.resolve12345resolve: &#123; extensions: [\".js\",\".jsx\",\".json\",\".css\"], alias:&#123;&#125;, modules:['node_modules']&#125;, 14.include/exclude在使用loader时,可以指定哪些文件不通过loader,或者指定哪些文件通过loader123456&#123; test: /\\.js$/, use: \"babel-loader\", // include:path.resolve(__dirname,'src'), exclude:/node_modules/&#125;, 15.happypack多线程打包，我们可以将不同的逻辑交给不同的线程来处理1npm install --save-dev happypack 使用插件1234567891011121314151617181920212223const HappyPack = require('happypack');rules:[ &#123; test: /\\.js$/, use: 'happypack/loader?id=jsx' &#125;, &#123; test: /\\.less$/, use: 'happypack/loader?id=styles' &#125;,]new HappyPack(&#123; id: 'jsx', threads: 4, loaders: [ 'babel-loader' ]&#125;),new HappyPack(&#123; id: 'styles', threads: 2, loaders: [ 'style-loader', 'css-loader', 'less-loader' ]&#125;)","categories":[],"tags":[]},{"title":"webpack-base","slug":"webpack-base.1","date":"2019-11-04T07:30:18.000Z","updated":"2019-11-04T08:00:44.742Z","comments":true,"path":"2019/11/04/webpack-base.1/","link":"","permalink":"http://yoursite.com/2019/11/04/webpack-base.1/","excerpt":"","text":"从0搭建自己的webpack开发环境1.什么是Webpack？webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler),当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle 使用Webpack作为前端构建工具： 代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。 文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。 代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。 模块合并：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。 自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。 代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。 自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。 在webpack应用中有两个核心: 1) 模块转换器，用于把模块原内容按照需求转换成新内容，可以加载非 JS 模块 2) 扩展插件，在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情。 2.初始化项目123├── src # 源码目录│ ├── a-module.js│ └── index.js 编写 a-module.js1module.exports = 'hello'; 编写 index.js12let a = require('./a-module');console.log(a); 这里我们使用CommonJS模块的方式引入，这种方式默认在浏览器上是无法运行的，我们希望通过 webpack 来进行打包！ 3.webpack快速上手3.1 安装12npm init -ynpm install webpack webpack-cli --save-dev webpack默认支持0配置,配置scripts脚本 123\"scripts\": &#123; \"build\": \"webpack\"&#125; 执行npm run build,默认会调用 node_modules/.bin下的webpack命令，内部会调用webpack-cli解析用户参数进行打包。默认会以 src/index.js 作为入口文件。 这里也可以使用npx webpack,npx 是 5.2版本之后npm提供的命令可以执行.bin下的可执行文件 我们可以发现已经产生了dist目录，此目录为最终打包出的结果。main.js可以在html中直接引用,这里还提示我们默认mode 为production 3.2 webpack.config.js我们打包时一般不会采用0配置，webpack在打包时默认会查找当前目录下的 webpack.config.js or webpackfile.js 文件。 通过配置文件进行打包 12345678const path = require('path');module.exports = &#123; entry:'./src/index.js', output:&#123; filename:'bundle.js', // 打包出的结果文件 path:path.resolve(__dirname,'dist') // 打包到dist目录下 &#125;&#125; 3.3 配置打包的mode我们需要在打包时提供mode属性来区分是开发环境还是生产环境,来实现配置文件的拆分 1234├── build│ ├── webpack.base.js│ ├── webpack.dev.js│ └── webpack.prod.js 我们可以通过指定不同的文件来进行打包 配置scripts脚本1234\"scripts\": &#123; \"build\": \"webpack --config ./build/webpack.prod\", \"dev\": \"webpack --config ./build/webpack.dev\"&#125; 可以通过 config 参数指定,使用哪个配置文件来进行打包 通过env参数区分 1234\"scripts\": &#123; \"build\": \"webpack --env.production --config ./build/webpack.base\", \"dev\": \"webpack --env.development --config ./build/webpack.base\"&#125; 改造webpack.base文件默认导出函数，会将环境变量传入到函数的参数中123module.exports = (env)=&gt;&#123; console.log(env); // &#123; development: true &#125;&#125; 合并配置文件 我们可以判断当前环境是否是开发环境来加载不同的配置,这里我们需要做配置合并安装webpack-merge:1npm install webpack-merge --save-dev webpack.dev配置123module.exports = &#123; mode:'development'&#125; webpack.prod配置123module.exports = &#123; mode:'production'&#125; webpack.base配置1234567891011121314151617181920const path = require('path');const merge = require('webpack-merge');// 开发环境const dev = require('./webpack.dev');// 生产环境const prod = require('./webpack.prod');const base = &#123; // 基础配置 entry:'./src/index.js', output:&#123; filename:'bundle.js', path:path.resolve(__dirname,'../dist') &#125;&#125;module.exports = (env) =&gt;&#123; if(env.development)&#123; return merge(base,dev); &#125;else&#123; return merge(base,prod) &#125;&#125; 后续的开发中，我们会将公共的逻辑放到base中,开发和生产对的配置也分别进行存放！ 4.webpack-dev-server配置开发服务器，可以在实现在内存中打包,并且自动启动服务1npm install webpack-dev-server --save-dev 1234\"scripts\": &#123; \"build\": \"webpack --env.production --config ./build/webpack.base\", \"dev\": \"webpack-dev-server --env.development --config ./build/webpack.base\"&#125; 通过执行npm run dev来启启动开发环境 默认会在当前根目录下启动服务 配置开发服务的配置12345678910const path = require('path')module.exports = &#123; mode:'development', devServer:&#123; // 更改静态文件目录位置 contentBase:path.resolve(__dirname,'../dist'), compress:true, // 开启gzip port:3000, // 更改端口号 &#125;&#125; 5.打包Html插件5.1 单入口打包自动产生html，并引入打包后的文件 编辑webpack.base文件123456789101112const HtmlWebpackPlugin = require('html-webpack-plugin');plugins:[ new HtmlWebpackPlugin(&#123; filename:'index.html', // 打包出来的文件名 template:path.resolve(__dirname,'../public/index.html'), hash:true, // 在引用资源的后面增加hash戳 minify:&#123; removeAttributeQuotes:true // 删除属性双引号 &#125; &#125;)] 5.2 多入口打包根据不同入口 生成多个js文件，引入到不同html中123── src ├── entry-1.js └── entry-2.js 多入口需要配置多个entry123456789entry:&#123; jquery:['jquery'], // 打包jquery entry1:path.resolve(__dirname,'../src/entry-1.js'), entry2:path.resolve(__dirname,'../src/entry-2.js')&#125;,output:&#123; filename:'[name].js', path:path.resolve(__dirname,'../dist')&#125;, 产生多个Html文件1234567891011121314151617181920new HtmlWebpackPlugin(&#123; filename:'index.html', template:path.resolve(__dirname,'../public/template.html'), hash:true, minify:&#123; removeAttributeQuotes:true &#125;, chunks:['jquery','entry1'], // 引入的chunk 有jquery,entry&#125;),new HtmlWebpackPlugin(&#123; filename:'login.html', template:path.resolve(__dirname,'../public/template.html'), hash:true, minify:&#123; removeAttributeQuotes:true &#125;, inject:false, // inject 为false表示不注入js文件 chunksSortMode:'manual', // 手动配置代码块顺序 chunks:['entry2','jquery']&#125;) 以上的方式不是很优雅，每次都需要手动添加HtmlPlugin应该动态产生html文件，像这样:12345678910111213141516171819202122let htmlPlugins = [ &#123; entry: \"entry1\", html: \"index.html\" &#125;, &#123; entry: \"entry2\", html: \"login.html\" &#125;].map( item =&gt; new HtmlWebpackPlugin(&#123; filename: item.html, template: path.resolve(__dirname, \"../public/template.html\"), hash: true, minify: &#123; removeAttributeQuotes: true &#125;, chunks: [\"jquery\", item.entry] &#125;));plugins: [...htmlPlugins] 6.清空打包结果可以使用clean-webpack-plugin手动清除某个文件夹内容: 安装1npm install --save-dev clean-webpack-plugin 12345const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');new CleanWebpackPlugin(&#123; // 清空匹配的路径 cleanOnceBeforeBuildPatterns: [path.resolve('xxxx/*'),'**/*'],&#125;) 这样就可以清空指定的目录了,我们可以看到webpack插件的基本用法就是 new Plugin并且放到plugins中","categories":[],"tags":[]},{"title":"connected-react-router 的使用","slug":"react-router-4","date":"2019-10-28T02:54:56.000Z","updated":"2019-10-30T02:04:21.741Z","comments":true,"path":"2019/10/28/react-router-4/","link":"","permalink":"http://yoursite.com/2019/10/28/react-router-4/","excerpt":"","text":"第一：connected-react-router使用。 是链接react-router 和react-redux的一个库。 解决在redux action 里面跳转路径，以及获取当前的浏览器loacation等问题。 connected-react-router的三部？ yarn add connected-react-router ||npm install –save connected-react-router 第一步：在项目中的reducers文件夹的根目录 引入 connectRouter 和history 代码如下：12345678910// reducers.jsimport &#123; combineReducers &#125; from 'redux'import counter from './counter'import history from './history' // history 可以自己创建hostory 对象import &#123;connectRouter &#125; from 'connected-react-router'let reducer = combineReducers(&#123; counter, router:connectRouter(history)&#125;)export default reducer; 原理： 每当地址栏里的路径发生改变的时候,都会向仓库派发一个动作， 然后由仓库中的reducer把最新的动作类型和最新的路径保存到状态树中。 这里的key 值必须是 router 如何创建hostory 对象？ 在react-router-dom中直接将这三种history作了内置，于是我们看到了BrowserRouter、HashRouter、MemoryRouter这三种Router。但是 redux action 中是获取不到history 对象的，就需要自己创建一个history 对象 123import &#123; createHashHistory &#125; from 'history'let history = createHashHistory();export default history 第二部： 在redux store 的文件里 引入history和routerMiddleware 使用中间件拦截处理history,代码如下: 1234567891011import &#123;createStore,applyMiddleware&#125; from 'redux';import reducers from './reducers'import history from '../historty'import &#123; routerMiddleware &#125; from 'connected-react-router'// 第二部： 使用中间件// 当我们想在action是里跳转路径的时候， 我们会向仓库派发一个跳转路径的动作// 然后会由routerMiddle 这个中间件进行拦截处理， 通过history对象实现路径的跳转let store = applyMiddleware(routerMiddleware(history))(createStore)(reducers)window.store = storeexport default store 第三部: 在路由的根组件把 Router组件改成ConnectedRouter 代码如下： 12345678910111213141516171819202122232425import React from 'react';import ReactDOM from 'react-dom';import &#123;HashRouter as Router, Route, Link&#125; from 'react-router-dom'import Counter from './components/Counter'import Home from './components/Home'import &#123; Provider &#125; from'react-redux'// step3import &#123; ConnectedRouter &#125; from 'connected-react-router'import store from './store'import history from './historty'ReactDOM.render( ( &lt;Provider store =&#123;store&#125;&gt; &lt;ConnectedRouter history=&#123;history&#125;&gt; &lt;&gt; &lt;Link to='/'&gt;首页&lt;/Link&gt; &lt;Link to='/counter'&gt;计数器&lt;/Link&gt; &lt;Route path='/' exact=&#123;true&#125; component=&#123;Home&#125;/&gt; &lt;Route path='/counter' component=&#123;Counter&#125;/&gt; &lt;/&gt; &lt;/ConnectedRouter&gt; &lt;/Provider&gt; ) , document.getElementById('root')); Note: the history object provided to router reducer, routerMiddleware, and ConnectedRouter component must be the same history object.","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react-router-3","slug":"react-router-3","date":"2019-10-26T11:54:56.000Z","updated":"2019-10-29T00:32:06.098Z","comments":true,"path":"2019/10/26/react-router-3/","link":"","permalink":"http://yoursite.com/2019/10/26/react-router-3/","excerpt":"","text":"常见问题总结1，React-Router 和 react-router-dom区别？ API 方面的不同 React-Router 提供了路由的核心api。如Router、Route、Switch等，但没有提供有关dom操作进行路由跳转的api； react-router-dom 主要用于web 应用，提供了BrowserRouter、Route、Link等api，可以通过dom操作触发事件控制路由。 Link组件，会渲染一个a标签；BrowserRouter和HashRouter组件，前者使用pushState和popState事件构建路由，后者使用 hash 和 hashchange 事件构建路由。 动态路由跳转的不同 1,React-router： router4.0以上 this.props.history.push(&apos;/path&apos;) 实现跳转； router3.0以上 this.props.router.push(&apos;/path&apos;) 实现跳转； 2,React-router-dom： 直接用 this.props.history.push(‘/path’) 实现跳转 使用的区别 react-router-dom在react-router的基础上扩展了可操作dom的api。 Swtich 和 Route 都是从react-router中导入了相应的组件并重新导出，没做什么特殊处理。 react-router-dom中package.json依赖中存在对react-router的依赖，故此，不需要npm安装react-router。 一般项目中直接 安装 react-router-dom 即可在web 应用中。 2，Link组件，会渲染一个a标签 和普通a 标签有什么区别？- Link 组件渲染的 a 禁掉默认事件的 a 标签 可以使用 history.pushState() 来改变页面 url，这个方法还会触发页面的 hashchange 事件，Router 内部通过捕获监听这个事件来处理对应的跳转逻辑。。只是链接变了， 并没有刷新页面。 1234567891011121314151617import React,&#123;Component&#125; from 'react';import RouterContext from './context';class Link extends Component &#123; static contextType = RouterContext; render() &#123; return ( // &lt;a href=&#123; `#$&#123;this.props.to&#125;`&#125;&gt; &#123;this.props.children&#125;&lt;/a&gt; 只支持hash &lt;a &#123;...this.props&#125; onClick=&#123;()=&gt;this.context.history.push(this.props.to)&#125;&gt; &#123;this.props.children&#125; &lt;/a&gt; ) &#125;&#125; export default Link; 3,受保护的路由 含义：受保护的路由是，有一定的条件才能够能访问到， 例如，有些页面是登录后才能看到的 如何实现能？ 就是在基本Route组件路由外面再套一个保护组件 实现的思路是：在渲染route 组件之前，在外层组件里面做判断，如果用户登录了可直接渲染对应的route 组件。如果没有登录，则重定向到登录页面。代码实现如下：123456789101112import React, &#123;Component&#125; from 'react';import &#123; Route, Redirect &#125; from '../react-router-dom';export default function(&#123;component:Component,...rest&#125;)&#123; return ( &lt;Route &#123;...rest&#125; render=&#123; props=&gt;localStorage.getItem('login')? &lt;Component &#123;...props&#125;/&gt;: &lt;Redirect to=&#123;&#123;pathname:'/login',state:&#123;from:props.location.pathname&#125;&#125;&#125;/&gt; &#125;/&gt; ) &#125; 4,自定义导航 含义: 主要是实现点击谁，谁高亮。 实现原理代码如下： 12345678910111213import React from 'react';import &#123;Route,Link&#125; from '../react-router-dom';export default function(&#123;to,exact,children&#125;)&#123; return ( &lt;Route path=&#123;to&#125; exact=&#123;exact&#125; children=&#123; props=&gt;&#123; // match匹配上才有值 return &lt;Link className=&#123;props.match?'active':''&#125; to=&#123;to&#125;&gt;&#123;children&#125;&lt;/Link&gt;; &#125; &#125; /&gt; ) &#125; 注意 route组件里 属性 render 和children 渲染的区别 render 只会在path 和地址栏路径区域的时候才会渲染 children 不管路径匹配不匹配，都会渲染返回值的。 5,一个普通组件如何能使用路由里面的信息呢？ 解决方案是 使用 withRouter withRouter 组件的原理实现如下： 12345678import React,&#123;Component&#125; from 'react';import Route from './Route';export default function(WrappedComponent)&#123; return &lt;Route render=&#123;routeProps=&gt;&lt;Component &#123;...routeProps&#125;&gt;&#125;/&gt;&#125; 6,跳转是添加阻止组件 解决的问题是，再添加表单时误操作跳转到其他页面，而丢失之前添加的数据信息 实现原理： 在表单的input 标签内添加 onChange的属性 来改变state 里面blocking 一个阻止开启的标识。 添加一个Prompt 的提示组件， 根据state里面的blocking 的真假值来显示和隐藏。12345678910111213141516171819202122232425262728293031323334353637383940414243import React, &#123;Component&#125; from 'react';import local from '../local';import &#123;Prompt&#125; from '../react-router-dom';export default class UserAdd extends Component&#123; state = &#123;blocking:false&#125; constructor()&#123; super(); this.usernameRef = React.createRef(); this.emailRef = React.createRef(); &#125; handleSubmit = (event)=&gt;&#123; event.preventDefault(); let username = this.usernameRef.current.value; let email = this.emailRef.current.value; let user = &#123;id:Date.now(),username,email&#125;; local.add(user); this.props.history.push('/user/list'); &#125; render()&#123; return( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;Prompt when=&#123;this.state.blocking&#125; message=&#123;location=&gt;`你确定你要跳转到$&#123;location.pathname&#125;吗`&#125; /&gt; &lt;div className=\"form-group\"&gt; &lt;label className=\"control-label\"&gt;用户名&lt;/label&gt; &lt;input className=\"form-control\" ref=&#123;this.usernameRef&#125; onChange=&#123;event=&gt;this.setState(&#123;blocking:this.state.blocking.block||event.target.value.length&gt;0&#125;)&#125;/&gt; &lt;/div&gt; &lt;div className=\"form-group\"&gt; &lt;label className=\"control-label\"&gt;邮箱&lt;/label&gt; &lt;input className=\"form-control\" ref=&#123;this.emailRef&#125; onChange=&#123;event=&gt;this.setState(&#123;blocking:this.state.blocking.block||event.target.value.length&gt;0&#125;)&#125;/&gt; &lt;/div&gt; &lt;div className=\"form-group\"&gt; &lt;button className=\"btn btn-primary\" type=\"submit\"&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; ) &#125;&#125; 123456789101112131415161718import React from 'react';import RouterContext from './context';export default class Prompt extends React.Component&#123; static contextType = RouterContext componentWillUnmount()&#123; this.context.history.block(null); &#125; render()&#123; let history = this.context.history;//从上下文中获取历史对象 const &#123;when,message&#125; = this.props; if(when)&#123; history.block(message); &#125;else&#123; history.block(null); &#125; return null; &#125;&#125;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"React-router2","slug":"React-router2","date":"2019-10-25T08:31:16.000Z","updated":"2019-10-29T00:38:50.730Z","comments":true,"path":"2019/10/25/React-router2/","link":"","permalink":"http://yoursite.com/2019/10/25/React-router2/","excerpt":"","text":"react-router 里的API Router 组件与 history Router 组件是比较底层的组件。实际开发中，我们通常选用 BrowserRouter 或者 HashRouter。 BrowserRouter 与 HashRouter 都是对 Router 的封装，自带了一个 history 对象。这二者的最大区别在于自身的 history 对象的不同。 12345678910import &#123; createBrowserHistory, createHashHistory &#125; from 'history'const history = createBrowserHistory()// 或者下面这样// const history = createHashHistory()&lt;Router history=&#123;history&#125;&gt; &lt;App/&gt;&lt;/Router&gt;","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"React-router1","slug":"React-router1","date":"2019-10-25T01:31:16.000Z","updated":"2019-10-25T07:17:23.216Z","comments":true,"path":"2019/10/25/React-router1/","link":"","permalink":"http://yoursite.com/2019/10/25/React-router1/","excerpt":"","text":"react-router 的三问？ 是什么 React Router 是完整的 React 路由解决方案。它有助于向应用程序添加新的屏幕和流。这使 URL 与网页上显示的数据保持同步。它负责维护标准化的结构和行为，并用于开发单页 Web 应用。 React 路由有一个简单的API。 解决什么问题 大型应用中不同的路径渲染不同的组件 使用场景它通过管理 URL，实现组件的切换和状态的变化，开发复杂的应用几乎肯定会用到。 基本用法 1,React Router 安装命令如下。1npm install react-router -S 2,使用时，路由器Router就是React的一个组件。 12import &#123; Router &#125; from 'react-router';render(&lt;Router/&gt;, document.getElementById('app')); 3, Router 组件本身就是一个容器，真正的路由是要通过Route组件来定义1234567import &#123; Router, Route, hashHistory &#125; from 'react-router';render(( &lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route path=\"/\" component=&#123;App&#125;/&gt; &lt;/Router&gt;), document.getElementById('app')); 路由的两种实现方式 1,HashRouter : 利用hash 实现路由切换 HashRouter 的原理12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;link rel=\"shortcut icon\" href=\"%PUBLIC_URL%/favicon.ico\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /&gt; &lt;meta name=\"theme-color\" content=\"#000000\" /&gt; &lt;title&gt;React App&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;a href=\"#/a\"&gt; 去A&lt;/a&gt; &lt;a href=\"#/b\"&gt; 去B&lt;/a&gt; &lt;script&gt; let root = document.getElementById('root') window.addEventListener('hashchange',()=&gt;&#123; let hash = window.location.hash; if(hash == '#/a')&#123; root.innerHTML = '&lt;h1&gt;aaaaaaaa&lt;/h1&gt;' &#125;else if(hash == '#/b')&#123; root.innerHTML = '&lt;h1&gt;bbbbbbb&lt;/h1&gt;' &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2,BrowserRouter :实现h5 Api实现路由的切换 history 的理解 history对象提供了操作浏览器会话历史的接口。 historylength 属性声明了浏览器历史列表中的元素数量 pushState HTML5引入了 history.pushState() 和 history.replaceState() 方法，它们分别可以添加和修改历史记录条目。这些方法通常与window.onpopstate 配合使用 onpopstate window.onpopstate是popstate事件在window对象上的事件处理程序1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;link rel=\"shortcut icon\" href=\"%PUBLIC_URL%/favicon.ico\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /&gt; &lt;meta name=\"theme-color\" content=\"#000000\" /&gt; &lt;title&gt;React App&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;button&gt;/a&lt;/button&gt; &lt;button&gt;/b&lt;/button&gt; &lt;script&gt; let root = document.getElementById('root') // 给window增加一个事件监听,监听popstate 弹出的事件 window.onpopstate =function(event)&#123; console.log(event) &#125; setTimeout(() =&gt; &#123; history.pushState(&#123;page:1&#125;,'page1','/page1') &#125;, 1000); setTimeout(() =&gt; &#123; history.pushState(&#123;page:2&#125;,'page2','/page2') &#125;, 2000); setTimeout(() =&gt; &#123; // 添加 history.pushState(&#123;page:3&#125;,'page3','/page3') &#125;, 3000); setTimeout(() =&gt; &#123; // 替换 history.replaceState(&#123;page:4&#125;,'page4','/page4') &#125;, 4000); setTimeout(() =&gt; &#123; history.back() // 后退 &#125;, 5000); setTimeout(() =&gt; &#123; history.forward() // 前进 &#125;, 6000); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 总结： pushState会往History中写入一个对象，他造成的结果便是,History length +1、url 改变、该索引History对应有一个State对象,这个时候若是点击浏览器的后退，便会触发popstate事件，将刚刚的存入数据对象读出 pushState 会改变History 每次使用时候会为该索引的State加入我们自定义数据 每次我们会根据State的信息还原当前的view，于是用户点击后退便有了与浏览器后退前进一致的感受 pushState() 需要三个参数: 一个状态对象, 一个标题 (目前被忽略), 和 (可选的) 一个URL 调用history.pushState()或者history.replaceState()不会触发popstate事件. popstate事件只会在浏览器某些行为下触发, 比如点击后退、前进按钮(或者在JavaScript中调用history.back()、history.forward()、history.go()方法) 跑通路由123456789101112131415161718192021import React from 'react';import ReactDOM from 'react-dom';// 第一引入路由,里面提供了很多组件import &#123; HashRouter as Router, Route, Link &#125; from 'react-router-dom';import Home from './components/Home';import User from './components/User';import Profile from './components/Profile';import Login from './components/Login';// 分析 HashRouter 组件, 1，要提供一个对象 里面有history, location , match 传递给后代组件（setState）// Route 路由 主要工作就是拿到父组件中的路劲， 和自己身上的path比较是否相等，如果相等就渲染自己的component即可。ReactDOM.render( // 提供属性和方法 &lt;Router&gt; &lt;&gt; &lt;Route path=\"/\" exact=&#123;true&#125; component=&#123;Home&#125; /&gt; &lt;Route path=\"/user\" component=&#123;User&#125; /&gt; &lt;Route path=\"/profile\" component=&#123;Profile&#125; /&gt; &lt;/&gt; &lt;/Router&gt; , document.getElementById('root'));","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"Redux-Saga","slug":"Redux-Saga","date":"2019-10-24T01:33:41.000Z","updated":"2019-10-24T10:52:02.154Z","comments":true,"path":"2019/10/24/Redux-Saga/","link":"","permalink":"http://yoursite.com/2019/10/24/Redux-Saga/","excerpt":"","text":"redux-saga 的三问 产生的原因 在reducers 中的所有操作都是同步的并且是纯粹的， 就renducer 是纯函数， 纯函数是指一个函数返回的结果只依赖于它的参数， 并且在执行过成中不会对外部产生副作用， 即给它传什么，就吐出什么。 但是在实际应用开发中， 我们希望做一些异步的（如：Ajax 请求） 且不纯粹的操作（改变外部的状态），这些在函数式编程范式中被称作为“副作用” 是什么 redux-saga是用来处理上述副作用（异步任务）的一个中间件。它是一个接受事件，并且可能触发新事件的过程管理者，为你的应用管理复杂的流程 一般大型的框架里面都有用到， 例如create-react-app , ant-dva-pro 等 redux-saga 工作原理 saga 采用的Generator 函数来 yield Effects (包含指令的文本对象) Generator 函数的作用是可以暂停执行的，再次执行的时候从上次暂停的地方继续执行 Effect是一个简单的对象,改对象包含了一些middleware 解释执行的信息 你可以通过使用effects API 如 fork, call ,take,pull ,select, cancel等来创建Effect. redux-saga 分类 worker saga做实际的工作，例如调用API,进行异步的请求，获取异步封装的结果 watcher saga监听被 dispatch的actions, 当接收到action 或者知道被其触发时， 调用worker执行 root saga 立即启动saga 的唯一入口 构建项目 初始化项目 123cnpm install create-react-app -g create-react-app saga-startcnpm i redux react-redux redux-saga tape --save 跑通saga 12345678910import &#123;createStore, applyMiddleware&#125; from 'redux';import reducer from './reducer';import createSagaMiddleware from 'redux-saga';//首先我们引入 ./sagas 模块中的 Saga。然后使用 redux-saga 模块的 createSagaMiddleware 工厂函数来创建一个 Saga middlewareimport &#123;helloSaga&#125; from './sagas';let sagaMiddleware = createSagaMiddleware();//运行 helloSaga 之前，我们必须使用 applyMiddleware 将 middleware 连接至 Store。然后使用 sagaMiddleware.run(helloSaga) 运行 Saga。let store=applyMiddleware(sagaMiddleware)(createStore)(reducer);sagaMiddleware.run(helloSaga);export default store; ./saga.js 123export function*()&#123; console.log('hello')&#125; 发起异步调用 首先我们通过effect里面的APi 编写好一个saga 中间件 添加一个saga.js123456789101112131415161718192021222324252627import &#123;takeEvery,put,call,take&#125; from 'redux-saga/effects'import * as types from '../action-types';import &#123; delay &#125;from '../utils'//worker Saga: 将执行异步的 increment 任务//incrementAsync Saga 通过 delay(1000) 延迟了 1 秒钟，然后 dispatch 一个叫 INCREMENT 的 action。export function* incrementAsync()&#123; //工具函数 delay，这个函数返回一个延迟 1 秒再 resolve 的 Promise 我们将使用这个函数去 block(阻塞) Generator //Sagas 被实现为 Generator functions，它会 yield 对象到 redux-saga middleware。 被 yield 的对象都是一类指令，指令可被 middleware 解释执行。当 middleware 取得一个 yield 后的 Promise，middleware 会暂停 Saga，直到 Promise 完成 //incrementAsync 这个 Saga 会暂停直到 delay 返回的 Promise 被 resolve，这个 Promise 将在 1 秒后 resolve //当 middleware 拿到一个被 Saga yield 的 Effect，它会暂停 Saga，直到 Effect 执行完成，然后 Saga 会再次被恢复 yield call(delay,1000);//如果 Effect 类型是 CALL 那么它会调用给定的函数。 //一旦 Promise 被 resolve，middleware 会恢复 Saga 接着执行，直到遇到下一个 yield //在这里下一个语句是另一个被 yield 的对象：调用 put(&#123;type: 'INCREMENT'&#125;) 的结果，意思是告诉 middleware 发起一个 INCREMENT 的 action //put 就是我们称作 Effect 的一个例子。Effects 是一些简单 Javascript 对象，包含了要被 middleware 执行的指令 yield put(&#123;//PUT 那 middleware 会 dispatch 一个 action 到 Store type:types.INCREMENT &#125;) &#125;export default function* watchIncrementAsync()&#123; //takeEvery，用于监听所有的 INCREMENT_ASYNC action，并在 action 被匹配时执行 incrementAsync 任务 yield takeEvery(types.ASYNC_INCREMENT,incrementAsync)&#125; 1234567891011//saga/index.jsimport &#123; all &#125; from 'redux-saga/effects'import &#123; watchIncrementAsync, watchAndLog &#125; from './watchIncrementAsync'import helloSaga from './helloSage'export default function* rootSaga() &#123; //这个 Saga yield 了一个数组，值是调用 helloSaga 和 watchIncrementAsync 两个 Saga 的结果。意思是说这两个 Generators 将会同时启动 yield all([ helloSaga(), watchIncrementAsync() ]) &#125; 123456789101112//store/index.jsimport &#123;createStore,applyMiddleware &#125; from 'redux';import reducers from './reducers';import createSageMiddleware from 'redux-saga';import rootSaga from './saga';let sagaMiddleware = createSageMiddleware();let store = applyMiddleware(sagaMiddleware)(createStore)(reducers)sagaMiddleware.run(rootSaga)window.store = store// 创建一个仓库export default store redux-saga 框架的核心API-, Saga 辅助函数redux-saga提供了一些辅助函数，用来在一些特定的action 被发起到Store时派生任务，下面我先来讲解两个辅助函数：takeEvery 和 takeLatest takeEvery例如：每次点击 Fetch 按钮时，我们发起一个 FETCH_REQUESTED 的 action。 我们想通过启动一个任务从服务器获取一些数据，来处理这个action 首先我们创建一个将执行异步 action 的任务：1234567891011import &#123; call, put &#125; from 'redux-saga/effects'export function* fetchData(action) &#123; try &#123; const data = yield call(Api.fetchUser, action.payload.url); yield put(&#123;type: \"FETCH_SUCCEEDED\", data&#125;); &#125; catch (error) &#123; yield put(&#123;type: \"FETCH_FAILED\", error&#125;); &#125;&#125; 然后在每次 FETCH_REQUESTED action 被发起时启动上面的任务 12345678function* watchFetchData() &#123; while(true)&#123; yield take('FETCH_REQUESTED'); yield fork(fetchData); &#125;&#125; takeLatest在上面的例子中，takeEvery 允许多个 fetchData 实例同时启动，在某个特定时刻，我们可以启动一个新的 fetchData 任务， 尽管之前还有一个或多个 fetchData 尚未结束如果我们只想得到最新那个请求的响应（例如，始终显示最新版本的数据），我们可以使用 takeLatest 辅助函数 12345import &#123; takeLatest &#125; from 'redux-saga'function* watchFetchData() &#123; yield* takeLatest('FETCH_REQUESTED', fetchData)&#125; 和takeEvery不同，在任何时刻 takeLatest 只允许执行一个 fetchData 任务，并且这个任务是最后被启动的那个，如果之前已经有一个任务在执行，那之前的这个任务会自动被取消 二，redux-saga框架提供了很多创建effect的函数，下面我们就来简单的介绍下开发中最常用的几种 take(pattern) put(action) call(fn, …args) fork(fn, …args) select(selector, …args) 1,take(pattern)take函数可以理解为监听未来的action，它创建了一个命令对象，告诉middleware等待一个特定的action， Generator会暂停，直到一个与pattern匹配的action被发起，才会继续执行下面的语句，也就是说，take是一个阻塞的 effect用法：1234567function* watchFetchData() &#123; while(true) &#123; // 监听一个type为 'FETCH_REQUESTED' 的action的执行，直到等到这个Action被触发，才会接着执行下面的 yield fork(fetchData) 语句 yield take('FETCH_REQUESTED'); yield fork(fetchData); &#125;&#125; 2,put(action)put函数是用来发送action的 effect，你可以简单的把它理解成为redux框架中的dispatch函数，当put一个action后，reducer中就会计算新的state并返回，注意： put 也是阻塞 effect用法：12345678export function* toggleItemFlow() &#123; let list = [] // 发送一个type为 'UPDATE_DATA' 的Action，用来更新数据，参数为 `data：list` yield put(&#123; type: actionTypes.UPDATE_DATA, data: list &#125;)&#125; 3,call(fn, …args)call函数你可以把它简单的理解为就是可以调用其他函数的函数，它命令 middleware 来调用fn 函数， args为函数的参数，注意： fn 函数可以是一个 Generator 函数，也可以是一个返回 Promise 的普通函数，call 函数也是阻塞 effect用法：12345678910export const delay = ms =&gt; new Promise(resolve =&gt; setTimeout(resolve, ms))export function* removeItem() &#123; try &#123; // 这里call 函数就调用了 delay 函数，delay 函数为一个返回promise 的函数 return yield call(delay, 500) &#125; catch (err) &#123; yield put(&#123;type: actionTypes.ERROR&#125;) &#125;&#125; 4,fork(fn, …args)fork 函数和 call 函数很像，都是用来调用其他函数的，但是fork函数是非阻塞函数，也就是说，程序执行完 yield fork(fn， args) 这一行代码后，会立即接着执行下一行代码语句，而不会等待fn函数返回结果后，在执行下面的语句用法：123456789import &#123; fork &#125; from 'redux-saga/effects'export default function* rootSaga() &#123; // 下面的四个 Generator 函数会一次执行，不会阻塞执行 yield fork(addItemFlow) yield fork(removeItemFlow) yield fork(toggleItemFlow) yield fork(modifyItem)&#125; 5,select(selector, …args)select 函数是用来指示 middleware调用提供的选择器获取Store上的state数据，你也可以简单的把它理解为redux框架中获取store上的 state数据一样的功能 ：store.getState()用法：12345export function* toggleItemFlow() &#123; // 通过 select effect 来获取 全局 state上的 `getTodoList` 中的 list let tempList = yield select(state =&gt; state.getTodoList.list)&#125;","categories":[],"tags":[{"name":"Redux","slug":"Redux","permalink":"http://yoursite.com/tags/Redux/"}]},{"title":"redux-actions使用方法","slug":"redux-actions使用方法","date":"2019-10-23T07:58:51.000Z","updated":"2019-10-23T10:44:49.252Z","comments":true,"path":"2019/10/23/redux-actions使用方法/","link":"","permalink":"http://yoursite.com/2019/10/23/redux-actions使用方法/","excerpt":"","text":"安装： npm install –save redux-actions 或是 yarn add redux-actions 具体API使用 包含API: createAction(s), handleAction(s), combineActions 单数的使用demo 复数多个Action 类型的demo 目的是 简化action的编写","categories":[],"tags":[{"name":"Redux","slug":"Redux","permalink":"http://yoursite.com/tags/Redux/"}]},{"title":"Redux-Middleware","slug":"Redux-Middleware-0","date":"2019-10-23T05:57:26.000Z","updated":"2019-10-23T07:46:31.673Z","comments":true,"path":"2019/10/23/Redux-Middleware-0/","link":"","permalink":"http://yoursite.com/2019/10/23/Redux-Middleware-0/","excerpt":"","text":"中间件的概念 中间件就是一个函数,对store.dispatch 方法进行改造，提供是位于action 被发起之后，到达reducer之前的扩展点。 常用在 logger,调用异步接口和路由等。 中间件的用法1234567891011121314151617181920import &#123; applyMiddleware, createStore &#125; from 'redux';import createLogger from 'redux-logger';const logger = createLogger();//用法一：const store = applyMiddleware(logger)(createStore)(reducer);// 对个中间件的使用const store = applyMiddleware(thunk, promise,logger)(createStore)(reducer);// 用法二：const store = createStore( reducer, initial_state, applyMiddleware(logger));// 多个中间件的使用const store = createStore( reducer, initial_state, applyMiddleware(thunk, promise,logger)); 上面代码中，applyMiddleware方法的三个参数，就是三个中间件。有的中间件有次序要求，使用前要查一下文档。比如，logger就一定要放在最后，否则输出结果会不正确。 applyMiddleware() 的源码实现看到这里，你可能会问，applyMiddlewares这个方法到底是干什么的？ 它是 Redux 的原生方法，作用是将所有中间件组成一个数组，依次执行。下面是它的源码。12345678910111213141516171819import compose from './compose'export default function applyMiddleware(...middlewares) &#123; return createStore=&gt;(...args)=&gt;&#123; const store = createStore(...args); let dispatch = ()=&gt;&#123; throw new Error('不允许派发正在构建中的中间件!'); &#125; const middlewareAPI= &#123; getState:store.getState, dispatch:(...args)=&gt;dispatch(...args) &#125; const chain = middlewares.map(middleware=&gt;middleware(middlewareAPI)); dispatch = compose(...chain)(store.dispatch); return &#123; ...store, dispatch &#125; &#125;;&#125; 12345678910111213141516function add1(str)&#123; return '1'+str;&#125;function add2(str)&#123; return '2'+str;&#125;function add3(str)&#123; return '3'+str;&#125;function compose(...funcs)&#123; return funcs.reduce((a,b)=&gt;(...args)=&gt;a(b(...args)));&#125;let result = compose(add3,add2,add1)('zfpx');console.log(result); 常用的中间件 thunk 12345678910111213141516/** * 让你可以发起一个函数来替代 action * 这个函数接收 `dispatch` 和 `getState` 作为参数。*/function createThunkMiddleware(extraArgument) &#123; return (&#123;dispatch,getState&#125;) =&gt; next =&gt; action =&gt; &#123; if (typeof action == 'function') &#123; return action(dispatch, getState, extraArgument); &#125; return next(action); &#125;&#125;const thunk = createThunkMiddleware();thunk.withExtraArgument = createThunkMiddleware;export default thunk; promise 12345678910111213141516function isPromise(obj) &#123; return !!obj &amp;&amp; (typeof obj === 'object' || typeof obj === 'function') &amp;&amp; typeof obj.then === 'function';&#125;export default function promiseMiddleware(&#123; dispatch &#125;) &#123; return next =&gt; action =&gt; &#123; return isPromise(action.payload) ? action.payload .then(result =&gt; dispatch(&#123; ...action, payload: result &#125;)) .catch(error =&gt; &#123; dispatch(&#123; ...action, payload: error, error: true &#125;); return Promise.reject(error); &#125;) : next(action); &#125;;&#125; logger 12345export default store =&gt; dispatch =&gt; action=&gt;&#123; console.log(store.getState().number); dispatch(action); console.log(store.getState().number)&#125;; 详细还得看文档","categories":[],"tags":[{"name":"Redux","slug":"Redux","permalink":"http://yoursite.com/tags/Redux/"}]},{"title":"React-Redux 的用法","slug":"React-Redux","date":"2019-10-22T03:56:52.000Z","updated":"2019-11-04T07:33:05.451Z","comments":true,"path":"2019/10/22/React-Redux/","link":"","permalink":"http://yoursite.com/2019/10/22/React-Redux/","excerpt":"","text":"React-Redux 定义：是把react的组件和redux 的数据流关联起来的一个专用库。可用也可以不用。 对组件的分类 ：React-Redux 将所有组件分成了两大类： UI 组件和容器组件第一 UI组件有一下特征： 只负责 UI 的呈现，不带任何的业务逻辑 没有状态（既不使用this.state 这个变量） 所有数据都由参数（this.props)提供 不适用任何 Redux的API 第二： 容器组件主要特征： 负责管理数据和业务逻辑， 不负责UI的呈现 带有内部状态 使用Redux 的API 总之就是， UI组件负责UI呈现， 容器组件负责管理数据和逻辑如果一个组件既有UI 又有 业务逻辑的话吗？ 就需要将它拆分成下面的结构：外面是一个容器组件， 里面包含一个UI 组件。前者负责与外部通信，将数据传给后者， 有后者渲染出视图 React-Redux 规定 所有的UI 组件都有用户提供， 容器组件则是由 React-Redux 自动生成。也就是说， 用户负责视觉层， 状态管理则是全部交给它 React-Redux API 第一：connect()React-Redux 提供了 connect(), 用于从UI组件生成容器组件， 就是讲两种组件连起来。 123import &#123; connect&#125; from 'react-redux'const VisibleTodoList = connect()(TodoList) TodoList 是UI组件， VisibleTodoList 就是有React-redux 通过connect 方法自动生成的容器组件但是，因为没有业务逻辑， 上面的容器组件毫无意义。 只是UI组件的一个单纯包装， 为了定义业务逻辑，需要给出下面两方面的信息 (1) 输入逻辑： 外部的数据（即 state 对象） 如何转化为UI组件的参数 (2) 输出逻辑： 用户发出的动作如何变为 Action对象，从UI 组件传出去。 因此 connect 方法的完整API 如下： 12345import &#123; connect &#125; from 'react-redux'const VisibleTodoList = connect( mapStateToProps, mapDispatchToProps)(TodoList) 上面代码中， connect 方法接受两个参数 maoStateToProps 和mapDispatchToProps .他们定义了UI组件的业务逻辑。前者负责输入逻辑，即将state 映射到UI 组件的参数（props)， 后者负责输出逻辑，即将用户对UI 组件的操作映射成Action. 2，mapStateToProps() mapStateToProps是一个函数，作用呢，就是建立一个从外部的state 对象到UI组件的props 对象的映射关系。作为函数mapStateToProps 执行后应该返回一个对象， 里面的每一个键值对就是一个映射。 1const mapStateToProps =(state ,ownProps)=&gt;(&#123;state:state.todos&#125;) 使用ownProps作为参数后，如果容器组件的参数放生了变化，也会引起UI 组件重新渲染connect 方法可以省略此参数， 那样的话 UI组件就不会订阅store, 也就是说store 的更新不会引起UI组件的更新 3，mapDispatchToProps() mapDispatchToProps是connect函数的第二个参数，用来建立 UI 组件的参数到store.dispatch方法的映射。也就是说，它定义了哪些用户的操作应该当作 Action，传给 Store。它可以是一个函数，也可以是一个对象。 如果mapDispatchToProps是一个对象，它的每个键名也是对应 UI 组件的同名参数，键值应该是一个函数，会被当作 Action creator ，返回的 Action 会由 Redux 自动发出。举例来说，上面的mapDispatchToProps可以直接用actions 代替代码如下： 123456import actions from '../store/actions/counter'export default connect( state =&gt;state.todolist, actions)(TodoList) actions的对象内容：12345678910111213141516171819import * as types from '../actions-type'export default &#123; add()&#123; return &#123;type:types.ADD&#125; &#125;, asyncAdd()&#123; return function(dispatch)&#123; setTimeout(() =&gt; &#123; dispatch(&#123; type:types.ADD &#125;) &#125;, 1000); &#125; &#125;&#125; 也可以是一个函数，会得到dispatch 和ownProps两个参数12345678910111213const mapDispatchToProps = ( dispatch, ownProps) =&gt; &#123; return &#123; add: () =&gt; &#123; dispatch(&#123; type: 'ADD', filter: ownProps.filter &#125;); &#125; &#125;;&#125; 第二： Provider 组件 解决问题： 将state对象作为参数，一层层很麻烦传入需要的容器组件。 React-Redux 提供的Provider 组件，可以让容器组件拿到store里面的state数据、12345678910111213import &#123; Provider &#125; from 'react-redux'import &#123; createStore &#125; from 'redux'import todoApp from './reducers'import App from './components/App'let store = createStore(todoApp);render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')) 上面代码中，Provider在根组件外面包了一层，这样一来，App的所有子组件就默认都可以拿到state了。 它的原理是React组件的context属性，请看源码 1234567891011121314151617181920212223import React, &#123; Component &#125; from 'react'import PropTypes from 'prop-types'import &#123; ReactReduxContext &#125; from './Context'export default class Provider extends Component &#123; static propTypes = &#123; store: PropTypes.shape(&#123; subscribe: PropTypes.func.isRequired, dispatch: PropTypes.func.isRequired, getState: PropTypes.func.isRequired &#125;), children: PropTypes.any &#125; constructor(props) &#123; super(props) &#125; render() &#123; return ( &lt;ReactReduxContext.Provider value=&#123;&#123;store:this.props.store&#125;&#125;&gt; &#123;this.props.children&#125; &lt;/ReactReduxContext.Provider&gt; ) &#125;&#125; 由于新版实现的原理是利用React上下文（context)所以 消费传递属性值也一样，如下： 类组件中使用12345678910111213141516171819202122232425const ThemeContext = React.createContext('light');class App extends React.Component &#123; render() &#123; return ( &lt;ThemeContext.Provider value=\"dark\"&gt; &lt;Toolbar /&gt; &lt;/ThemeContext.Provider&gt; ); &#125;&#125;function Toolbar(props) &#123; return ( &lt;div&gt; &lt;ThemedButton /&gt; &lt;/div&gt; );&#125;class ThemedButton extends React.Component &#123; static contextType = ThemeContext; render() &#123; return &lt;Button theme=&#123;this.context&#125; /&gt;; &#125;&#125; 2,函数组件中使用 1234567891011121314151617181920import &#123;ThemeContext&#125; from './theme-context';function ThemeTogglerButton() &#123; // The Theme Toggler Button receives not only the theme // but also a toggleTheme function from the context return ( &lt;ThemeContext.Consumer&gt; &#123;(&#123;theme, toggleTheme&#125;) =&gt; ( &lt;button onClick=&#123;toggleTheme&#125; style=&#123;&#123;backgroundColor: theme.background&#125;&#125;&gt; Toggle Theme &lt;/button&gt; )&#125; &lt;/ThemeContext.Consumer&gt; );&#125;export default ThemeTogglerButton; 其他更多使用请参考 react-context的使用","categories":[{"name":"Redux","slug":"Redux","permalink":"http://yoursite.com/categories/Redux/"}],"tags":[{"name":"Redux","slug":"Redux","permalink":"http://yoursite.com/tags/Redux/"}]},{"title":"Reux-Store","slug":"Reux-store","date":"2019-10-21T06:56:52.000Z","updated":"2019-10-23T03:23:10.554Z","comments":true,"path":"2019/10/21/Reux-store/","link":"","permalink":"http://yoursite.com/2019/10/21/Reux-store/","excerpt":"","text":"##store store 就是一个保存数据的地方， 你可以把它看成一个容器， 整个应用中只能有一个store. store 的由来redux 提供了createStore 这个函数来生成store 12import &#123; createStore &#125; from 'redux';const store = createStore(reducer); store 包含大部分 State, Action, subscribe 1,state state 对象包含所有数据。如果想要的到某个时间点的数据。 就要对Store 生成快照。这中点的数据集合，就叫做state.是一个对象。 查看当前的state,可以通过store.getState() 拿到12345import &#123; createStore &#125; from 'redux';const store = createStore(reducer);const state = store.getState(); Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。 2,Action 派发动作redux里面的源码理解Action部分 3,Reducer Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。 Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。 12345const reducer = function(state,action)&#123; //... return newState&#125; 整个应用的初始状态，可以作为 State 的默认值。下面是一个实际的例子。 1234567891011121314const defaultState = 0;const reducer = (state = defaultState, action) =&gt; &#123; switch (action.type) &#123; case 'ADD': return state + action.payload; default: return state; &#125;&#125;;const state = reducer(1, &#123; type: 'ADD', payload: 2&#125;); 上面代码中，reducer函数收到名为ADD的 Action 以后，就返回一个新的 State，作为加法的计算结果。其他运算的逻辑（比如减法），也可以根据 Action 的不同来实现。 实际应用中，Reducer 函数不用像上面这样手动调用，store.dispatch方法会触发 Reducer 的自动执行。为此，Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入createStore方法。 12import &#123; createStore &#125; from 'redux';const store = createStore(reducer); Reducer 函数最重要的特征是，它是一个纯函数。也就是说，只要是同样的输入，必定得到同样的输出。 4, store.subscribe()Store 允许使用store.subscribe方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。1234import &#123; createStore &#125; from 'redux';const store = createStore(reducer);store.subscribe(listener); store.subscribe方法返回一个函数，调用这个函数就可以解除监听。 12345let unsubscribe = store.subscribe(() =&gt; console.log(store.getState()));unsubscribe(); store的源码实现上一节介绍了 Redux 涉及的基本概念，可以发现 Store 提供了三个方法。 store.getState() store.dispatch() store.subscribe() 12import &#123; createStore &#125; from 'redux';let &#123; subscribe, dispatch, getState &#125; = createStore(reducer); createStore方法还可以接受第二个参数，表示 State 的最初状态。这通常是服务器给出的。 12import &#123; createStore &#125; from 'redux';let store = createStore(reducer, window.STATE_FROM_SERVER) 上面代码中，window.STATE_FROM_SERVER就是整个应用的状态初始值。注意，如果提供了这个参数，它会覆盖 Reducer 函数的默认初始值。 1234567891011121314151617181920212223242526272829303132333435export default function createStore(reducer, preloadedState) &#123; let currentState = preloadedState; let listeners = []; function getState() &#123; return currentState; &#125; function subscribe(listener) &#123; listeners.push(listener); return function unsubscribe() &#123; listeners = listeners.filter(l=&gt;l!==listener) &#125;; &#125; function dispatch(action) &#123; if (Object.getPrototypeOf(action) !== Object.prototype) &#123; throw new Error(`动作必须是一个纯对象，如果想进行异步操作请使用中间件`); &#125; if (typeof action.type === \"undefined\") &#123; throw new Error(`动作不能一个值为undefined的type属性`); &#125; currentState = reducer(currentState, action); listeners.forEach(listener=&gt;listener()) &#125; dispatch(&#123; type:'@@redux/INIT' &#125;); return &#123; dispatch, subscribe, getState &#125;;&#125;","categories":[],"tags":[{"name":"Redux","slug":"Redux","permalink":"http://yoursite.com/tags/Redux/"}]},{"title":"Reux-reducer","slug":"Reux-reducer","date":"2019-10-21T03:56:52.000Z","updated":"2019-10-23T03:42:02.764Z","comments":true,"path":"2019/10/21/Reux-reducer/","link":"","permalink":"http://yoursite.com/2019/10/21/Reux-reducer/","excerpt":"","text":"Reducer定义： Reducer指定了应用状态的变化如何响应actions 并发送到store的， 记住actions只是描述了有事情发生可这一事实，并没哟描述应用如何更新 state Reducer 就是一个纯函数，接受旧的state 和action , 返回新的state. Reducer 用来处理Action Reducer 拆分Reducer 函数负责生成 State。由于整个应用只有一个 State 对象，包含所有数据，对于大型应用来说，这个 State 必然十分庞大，导致 Reducer 函数也十分庞大。我们就需要把Reducer 函数被拆成一个个小函数，每一个负责生成对应的属性。 Redux 提供了一个combineReducers方法，用于 Reducer 的拆分。你只要定义各个子 Reducer 函数，然后用这个方法，将它们合成一个大的 Reducer。 12345678910import &#123; combineReducers &#125; from 'redux';const Reducers = combineReducers(&#123; chatLog, statusMessage, userName&#125;)export default todoApp; 上面的代码通过combineReducers方法将三个子 Reducer 合并成一个大的函数。这种写法有一个前提，就是 State 的属性名必须与子 Reducer 同名。如果不同名，就要采用下面的写法。 1234567891011121314const reducer = combineReducers(&#123; a: doSomethingWithA, b: processB, c: c&#125;)// 等同于function reducer(state = &#123;&#125;, action) &#123; return &#123; a: doSomethingWithA(state.a, action), b: processB(state.b, action), c: c(state.c, action) &#125;&#125; 总之，combineReducers()做的就是产生一个整体的 Reducer 函数。该函数根据 State 的 key 去执行相应的子 Reducer，并将返回结果合并成一个大的 State 对象。 combineReducers() 实现： 1234567891011121314export default function combineReducers(reducers) &#123; const reducerKeys = Object.keys(reducers) return function combination(state = &#123;&#125;, action) &#123; const nextState = &#123;&#125; for (let i = 0; i &lt; reducerKeys.length; i++) &#123; const key = reducerKeys[i]; const reducer = reducers[key]; const previousStateForKey = state[key]; const nextStateForKey = reducer(previousStateForKey, action); nextState[key] = nextStateForKey; &#125; return nextState; &#125;&#125;","categories":[],"tags":[{"name":"Redux","slug":"Redux","permalink":"http://yoursite.com/tags/Redux/"}]},{"title":"React-lifeCycle","slug":"React-lifeCycle","date":"2019-09-03T11:29:34.000Z","updated":"2019-11-07T08:38:12.257Z","comments":true,"path":"2019/09/03/React-lifeCycle/","link":"","permalink":"http://yoursite.com/2019/09/03/React-lifeCycle/","excerpt":"","text":"旧版的生命周期 如何初始化state 和 props 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970export default class Counter extends React.Component&#123; static defaultProps =&#123; //1， 设置默认值 name:'石头' &#125; constructor(props)&#123; super(props) // 2.初始化state 和props this.state =&#123;number:0&#125; console.log('1, constructor 初始化属性对象和状态对象') &#125; // componentWillMount 在渲染过程中会多次渲染。会多次调用接口等， componentWillMount()&#123;// 虚拟Dom 转化成真实dom 的过程 console.log('2.组件将要加载 componentWillMount'); &#125; // 一般在组件挂载调用副作用，因为只渲染依次 componentDidMount()&#123; console.log('4.组件挂载完成 componentDidMount'); &#125; handleClick=()=&gt;&#123; this.setState(&#123;number:this.state.number+1&#125;); &#125; shouldComponentUpdate(nextProps,nextState)&#123; console.log('5.组件是否更新 shouldComponentUpdate'); return nextState.number%2; &#125; componentWillUpdate()&#123; console.log('6.组件将要更新 componentWillUpdate'); &#125; componentDidUpdate()&#123; console.log('7.组件完成更新 componentDidUpdate'); &#125; render()&#123; console.log('3.render') return(&lt;div style=&#123;&#123;border:'1px solid black'&#125;&#125;&gt; &lt;p&gt;&#123;this.state.number&#125;&lt;/p&gt; &#123;this.state.number%2===0?null:&lt;ChildCounter n=&#123;this.state.number&#125;/&gt;&#125; &lt;button onClick=&#123;this.handleClick&#125;&gt;+&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;class ChildCounter extends React.Component&#123; componentWillUnmount()&#123; console.log('组件将要卸载componentWillUnmount') &#125; componentWillMount()&#123; console.log('child componentWillMount') &#125; render()&#123; console.log('child-render') return (&lt;div style=&#123;&#123;border:'1px solid red'&#125;&#125;&gt; &#123;this.props.n&#125; &lt;/div&gt;) &#125; componentDidMount()&#123; console.log('child componentDidMount') &#125; componentWillReceiveProps(newProps)&#123; // 第一次不会执行，之后属性更新时才会执行 console.log('child componentWillReceiveProps') &#125; shouldComponentUpdate(nextProps,nextState)&#123; return nextProps.n%2==0; //子组件判断接收的属性 是否满足更新条件 为true则更新 &#125; &#125; 思考：为什么异步副作用放在componentDidMount()里而不是componentWillUnmount等其他生命周期函数里 新版生命周期函数图 新旧区别 去掉 三个生命周期函数 componentWillMount() componentWillUpdate() componentWillReceiveProps() 添加两个生命周期函数数 getDerivedStateFromProps() 根据新的属性对象派生状态对象 是一个静态方法 两个参数， 新的属性对象和旧的状态对象 ，不用调用setState(),就能更新界面getDerivedStateFromProps-demo getSnapshotBeforeUpdate() getSnapshotBeforeUpdate() 被调用于render之后，可以读取但无法使用DOM的时候。它使您的组件可以在可能更改之前从DOM捕获一些信息（例如滚动位置）。此生命周期返回的任何值都将作为参数传递给componentDidUpdate()getSnapshotBeforeUpdate-demo","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"前端每日一题","slug":"前端每日一题","date":"2019-07-09T11:02:01.000Z","updated":"2019-10-20T13:27:35.562Z","comments":true,"path":"2019/07/09/前端每日一题/","link":"","permalink":"http://yoursite.com/2019/07/09/前端每日一题/","excerpt":"","text":"第一题 写React 项目时为什么要在列表组件中写key,其作用是什么？ 1, 因为不写运行这段代码，将会看到一个警告 a key should be provided for list items，意思是当你创建一个元素时，必须包括一个特殊的 key 属性。 2, key 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。 3,一个元素的 key 最好是这个元素在 列表中 拥有的一个独一无二的字符串。通常，我们使用来自数据 id 来作为元素的 key. 注意 当元素没有确定 id 的时候，万不得已你可以使用元素索引 index 作为 key：如果列表项目的顺序可能会变化，我们不建议使用索引来用作 key 值，因为这样做会导致性能变差，还可能引起组件状态的问题。如果你选择不指定显式的 key 值，那么 React 将默认使用索引用作为列表项目的 key 值","categories":[],"tags":[]},{"title":"React-ref","slug":"React-ref","date":"2018-09-02T12:29:34.000Z","updated":"2019-11-07T03:27:09.462Z","comments":true,"path":"2018/09/02/React-ref/","link":"","permalink":"http://yoursite.com/2018/09/02/React-ref/","excerpt":"","text":"Ref Ref 提供了一种方式，允许我们访问DOM 节点或者在render 方法中创建的React 元素。 在React 渲染生命周期时，表单元素上的value 将会覆盖DOM 节点的值， 在非受控组件中，经常希望Rect能赋予组件一个初始值，但是不去控制后续的更新。在这种情况下，你可以指定一个defaultValue属性，而不是value Ref 的使用方式 ref 的值是一个字符串 12345678910111213141516171819// ref 的值是一个字符串class Sum extends React.Component&#123; handleAdd=(e)=&gt;&#123; let a = this.refs.a.value; let b = this.refs.b.value this.refs.c.value = a+b; &#125; render()&#123; return( &lt;div&gt; // ref =‘字符串’ &lt;input ref=\"a\"/&gt; + &lt;input ref='b' /&gt; &lt;button onClick=&#123;this.handleAdd&#125;&gt;=&lt;/button&gt; &lt;input ref=\"c\" /&gt; &lt;/div&gt; ) &#125;&#125; 结果是 ab 的链接, this.refs.a.value 的返回来是字符串。输入是1+2 结果是’12’. ref 的值是一个函数 1234567891011121314151617class Sum2 extends React.Component&#123; handleAdd=(e)=&gt;&#123; let a = this.a.value; let b = this.b.value; // a,b 都是字符串，数字需要用parseIn() 转义一下 this.result.value = a+b &#125; render()&#123; return( &lt;div&gt; // ref= 函数 &lt;input ref=&#123;ref=&gt;this.a=ref&#125;/&gt; + &lt;input ref=&#123;ref =&gt; this.b =ref&#125; /&gt; &lt;button onClick=&#123;this.handleAdd&#125;&gt;=&lt;/button&gt; &lt;input ref=&#123;ref=&gt;this.result=ref&#125;/&gt; &lt;/div&gt;) &#125;&#125; 以上都是老的写法，最新版本的为DOM 元素添加ref 12345678910111213141516171819202122class Sum3 extends React.Component&#123; constructor(props)&#123; super(props) this.a = React.createRef(); this.b = React.createRef(); this.result = React.createRef(); &#125; handleAdd=(e)=&gt;&#123; let a = this.a.current.value; let b = this.b.current.value; // a,b 都是字符串，数字需要用parseIn() 转义一下 this.result.current.value = a+b &#125; render()&#123; return( &lt;div&gt; &lt;input ref=&#123;this.a&#125;/&gt; + &lt;input ref=&#123;this.b&#125; /&gt; &lt;button onClick=&#123;this.handleAdd&#125;&gt;=&lt;/button&gt; &lt;input ref=&#123;this.result&#125;/&gt; &lt;/div&gt;) &#125;&#125; 通过上面代码可以看出， 有三点不同：1,可以使用 ref 去存储 DOM 节点的引用2, 当 ref 属性用于 HTML 元素时，构造函数中使用 React.createRef() 创建的 ref 接收底层 DOM 元素作为其 current 属性 为组件添加ref 属性 ref属性用在自定义class组件上 12345678910111213141516171819202122232425262728293031323334import React from \"react\";import ReactDOM from 'react-dom';export default class Form extends React.Component&#123; constructor(props)&#123; super(props) this.input = React.createRef(); &#125; getFocus=()=&gt;&#123; this.input.current.getFocus() console.log(this.input.current) &#125; render()&#123; return( &lt;div&gt; &lt;TextInput ref =&#123;this.input&#125;/&gt; &lt;button onClick=&#123;this.getFocus&#125;&gt;=&lt;/button&gt; &lt;/div&gt;) &#125;&#125;class TextInput extends React.Component&#123; constructor(props)&#123; super(props); this.input = React.createRef(); &#125; getFocus =()=&gt;&#123; this.input.current.focus(); &#125; render()&#123; return &lt;input ref=&#123;this.input&#125;/&gt; &#125;&#125; 总结： 当 ref 属性用于自定义 class 组件时，ref 对象接收组件的挂载实例作为其 current 属性 ref添加到函数组件的使用方法 由于函数组件上没有实例， 所以不能再函数上使用ref 属性，但是可以使用转发来解决 Ref 转发是一项将ref自动地通过组件传递到其一子组件的技巧 Ref 转发允许某些组件接受ref, 并将其向下传递（换句话“转发”它 给子组件） 123456789101112131415161718192021222324252627282930export default class Form extends React.Component&#123; constructor(props)&#123; super(props) this.input = React.createRef(); &#125; getInput=()=&gt;&#123; console.log( this.input.current ) &#125; add=()=&gt;&#123; console.log('add') &#125; render()&#123; return( &lt;div&gt; &lt;TextInput ref =&#123;this.input&#125; onClick=&#123;this.add&#125; /&gt; &lt;button onClick=&#123;this.getInput&#125;&gt;=&lt;/button&gt; &lt;/div&gt;) &#125;&#125;// 函数组件// function TextInput()&#123;// return &lt;input /&gt;// &#125;const TextInput = React.forwardRef((props,ref)=&gt;&#123; return &lt;input ref=&#123;ref&#125; /&gt;&#125; )","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"React-State& 生命周期","slug":"React-State","date":"2018-08-28T09:45:34.000Z","updated":"2019-11-07T05:58:04.107Z","comments":true,"path":"2018/08/28/React-State/","link":"","permalink":"http://yoursite.com/2018/08/28/React-State/","excerpt":"","text":"state 组件的数据来源有两个地方， 分别是 props属性对象和 state 状态对象 属性是父组件传递过来的，不能修改，只能读 状态state 是私有的，并且完全受控于当前组件， 改变状态唯一的方法就是 setState 属性和状态的改变都会影响视图的更新 在构造函数里，是唯一可以给this.state 赋初始值得地方 123456789101112131415class Clock extends React.Component&#123; constructor(props)&#123; super(props) // 唯一可以给state赋初始值的地方 this.state = &#123; date: new Date().toLocaleTimeString() &#125; &#125; render()&#123; return&lt;div&gt;&#123;this.state.date&#125;&lt;/div&gt; &#125;&#125;ReactDOM.render(&lt;Clock /&gt;,document.getElementById('root')) 唯一修改state值方法 12345678910111213141516171819202122class Clock extends React.Component&#123; constructor(props)&#123; super(props) // 唯一可以给state赋初始值的地方 this.state = &#123; date: new Date().toLocaleTimeString() &#125; &#125; // 组件挂载完成之后 componentDidMount()&#123; this.timer = setInterval(()=&gt;&#123; // 使用 this.setState() 来时刻更新组件 state： this.setState(&#123;date:new Date().toLocaleTimeString()&#125;) &#125;,1000) &#125; componentWillUnmount()&#123; clearInterval(this.timer) &#125; render()&#123; return&lt;div&gt;时间:&#123;this.state.date&#125;&lt;/div&gt; &#125;&#125; 正确的使用state关于setState(),应该了解三件事： 不要直接修改state,而是使用setState() State 的更新可能是异步的 处于性能考虑，React 可能会把多个setState() 调用合并成一个调用 由于this.props 和this.state 肯能会异步更新， 所以不要依赖他们的值来更新下一个状态1234// 这样写是错误的 this.setState(&#123; number: this.state.counter+this.props.increment &#125;) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Counter extends React.Component&#123; constructor(props)&#123; super(props) // 唯一可以给state赋初始值的地方 this.state = &#123; number:0 &#125; &#125; // 这个方法是直接 赋给组件实例上的， 而不是放在原型上的 // 判断依据是console.log(this) 你看看就知道了 add=()=&gt;&#123; // 会改变状态值， 但是不会重新render 渲染组件 // this.state.number = this.state.number+1 //修改state this.setState(&#123; number:this.state.number+1 &#125;) // 强制更新，不管状态和属性有没有修改，都会强制刷新界面 this.forceUpdate() // this.setState() 可能是异步的 this.setState(&#123; number:this.state.number+1 &#125;) console.log(this.state.number) this.setState(&#123; number:this.state.number+1 &#125;) console.log(this.state.number) this.setState(&#123; number:this.state.number+1 &#125;) console.log(this.state.number) &#125; render()&#123; return( &lt;div&gt; &lt;p&gt;&#123;this.state.number&#125;&lt;/p&gt; &lt;button onClick=&#123;this.add&#125;&gt;+++++&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 结果是每次console.log(this.state.number) 都是0 ,而页面上显示是1，因为0+1 =1 解决这个问题， 可以让setState() 接受一个函数而不是一个对象。这个函数第一个参数是上一个state, 将此次更新的被应用时的props 做为第二个参数1234this.setState((state,props)=&gt;(&#123; number: state.couter+props.increment&#125;)) 在此使用箭头函数和普通函数是一样的。12345this.setState(function(state,props)&#123; return &#123; number:state.counter+props.increment &#125;&#125;) 原理：当调用setState 的时候， 其实状态并没有直接改变， 而是放入一个队列当中 State 的更新会被合并当你调用 setState()的时候,React 会把你提供的对象合并到当前的state. 12345678910111213141516171819constructor(props)&#123; super(props) this.state = &#123; posts:[], comments:[] &#125;&#125;componentDidMount()&#123; fetchPosts().then(response=&gt;&#123; this.setState(&#123; posts:response.posts &#125;) &#125;) fetchComments().then(response=&gt;&#123; this.setState(&#123; comments:response.comments &#125;) &#125;)&#125; 这里的合并是浅合并，所以this.setState({comments}) 完全保留了this.state.posts,但是替换了this.state.comments this.forceUpdate() 强制更新，不管状态和属性有没有修改，都会强制刷新界面 。一般不常用 数据是向下流动的 不管是父组件或是子组件都无法知道某个组件是有状态的还是无状态的，并且它们也并不关心它是函数组件还是 class 组件 这就是为什么称 state 为局部的或是封装的的原因,除了拥有并设置了它的组件，其他组件都无法访问 组件可以选择把它的 state 作为 props 向下传递到它的子组件中： 任何的 state 总是所属于特定的组件，而且从该 state 派生的任何数据或 UI 只能影响树中“低于”它们的组件 如果你把一个以组件构成的树想象成一个 props 的数据瀑布的话，那么每一个组件的 state 就像是在任意一点上给瀑布增加额外的水源，但是它只能向下流动","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"React-event&this","slug":"React-this","date":"2018-08-27T12:29:34.000Z","updated":"2019-11-07T00:51:11.294Z","comments":true,"path":"2018/08/27/React-this/","link":"","permalink":"http://yoursite.com/2018/08/27/React-this/","excerpt":"","text":"React事件处理 React 事件的命名采用是小驼峰式（camelCase)，原生BOM 是纯小写。 使用jsx 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串 不能通过返回false 的方式阻止默认行为。 你必须使用 preventDefault 12345678910111213141516171819202122import React from 'react';import ReactDOM from 'react-dom';class Link extends React.Component &#123; handleClick(e) &#123; e.preventDefault(); console.log('The link was clicked.'); &#125; render() &#123; return ( &lt;a href=\"http://www.baidu.com\" onClick=&#123;this.handleClick&#125;&gt; Click me &lt;/a&gt; ); &#125;&#125;ReactDOM.render( &lt;Link /&gt;, document.getElementById('root')); React 里面的this 问题 必须谨慎对待 JSX 回调函数中的 this,在JavaScript中， class 的方法默认是不会绑定this.如果忘记绑定this.handleClick 并把它传入了 onClick ,在调用这个函数的时候 this 的值为 undefined。 可以使用: 公共属性(箭头函数) 123456789101112131415class LoggingButton extends React.Component &#123; // 此语法确保 `handleClick` 内的 `this` 已被绑定。 // 注意: 这是 *实验性* 语法。 handleClick = () =&gt; &#123; console.log('this is:', this); &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; Click me &lt;/button&gt; ); &#125;&#125; 匿名函数 1234567891011121314class LoggingButton extends React.Component &#123; handleClick() &#123; console.log('this is:', this); &#125; render() &#123; // 此语法确保 `handleClick` 内的 `this` 已被绑定。 return ( &lt;button onClick=&#123;(e) =&gt; this.handleClick(e)&#125;&gt; Click me &lt;/button&gt; ); &#125;&#125; bind进行绑定 1234567891011121314151617181920212223242526272829303132class Toggle extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;isToggleOn: true&#125;; // 为了在回调中使用 `this`，这个绑定是必不可少的 this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; this.setState(state =&gt; (&#123; isToggleOn: !state.isToggleOn &#125;)); &#125; render() &#123; return ( // &lt;button onClick=&#123;this.handleClick.bind()&#125;&gt; // ... // &lt;/button&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt; &#123;this.state.isToggleOn ? 'ON' : 'OFF'&#125; &lt;/button&gt; ); &#125;&#125;ReactDOM.render( &lt;Toggle /&gt;, document.getElementById('root')); 向事件处理程序传递参数的方式 匿名函数 bind 123456789101112131415161718class LoggingButton extends React.Component &#123; handleClick1 = (id,event) =&gt; &#123; console.log('id:', id); &#125; render() &#123; return ( &lt;&gt; &lt;button onClick=&#123;(event) =&gt; this.handleClick('1',event)&#125;&gt; Click me &lt;/button&gt; &lt;button onClick=&#123;this.handleClick.bind(this,'1')&#125;&gt; Click me &lt;/button&gt; &lt;/&gt; ); &#125;&#125;","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"React-Component&props","slug":"React-Component","date":"2018-08-25T12:16:34.000Z","updated":"2019-11-06T08:24:05.307Z","comments":true,"path":"2018/08/25/React-Component/","link":"","permalink":"http://yoursite.com/2018/08/25/React-Component/","excerpt":"","text":"组件含义 组件允许你将 UI 拆分为独立可复用的代码片段，并对每个片段进行独立构思。 组件从概念上类似于 JavaScript 函数。 它接受任意的入参（即” props “),并返回用于描述页面展示内容的React 元素 组件的分类 函数组件 123function welcome(props)&#123; return &lt;h1&gt;hello,&#123;props.name&#125;&lt;/h1&gt;&#125; 该函数是一个有效的 React 组件，因为它接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素。这类组件被称为“函数组件”，因为它本质上就是 JavaScript 函数。 ES6的class 来定义组件 123456class welcom extends React.Component&#123; render()&#123; return &lt;h1&gt;hello,&#123;this.props.name&#125;&lt;/h1&gt; &#125;&#125; 复合组件 组件由于嵌套变得难以被修改，可复用的部分也难以被复用，所以可以把大组件切分为更小的组件 然后在组合到一起使用的大组件就成为复合组件 123456789101112131415161718function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;function App() &#123; return ( &lt;div&gt; &lt;Welcome name=\"Sara\" /&gt; &lt;Welcome name=\"Cahal\" /&gt; &lt;Welcome name=\"Edite\" /&gt; &lt;/div&gt; );&#125;ReactDOM.render( &lt;App /&gt;, document.getElementById('root')); 每个新的 React 应用程序的顶层组件都是 App 组件。但是，如果你将 React 集成到现有的应用程序中，你可能需要使用像 Button 这样的小组件，并自下而上地将这类组件逐步应用到视图层的每一处 提取组件将组件拆分为更小的组件小组件的命名建议从组件自身的角度命名props. 而不是依赖于调用组件的上下文命名。 组件的渲染 React 元素不但是 DOM 标签，还可以是用户自定义的组件 组件名称必须以大写字母开头 props 当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）转换为单个对象传递给组件，这个对象被称之为 “props”。 props是用来收集属性对象的 123let data =&#123;name:'shitou',age:3&#125;// 展开对象，传递参数ReactDOM.render(&lt;welcome &#123;...data&#125; /&gt;,document.getElementById('root')) Props 的只读性 组件无论是使用函数声明还是通过 class 声明，都决不能修改自身的 props。 纯函数没有改变它自己的输入值，当传入的值相同时，总是会返回相同的结果 所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"React-element","slug":"React-element","date":"2018-08-23T13:22:34.000Z","updated":"2019-11-06T07:18:00.618Z","comments":true,"path":"2018/08/23/React-element/","link":"","permalink":"http://yoursite.com/2018/08/23/React-element/","excerpt":"","text":"React 元素的理解 元素是构成React 应用的最小砖块 元素是描述你在屏幕上想看到的内容 元素就是一个普通对象 123456789101112&#123; &quot;type&quot;:&quot;h1&quot;, &quot;props&quot;:&#123; &quot;className&quot;:&quot;title&quot;, &quot;children&quot;:[&quot;hello&quot;,&#123; &quot;type&quot;:&quot;span&quot;, &quot;props&quot;:&#123; &quot;children&quot;:&quot;world&quot; &#125; &#125;] &#125;&#125; 注意： children 可能是字符串和数组 React 元素与DOM元素的不同React 元素是创建开销极小的普通对象。 React DOM会负责更新DOM来与React元素保持一致。 如何渲染一个React 元素12const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;ReactDOM.render(element, document.getElementById('root')); 想要将一个 React 元素渲染到根 DOM 节点中，只需把它们一起传入 ReactDOM.render()： 如何更新已渲染的元素由于React 元素是不可变对象。一旦被创建，你就无法更改它的子元素或者属性， 更新UI 唯一的方式就是创建一个全新的元素，并将其传入 ReactDOM.render() React 只更新它需要更新的部分 React DOM 会将元素和它的子元素与它们之前的状态进行比较，并只会进行必要的更新来使 DOM 达到预期的状态。","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"React-base","slug":"React-jsx","date":"2018-08-21T12:22:34.000Z","updated":"2019-11-06T07:01:13.696Z","comments":true,"path":"2018/08/21/React-jsx/","link":"","permalink":"http://yoursite.com/2018/08/21/React-jsx/","excerpt":"","text":"第一： React 的理解 定义： React 是用于构建用户界面的JavaScript库，核心专注于视图，目的实现组件化开发。 组件化概念 就是将一个复杂的页面分割成若干个独立的组件，每个组件包含自己的逻辑和样式，再将这些独立组件组合完成一个复杂的页面。 减少了逻辑复杂度，又实现了代码的重用 可组合: 一个组件可以和其他的组件一起使用或者可以直接嵌套在另一个组件内部 可重用: 每个组件都是具有独立功能的，它可以被使用在多个场景中 可维护: 每个小的组件仅仅包含自身的逻辑，更容易被理解和维护 搭建React 开发环境 12345npm i create-react-app -gcreate-react-app react2019cd react2019yarn start 默认会自动安装React。 react.js 是React 的核心库 react-dom.js 是提供与DOM 相关的功能,内部比较重要的方法是render, 他是用来向浏览器里插入Dom 元素的 第二： jsx 1, 什么是JSX1const element = &lt;h1&gt; hello,word&lt;/h1&gt; 上面有趣的标签语法即使不是字符串也不是HTML .它就被称为 jsx . JSX 是javascript 和XML 的一种混合语法。将组件的结构、数据甚至样式都聚合在一起定义组件 JSX 是用来描述界面上的元素长什么样子 JSX 其实只是一种语法糖,最终会通过babeljs转译成createElement语法,以下代码等价 123456789101112const element = ( &lt;h1 className=\"greeting\"&gt; Hello, world! &lt;/h1&gt;);// 等价于const element = React.createElement( 'h1', &#123;className: 'greeting'&#125;, 'Hello, world!'); 2, JSX的属性 需要注意的是JSX并不是html,在JSX中属性不能包含关键字，像class需要写成className,for需要写成htmlFor,并且属性名需要采用驼峰命名法1ReactDOM.render(&lt;h1 id=\" myTitle\" className=\"myTitle\" style=&#123;&#123;color:'red'&#125;&#125;&gt;hello,word&lt;/h1&gt;) 3，JSX表达式 可以任意地在 JSX 当中使用 JavaScript 表达式，在 JSX 当中的表达式要包含在大括号里12345let title = 'hello';ReactDOM.render(&lt;h1&gt;&#123;title&#125;&lt;/h1&gt;,document.getElementById('root')); 4, JSX防止注入攻击React DOM 在渲染所有输入内容之前，默认会进行转义。它可以确保在你的应用中，永远不会注入那些并非自己明确编写的内容。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS（cross-site-scripting, 跨站脚本）攻击。 5, JSX表示对象Babel 会把jsx 转译成一个名为React,createElement() 函数调用。123456789101112const element = ( &lt;h1 className=\"greeting\"&gt; Hello, world! &lt;/h1&gt;);// 等价于const element = React.createElement( 'h1', &#123;className: 'greeting'&#125;, 'Hello, world!'); React.createElement() 会预先执行一些检查，以帮助你编写无错代码，但实际上它创建了一个这样的对象： 123456789// 这是简化过的const element=&#123; type:'h1', props:&#123; className:'greeting', children:' Hello, world' &#125;&#125; element这个对象就叫做 ”React 元素“ 也就做虚拟Dom JSX是一个普通对象， 就可以被用在， if , while , for方法的参数， 以及返回值。 123456789101112let username = 'nuli';function greeting(username)&#123; if(username)&#123; // if return &lt;h1&gt;欢迎&#123;username&#125;&lt;/h1&gt; &#125;else&#123; return &lt;h1&gt;欢迎游客&lt;/h1&gt; &#125;&#125;let element = greeting(username) // 返回值ReactDOM.render(element,document.getElementById('root'))","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"图片延迟加载和懒加载","slug":"图片延迟加载和懒加载","date":"2018-03-06T05:45:46.000Z","updated":"2019-02-23T03:55:04.555Z","comments":true,"path":"2018/03/06/图片延迟加载和懒加载/","link":"","permalink":"http://yoursite.com/2018/03/06/图片延迟加载和懒加载/","excerpt":"","text":"图片延迟加载和图片懒加载的作用：保证页面首次打开的速度。 原理：1，对于首屏内容中的图片处理原理：首先给对应的区域一张默认图片占位(默认图片需要非常小的，一般可以维持在5kb以内),当首屏内容都加载完成后 (或者也可以给定一个延迟的时间)，在开始加载真正的图片 123&lt;div class=\"banner\"&gt; &lt;img src=\"\" trueImg=\"img/banner1.jpg\"&gt;&lt;/div&gt; 样式处理：1234567891011121314.banner&#123; margin: 1000px auto; width: 790px; height: 340px; border: 1px solid #000; // 默认图 background:#f1f1f1 url(\"img/loading.gif\") no-repeat center center;&#125;.banner img&#123; // 在开始的时候img 的src 属性没有地址，这样的话在IE浏览器中的容器中会显示一张碎图，不美观，所以我们让其默认是隐藏的，当真实的图片加载完成后再显示 display: none; width:100%; height:100%;&#125; js 处理：1234567891011121314var banner = document.getElementById(\"banner\");var imgFir = banner.getElementsByTagName(\"img\")[0];window.setTimeout(function()&#123; //获取图片地址，验证地址的有效性，是有效值在赋值。 //不是有效值的话不进行赋值 这样真实图片地址错误的话，控制台会报错。还会出现碎图影响视觉效果 var oImg = new Image // 创建一个临时的IMG标签 oImg.src = imgFir.getAttribute('trueImg') oImg.onLoad = function()&#123; // 当图片正常的加载 imgFir.src = this.src; imgFir.style.display = \"block\"; oImg = null; &#125; &#125;,1000) 2， 对应其他屏内的图片处理原理：也是给一张默认的图片占位，当滚动条滚动到对应的区域的时候，开始加载真实的图片。 123456789101112131415161718window.onscroll = function()&#123; if(banner.isLoad)&#123; // 不需要重复执行下面代码 return; &#125; var A = banner.offsetHeight + utils.offset(banner).top; var B = utils.win(\"clientHeight\") +utils.win(\"scrollTop\"); if(A&lt;B)&#123; var oImg = new Image; oImg.src = imgFir.getAttribute(\"trueImg\"); oImg.onload = function()&#123; imgFir.style.display = \"block\"; imgFir.src = this.src; oImg = null; &#125; // 设置自定义属性告诉浏览器图片已加载完成 banner.isLoad = true; &#125;&#125; demo地址 多张图片延迟加载demo地址 同原理可得：数据的异步加载数据的异步加载 开始也只是把前两屏的数据加载绑定出来。后面的数据不进行处理，当页面滚动到对应的区域的时候在从新请求数据然后绑定","categories":[],"tags":[{"name":"优化技巧","slug":"优化技巧","permalink":"http://yoursite.com/tags/优化技巧/"}]},{"title":"Redux","slug":"Redux","date":"2018-03-05T12:30:21.000Z","updated":"2019-10-23T02:55:39.510Z","comments":true,"path":"2018/03/05/Redux/","link":"","permalink":"http://yoursite.com/2018/03/05/Redux/","excerpt":"","text":"1,Redux认知Redux 把自己标榜为一个“可预测的状态容器”，其实也是 Flux 里面“单向数据流”的思想，只是它充分利用函数式的特性，让整个实现更加优雅纯粹，使用起来也更简单。Redux 是超越 Flux 的一次进化。 2,Redux 应用场景 随着JavaScript 单页面应用开发日趋复杂，管理不断变化的state 非常的困难。 Redux 的出现就是为了解决state里的数据问题 在React中， 数据在组件中是单向流动的 数据从一个方向父组件向子组件（通过props)传递。 由于这个特征，两个非父子关系的组件之间的通信就比较麻烦。 3,Redux 设计思想 Redux 是将整个应用状态存储到一个地方，成为store 里面保存着一棵状态树 state tree 组件可以派发dispatch 行为action给store ,而不是直接通知其它组件 其他组件可以通过订阅store中的状态（state) 来刷新自己的视图 4, Redux 三大原则 整个应用的state 被储存在一个object tree中， 并且这个object tree 只存在于唯一一个store 中 State 是只读的， 唯一改变state 的方法就是触发action, action 是一个用于描述已经发生事件的普通对象， 使用纯函数来执行修改， 为了描述actions 如何改变stae tree， 需要编写reducers 单一数据源的设计让react的组件之间的通信更加方便，同时也便于状态的统一管理 5,Redux源码理解之Action Action 的理解 action 的定义 Action 是把数据从应用（译者注：这里之所以不叫 view 是因为这些数据有可能是服务器响应，用户输入或其它非 view 的数据 ）传到 store 的有效载荷。它是 store 数据的唯一来源。一般来说你会通过 store.dispatch() 将 action 传到 store。 Action 本质上是 JavaScript 普通对象我们约定，action 内必须使用一个字符串类型的 type 字段来表示将要执行的动作。多数情况下，type 会被定义成字符串常量。当应用规模越来越大时，建议使用单独的模块或文件来存放 action 1234&#123; type: ADD_TODO, payload: '需要传递的参数'&#125; 我们应该尽量减少在 action 中传递的数据 Action 创建函数 Action 创建函数 就是生成 action 的方法 123456 function addTodo(text) &#123; return &#123; type: ADD_TODO, payload &#125;&#125; bindActionCreators() 可以自动把多个action创建函数绑定到dispatch()方法，返回一个绑定后的actions 案例如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// index.jsimport React from 'react';import ReactDOM from 'react-dom'import &#123;createStore,bindActionCreators&#125; from './redux';function reducer(state=&#123;number:0&#125;,action )&#123; switch (action.type) &#123; case 'ADD': return &#123;...state,number:state.number+action.payload&#125; case 'MINUS': return &#123;...state,number:state.number-action.payload&#125; default: return state &#125;&#125;let store = createStore(reducer)// bindActionCreators 绑定actionCreators let actions =&#123; // anctionCreator add(number)&#123; return &#123; type:'ADD',payload:number&#125; &#125;, minus()&#123; return &#123; type:'MINUS',payload:1&#125; &#125;&#125;actions = bindActionCreators(actions, store.dispatch)class Counter extends React.Component&#123; constructor(props)&#123; super(props) this.state = &#123; number: store.getState().number&#125; &#125; componentDidMount()&#123; this.unsubscribe = store.subscribe(()=&gt;&#123; this.setState(&#123;number:store.getState().number&#125;) &#125;) &#125; componentWillUnmount()&#123; this.unsubscribe() &#125; render()&#123; return( &lt;div&gt; &lt;p&gt;&#123;this.state.number&#125;&lt;/p&gt; &lt;button onClick=&#123;()=&gt;actions.add(5)&#125; &gt;+&lt;/button&gt; &lt;button onClick=&#123;actions.minus&#125;&gt;-&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; ReactDOM.render(&lt;Counter /&gt;, document.getElementById('root')) bindActionCreators() 源码如下： 12345678910111213export default function bindActionCreators(actionCreators,dispatch)&#123; function bindActionCreator(actionCreator,dispatch)&#123; return (...args) =&gt;dispatch(actionCreator(...args)) &#125; if(typeof actionCreators == 'function')&#123; return bindActionCreator(actionCreators,dispatch) &#125; let boundActionCreators =&#123;&#125;; for(let key in actionCreators)&#123; boundActionCreators[key] = bindActionCreator(actionCreators[key],dispatch) &#125; return boundActionCreators;&#125;","categories":[],"tags":[{"name":"Redux","slug":"Redux","permalink":"http://yoursite.com/tags/Redux/"}]},{"title":"React里的高阶组件","slug":"React里的高阶组件","date":"2018-03-04T13:50:02.000Z","updated":"2019-10-21T09:29:05.366Z","comments":true,"path":"2018/03/04/React里的高阶组件/","link":"","permalink":"http://yoursite.com/2018/03/04/React里的高阶组件/","excerpt":"","text":"高阶组件的定义高阶组件（HOC）是React中对组件逻辑进行重用的高级技术，但是高阶组件并不是React API.它是一种模式，这种模式是由React 自身的组件性质必然产生的。 具体而言 高阶组件就是一个函数，并且该函数接受一个组件作为参数，并且返回一个包裹后的组件1const NewComponent = higherOrderComponent(OldComponent) 高阶组件的作用是将一个组件转换成另一个组件 应用场景1，React代码进行更高层次重构的好方法，如果你想精简你的state和生命周期方法，那么高阶组件可以帮助你提取出可重用的函数。 最常见的案例12345678910111213141516171819202122232425262728293031323334 export default function connectToStores(stores, getState) &#123; return function (DecoratedComponent) &#123; return class StoreConnector extends Component &#123; constructor(props) &#123; super(props) this.handleStoresChanged = this.handleStoresChanged.bind(this) this.state = getState(props) &#125; componentWillMount() &#123; stores.forEach(store =&gt; store.addChangeListener(this.handleStoresChanged) ) &#125; componentWillUnmount() &#123; stores.forEach(store =&gt; store.removeChangeListener(this.handleStoresChanged) ) &#125; handleStoresChanged() &#123; let newState = getState(this.props); this.setState(newState); &#125; render() &#123; console.log(this.props) return &lt;DecoratedComponent &#123; ...this.props &#125; &#123; ...this.state &#125; /&gt; &#125; &#125; &#125;&#125; 多层高阶组件重复利用功能简单案例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 从localStorage中加载// 高阶组件function fromLocal(WrappedComponent, key) &#123; return class extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; value: '' &#125;; &#125; componentWillMount() &#123; this.setState(&#123; value: localStorage.getItem(key) &#125;) &#125; handleChange = (event) =&gt; &#123; let value = event.target.value; localStorage.setItem(key, value) this.setState(&#123; value &#125;) &#125; render() &#123; return &lt;WrappedComponent value=&#123;this.state.value&#125; handleChange=&#123;this.handleChange&#125; /&gt; &#125; &#125;&#125;class UseName extends React.Component &#123; render() &#123; return &lt;&gt;用户名：&lt;input style=&#123;&#123; border: `2px solid #ccc` &#125;&#125; value=&#123;this.props.value&#125; onChange=&#123;this.props.handleChange&#125; /&gt;&lt;/&gt; &#125;&#125;// 高阶组价的使用返货包裹后的组件UseName = fromLocal(UseName, 'UseName')class Password extends React.Component &#123; render() &#123; return &lt;&gt;密码：&lt;input style=&#123;&#123; border: `2px solid #ccc` &#125;&#125; value=&#123;this.props.value&#125; onChange=&#123;this.props.handleChange&#125; /&gt;&lt;/&gt; &#125;&#125;// 高阶组价的使用返货包裹后的组件Password = fromLocal(Password, 'Password')export default class Form extends React.Component &#123; render() &#123; return ( &lt;&gt; &lt;UseName /&gt; &lt;Password /&gt; &lt;/&gt; ) &#125;&#125;ReactDOM.render(&lt;Form /&gt;, document.getElementById('root')) 容器组件和展示组件1234567891011121314151617181920212223242526272829303132333435 // 展示组件function Clock(props)&#123; var [hours, minutes,seconds] = [props.hours,props.minutes,props.seconds].map(num=&gt;&#123; return num&lt;10?'0'+num:num; &#125;) return &lt;h1&gt;&#123;hours&#125;:&#123;minutes&#125;:&#123;seconds&#125;&lt;/h1&gt; &#125;// 容器组件export default class ClockContainer extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; time: new Date()&#125;; this._update = this._updateTime.bind(this); &#125; render() &#123; return &lt;List &#123; ...this._extract(this.state.time) &#125;/&gt;; &#125; componentDidMount() &#123; this._interval = setInterval(this._update, 1000); &#125; componentWillUnmount() &#123; clearInterval(this._interval); &#125; _extract(time) &#123; return &#123; hours: time.getHours(), minutes: time.getMinutes(), seconds: time.getSeconds() &#125;; &#125; _updateTime() &#123; this.setState(&#123; time: new Date(this.state.time.getTime() + 1000) &#125;); &#125;&#125;; 注意事项1， 不要再render函数中使用高阶组件2，必须将静态方法做拷贝3，Refs属性不能传递 无状态组件创建纯展示组件，这种组件只负责根据传入的props来展示，不涉及到要state状态的操作。无状态函数式组件形式上表现为一个只带有一个render方法的组件类无状态组件的创建形式使代码的可读性更好，并且减少了大量冗余的代码，精简至只有一个render方法，大大的增强了编写一个组件的便利，除此之外无状态组件还有以下几个显著的特点： 1，组件不会被实例化，整体渲染性能得到提升因为组件被精简成一个render方法的函数来实现的，由于是无状态组件，所以无状态组件就不会在有组件实例化的过程，无实例化过程也就不需要分配多余的内存，从而性能得到一定的提升。组件不能访问this对象2，无状态组件由于没有实例化过程，所以无法访问组件this中的对象，例如：this.ref、this.state等均不能访问。若想访问就不能使用这种形式来创建组件3，组件无法访问生命周期的方法因为无状态组件是不需要组件生命周期管理和状态管理，所以底层实现这种形式的组件时是不会实现组件的生命周期方法。所以无状态组件是不能参与组件的各个生命周期管理的。4,无状态组件只能访问输入的props，同样的props会得到同样的渲染结果，不会有副作用 只要有可能，尽量使用无状态组件。","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"一道事件循环列面试题","slug":"一道事件循环列面试题","date":"2018-03-03T13:19:01.000Z","updated":"2019-02-23T03:55:04.552Z","comments":true,"path":"2018/03/03/一道事件循环列面试题/","link":"","permalink":"http://yoursite.com/2018/03/03/一道事件循环列面试题/","excerpt":"","text":"12345678910111213141516171819202122232425262728 console.log('script'); const interval = setInterval(()=&gt;&#123; console.log('setInterval') &#125;,0) setTimeout(()=&gt;&#123; console.log('setTimeout1') Promise.resolve().then(()=&gt;&#123; console.log('Promise 3') &#125;).then(()=&gt;&#123; console.log('Promise 4') &#125;).then(()=&gt;&#123; setTimeout(()=&gt;&#123; console.log('setTimeout 2') Promise.resolve().then(()=&gt;&#123; console.log('Promise 5') &#125;).then(()=&gt;&#123; console.log('Promise 6') &#125;).then(()=&gt;&#123; clearInterval(interval) &#125;) &#125;,0) &#125;) &#125;,0)Promise.resolve().then(()=&gt;&#123; console.log('Promise 1')&#125;)then(()=&gt;&#123; console.log('Promise 2')&#125;) 最终结果safari,ff,nodejs与此结果一致，chrome某些版本会多出现一次interval(promise4后)1234567891011script startpromise1promise2setIntervalsetTimout1promise3promise4setIntervaltimeout2promise5promise6 参考链接https://stackoverflow.com/a/30910084https://blog.risingstack.com/node-js-at-scale-understanding-node-js-event-loop/ 分析步骤123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 1, 任务从script标签开始执行 script tag as task queueconsole.log('script'); // script log//2,开始向下执行把 setInterval ,setTimeout 放进 task queue 任务池内,把Promise对象的then放到 micro queue 事件池里 此时任务池里 task queue [setInterval ,setTimeout] micro queue [then1,then2]// 3，开始执行 micro queue 任务，执行完所有micro queue再执行下一次task queueconsole.log('Promise 1') // Promise 1 logconsole.log('Promise 2') // Promise 2 log// 4 , 开始下一个task queue此时任务池里 task queue: setInterval,setTimeout1 micro queue []开始执行 setInterval ，console.log('setInterval') // setInterval log// 5, 又开始下一个 task queuetask queue: setTimeout1, setInterval// 因为setInterval每个一分钟就再次创建一个定时器此时任务池里 micro queue [] micro queue 为空，继续下一轮task queue,执行setTimout1开始执行 setTimeout1 console.log('setTimeout 1') // setTimeout 1 log//此时任务池里 task queue setInterval micro queue [then3,then4,then5]// 又开始开始执行 micro queue console.log('promise 3') //promise 3 log console.log('promise 4') //promise 4 log then5 将timeout push到taskqueue此时任务池 task queue setInterval setTimeout2 micro queue[]又开始执行task console.log('setInterval') // setInterval log此时任务池 task setTimeout2,setInterval micro queue[]micro为空，继续执行task, timeout2出开始执行 timeout2 console.log('setTimeout 2') //setTimeout2 log 然后把 then5, then6,then7 puhs到micro此时任务池里 task queue: setInterval micro queue[then5,then6,then7]开始执行micro 任务 console.log('Promise 5') // promise 5 log console.log('Promise 6') // promise 6 log clearInterval(interval) // 清除定时器 interval此时任务池task queue []micro queue[] 总结1， Macrotasks 和 micro queue 任务的区分 Macrotasks :script , setTimeout setInterval microtasks: process.nextTick promises Object.observe2, 执行流程如下图：","categories":[],"tags":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/tags/面试题/"}]},{"title":"常见跨域原理","slug":"常见跨域原理","date":"2018-01-24T03:55:40.000Z","updated":"2019-02-23T03:55:04.557Z","comments":true,"path":"2018/01/24/常见跨域原理/","link":"","permalink":"http://yoursite.com/2018/01/24/常见跨域原理/","excerpt":"","text":"跨域起因和解决方案 案例体现产生跨域问题了 JSONP解决跨域原理：我们通过动态插入script标签的方式，利用script标签的src属性发起请求,服务器需要把数据包裹在一个函数里面返回给客户端。，本质上是JS标签,不支持POST请求 也需要后台接口的支持 Cross-Origin Resource Sharing (CORS)来源域名可以是，白名单","categories":[],"tags":[]},{"title":"本地缓存","slug":"本地缓存","date":"2018-01-21T03:54:23.000Z","updated":"2019-02-23T03:55:04.559Z","comments":true,"path":"2018/01/21/本地缓存/","link":"","permalink":"http://yoursite.com/2018/01/21/本地缓存/","excerpt":"","text":"一：本地存储的概念使用JS向浏览器的某一个位置中存储一些，浏览器即使关闭了，存储信息也不会销毁，当重新打开浏览器的时候我们依然你能获取到上一次存储的信息 二 本地存储的方案; localStorage和sessStorage的区别localStorage属于永久本地存储，不管是刷新页面还是关掉页面和浏览器，存储的内容都不会消失，只有我们自己手动的去删除才会消失（不管是杀毒软件还是浏览器自己带的清除历史记录功能都不能把loacalStorage 存储的内容移除掉） sessionStorage 属于临时的回话存储，只需要当前的页面不关闭，信息就可以存储下来，但是页面一旦关闭，存储的信息就会自东清楚（F5 刷新页面只把当前的Dom 结构等进行重新的渲染，回话并没有关闭。 三 cookie 和 localStorage的区别：cookie 不存在兼容问题， localStorage:不兼容IE6~8cookie 存储内容的大小是有限制的，同源下 一般不超过4kb 的内容localStorage: 存储也有限制，一般同源下只能存储5MBcookie存储是有过期时间的，而localStorage是永久存储到本地的，使用杀毒软件或是浏览器自带的清除垃圾的功能都可能把存储的cookie 给删除掉用户可能处于安全的角度可以禁用cookie(无痕浏览器） 但是不能禁止 localStorage 真实项目中的本地存储都是用哪些东西？1， cookie : 记住用户密码或者是自动登录， 用户的部分信息，当用户登录以后我们就会把一些信息记录到本地cookie中，这样项目中的任何页面都可以知道当前登录的用户是哪一个，购物车….(存储少量的信息或是需要浏览器兼容的斗需要使用cookie来存储)2，localStorage：在pc 端我们可以用器存储 ，某一个JS 和css 中的源代码 ，优化页面还要把一些不需要经常更新的数据存储到本地，存储的时候可以设置一个存储时间，以后重新刷新页面，看一下时间有没有超过设置的时间，如果超过了就更新数据， 如果没有超过，就使用本地数据。//本地存储都是明文存储对于重要的信息我们一般都不存储到本地，如果非要存储的话我们需要把信息进行加密可逆转加密：加密完成还可以解密回来// 不可逆转加密：MD5 toGMTString() 方法可根据格林威治时间 (GMT) 把 Date 对象转换为字符串，并返回结果。escape &amp;&amp; unescape 可以对中文的字符串进行编码和解码，防止传递储存过程中出现乱码， 除此之外可以使用的还有很多 12345var str = '帅宝贝';var n = escape(str) console.log(n) //%u5E05%u5B9D%u8D1Dvar m = unescape(n) console.log(m) // 帅宝贝","categories":[],"tags":[]},{"title":"http协议缓存机制","slug":"http协议缓存","date":"2018-01-19T03:54:55.000Z","updated":"2019-02-23T03:55:04.550Z","comments":true,"path":"2018/01/19/http协议缓存/","link":"","permalink":"http://yoursite.com/2018/01/19/http协议缓存/","excerpt":"","text":"一，缓存策略 有些资源是很长时间不会改变的，比如网站的 logo 图片、jQuery 库、字体等，因此可以为它们设定「永不过期」的缓存时间，例如设定为 10 年。 二，http报文就是浏览器和服务器之间通信时发送及响应的数据块浏览器向服务器请求数据时，发送请求（request）报文； 服务器向浏览器返回数据时， 返回响应（response)报文 报文信息主要分为两部分 1.首部(header)——附加信息（cookie，缓存信息等）与缓存相关的规则信息，均包含在header中 2.主体部分(body)—–HTTP请求真正想要传输的部分 三，缓存规则分析1》 第一次请求数据：我们认为浏览器存在一个缓存的数据库，用于存储缓存信息。在客户端第一次请求数据时，此时缓存数据库中没有对应的缓存数据，需要请求服务器，服务器返回后，将数据存储至缓存数据库中。2》HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为两大类(强制缓存，对比缓存)在详细介绍这两种规则之前，先通过时序图的方式，让大家对这两种规则有个简单了解。两类缓存规则的不同，强制缓存如果生效，不需要再和服务器发生交互，而对比缓存不管是否生效，都需要与服务端发生交互。强制缓存，在缓存数据未失效的情况下，可以直接使用缓存数据，那么浏览器是如何判断缓存数据是否失效呢？ 在没有缓存数据的时候，浏览器向服务器请求数据时，服务器会将数据和缓存规则一并返回，缓存规则信息包含在响应header中。 对于强制缓存来说，响应header中会有两个字段来标明失效规则（Expires/Cache-Control）使用chrome的开发者工具，可以很明显的看到对于强制缓存生效时，网络请求的情况 Expires Expires的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。另一个问题是，到期时间是由服务端生成的，但是客户端时间可能跟服务端时间有误差，这就会导致缓存命中的误差。所以HTTP 1.1 的版本，使用Cache-Control替代。 Cache-Control 案例展示图中Cache-Control仅指定了max-age，所以默认为private，缓存时间为31536000秒（365天）也就是说，在365天内再次请求这条数据，都会直接获取缓存数据库中的数据，直接使用。 对比缓存需要进行比较判断是否可以使用缓存。浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据第一次访问 ： 没有使用缓存 第二次访问： 本地缓存库已经有数据了，就是用强制缓存机制 from disk 使用对比缓存 协商成功后 返回的状态码是304 通过三图的对比，我们可以很清楚的发现，在使用： 强制缓存（from disk）和对比缓存生效时 状态码为304，并且报文大小和请求时间大大减少。原因是，使用强制缓存是不用发送请求的，取得是本地缓存库的数据。而比较缓存机制 是 客户端发送带标识请求服务器，服务端在进行标识比较后，只返回header部分，通过状态码通知客户端使用缓存，不再需要将报文主体部分返回给客户端。对于对比缓存来说，缓存标识的传递是我们着重需要理解的，它在请求header和响应header间进行传递， 传递参数的方式Last-Modified：服务器在响应请求时，告诉浏览器资源的最后修改时间 If-Modified-Since：再次请求服务器时，那么浏览器将在请求中添加参数 If-Modified-Since（值为上次响应里面的Last-Modified值），服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若资源的最后修改时间大于If-Modified-Since，说明资源又被改动过，则响应整片资源内容，返回状态码200；若资源的最后修改时间小于或等于If-Modified-Since，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。 Etag：服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。 If-None-Match：再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识。服务器收到请求后发现有头If-None-Match 则与被请求资源的唯一标识进行比对，不同，说明资源又被改动过，则响应整片资源内容，返回状态码200；相同，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。 总结对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。浏览器第一次请求：浏览器第二次请求： 缓存和刷新关系f5(mac平台Command+R)和地址栏输入是相同的，会优先从本地缓存找ctrl+f5(mac平台硬性重新加载Shift+Command+R)会跳过缓存，直接发送请求到服务器 nginx缓存配置 谷歌调试工具里面体现 相关文章 相关文章链接","categories":[],"tags":[{"name":"js 基础","slug":"js-基础","permalink":"http://yoursite.com/tags/js-基础/"}]},{"title":"ES6 里面的类","slug":"es6-class","date":"2018-01-04T09:53:36.000Z","updated":"2019-02-23T03:55:04.550Z","comments":true,"path":"2018/01/04/es6-class/","link":"","permalink":"http://yoursite.com/2018/01/04/es6-class/","excerpt":"","text":"类 (class) 也可以设置默认参数1234567891011121314class Person&#123; constructor(name,age)&#123; this.name = name; this.age = age; &#125; showName()&#123; return this.name; &#125; showAge()&#123; return this.age; &#125;&#125;var p1 = new Person('lisi',20)console.log(p1.showAge()) 继承原型继承：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Tab&#123; constructor(id)&#123; this.oBox = document.getElementById(id); this.oBtn = this.oBox.getElementsByTagName('input'); this.oDiv = this.oBox.getElementsByTagName('div'); this.iNow = 0; this.init(); &#125; init()&#123; for (let i = 0; i &lt; this.oBtn.length; i++) &#123; this.oBtn[i].onclick = function()&#123; this.iNow =i; this.hide(); this.show(i); &#125;.bind(this) &#125; &#125; hide()&#123; for (let i = 0; i &lt; this.oBtn.length; i++) &#123; this.oBtn[i].className =\"\"; this.oDiv[i].style.display=\"none\"; &#125; &#125; show(index)&#123; this.oBtn[index].className=\"on\"; this.oDiv[index].style.display=\"block\"; &#125;&#125;// box2 继承boxclass AutoTab extends Tab&#123; constructor(id)&#123; super(id); setInterval(this.next.bind(this),1000); &#125; next()&#123; this.iNow++; if(this.iNow ==this.oBtn.length)this.iNow =0; this.hide(); this.show(this.iNow) &#125;&#125;window.onload=function()&#123; new Tab('box'); let at = new AutoTab('box2'); document.onclick = function()&#123; at.next() &#125;&#125; ES6 模块化模块化操作主要包括两个方面。export :负责进行模块化，也是模块的输出。import : 负责把模块引，也是模块的引入操作。export default的使用加上default相当是一个默认的入口。在一个文件里export default只能有一个。export default{a,d,c} 多个模块导出 promise就是一个对象，用来传递异步操作的数据1，pending(等待，处理中)—&gt; resolve (完成) reject (拒绝，失败)2，创建一个promise的对象12345678910111213141516171819202122232425var p1 = new Promise(function(resolve,reject)&#123; // resolve(1) reject(2)&#125;);// then 是有返回值的，他的返的promise的对象值 会在下一个then 里面体现p1.then(function(val)&#123; console.log(\"成功了\"+val);&#125;,function(val)&#123; console.log('失败了'+val)&#125;)``` 3, catch 用来捕获的```javascriptvar p1 = new Promise(function(resolve,reject)&#123; // resolve(1) reject(2)&#125;);p1.then(function(val)&#123; console.log(\"成功了\"+val); throw '发生错误了'&#125;).catch(function(e)&#123; console.log(e) // 发生错误了&#125;) 4, all 方法 全部，用于将多个Promise 对象组合，包装成一个全新的promise 实例Promise.all([p1,p2,p3…]); 所有的Promise 对象都正确，才走成功，否则，只有一个报错，都是失败。 1234567var p1 = Promise.resolve(3);var p2 = Promise.reject(5);Promise.all([true,p1,p2]).then(function(val)&#123; console.log('成功了'+val)&#125;,function(val)&#123; console.log('错误了'+val)&#125;) race() 返回的也是一个promise 对象最先能执行promise 的结果，根据 那个快，就用那个12345678910 var p1 = new Promise(function(resolve,reject)&#123; setTimeout(resolve,100,'one');&#125;)var p2 = new Promise(function(resolve,reject)&#123; setTimeout(resolve,500,'two');&#125;)Promise.race([p1,p2]).then(function(val)&#123; console.log(val) // one 谁先到时间 就先执行谁&#125;) Promise.reject() 生产错误的一个Promise对象用法12345Promise.reject('错误信息').then(function()&#123; &#125;,function(res)&#123; console.log(res) // 错误信息 &#125;) Promise.resolve() 生成一个成功的Promise 对象语法： Promise.resolve(val); val 不同类型的值12345Promise.resolve('success').then(function(val)&#123; console.log(val) // 成功 &#125;,function(res)&#123; console.log(res) // 这句是不会执行 &#125;) Promise.resolve(Promise); 传了一个Promise 对象的值。12345let p1 = Promise.resolve(3);let p2 = Promise.resolve(p1)p2.then(function(val)&#123; console.log(val) //3&#125;)","categories":[],"tags":[]},{"title":"Symbol在对象里面的作用","slug":"Symbol在对象里面的作用","date":"2018-01-04T03:53:36.000Z","updated":"2019-02-23T03:55:04.549Z","comments":true,"path":"2018/01/04/Symbol在对象里面的作用/","link":"","permalink":"http://yoursite.com/2018/01/04/Symbol在对象里面的作用/","excerpt":"","text":"Symbol 的概念在对象里面的作用 是全局标记1， 声明方式：","categories":[],"tags":[]},{"title":"事件冒泡面试题","slug":"事件冒泡面试题","date":"2018-01-01T12:32:21.000Z","updated":"2019-02-23T03:55:04.552Z","comments":true,"path":"2018/01/01/事件冒泡面试题/","link":"","permalink":"http://yoursite.com/2018/01/01/事件冒泡面试题/","excerpt":"","text":"123456&lt;!-- 完善下面代码，要求：输出li标签的data-index的值。--&gt; &lt;ul class=\"box\" id=\"box\"&gt; &lt;li class=\"item\" data-index=\"1\"&gt;标题1&lt;span class=\"icon\"&gt;icon&lt;span&gt;fefef&lt;/span&gt;&lt;/span&gt;&lt;/li&gt; &lt;li class=\"item\" data-index=\"2\"&gt;标题2&lt;span class=\"icon\"&gt;icon&lt;/span&gt;&lt;/li&gt; &lt;li class=\"item\" data-index=\"3\"&gt;标题3&lt;span class=\"icon\"&gt;icon&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; 123456789101112131415161718let $box = document.querySelector(\"#box\");$box.addEventListener(\"click\", function (evt) &#123; var self=this, e = e || event, target = e.target, tags = target.tagName; var parent = target; while(parent.tagName.toLowerCase() !== 'li')&#123; parent = parent.parentNode; &#125; console.log(parent.getAttribute('data-index')); // if(tags===\"SPAN\")&#123; // index = (target.parentNode).getAttribute('data-index'); // &#125;else&#123; // index =target.getAttribute(\"data-index\"); // &#125; // console.log(index)&#125;, false); 12345678var oBox = document.getElementById(\"box\"); var olis = oBox.children; for (var i = 0; i &lt; olis.length; i++) &#123; var cur = olis[i]; cur.index = i; console.log(this.index) &#125; &#125; `","categories":[],"tags":[]},{"title":"处理兼容的三种方式","slug":"处理兼容的三种方式","date":"2017-12-31T02:19:40.000Z","updated":"2019-02-23T03:55:04.556Z","comments":true,"path":"2017/12/31/处理兼容的三种方式/","link":"","permalink":"http://yoursite.com/2017/12/31/处理兼容的三种方式/","excerpt":"","text":"一，使用try，catch 来处理兼容1》 前提是： 必须保证try 中的代码在不兼容浏览器中执行的时候报错，这样的话我们才能以用catch 捕获到异常信息进行处理。2》不管当前是什么浏览器，都需要先把try 中的代码执行一遍，如果当前是IE7，window.getComputedStyle 本身是不兼容的，但是我们也要先把它执行一遍，只有报错了，再把catch 里的curEle.currentStyle执行一遍（消耗性能)12345678910 function getCss(curEle,attr)&#123; var val = null; try&#123; val = window.getComputedStyle(curEle,null)[attr]; &#125;catch(e)&#123; val = curEle.currentStyle[attr]; &#125; return val &#125;console.log(getCss(box,\"height\")); 二，判断当前浏览器是否存在这个属性和方法，存在就是兼容，不存在就不兼容12345678910111213141516171819202122function getCss()&#123; var val =null; if(\"getComputedStyle\" in window)&#123; //true就是兼容，false就不兼容 val = window.getComputedStyle(curEle,null)[attr]; &#125;else&#123; val = curEle.currentStyle[attr]; &#125; return val;&#125;console.log(getCss(box,\"height\"));//第二种写法function getCss()&#123; var val = null; if(window.getComputedStyle)&#123; //true就是兼容，false就不兼容 val = window.getComputedStyle(curEle,null)[attr]; &#125;else&#123; val = curEle.currentStyle[attr]; &#125; return val;&#125;console.log(getCss(box,\"height\")); 3，通过检测浏览器版本和类型来检测处理兼容问题window.navigator.userAgent12345678910 function getCss(curEle,null)&#123; var val=null; if(/MSIE(6|7|8)/.test(navigator.userAgent))&#123; val = curEle.currentStyle[attr] &#125;else&#123; val = window.getComputedStyle(curEle,null)[attr]; &#125; return val; &#125;console.log(getCss(box,\"height\")); 标准浏览器和IE 浏览器获取的结果还是不一样的。对于部分样式属性，不同浏览器的结果不一样，主要是由于getComputedStyle 和currentStyle在某些方面不一样解决方案： 写css 初始化默认值。 所有复合值拆开获取。 1console.log(getCss(box,\"borderTop\")) getCss升级 获取到的样式值”去单位” 只有符合”s数字+单位/数字” 才可以使用parseFloat()1234567891011121314151617181920function getCss()&#123;var val =null, reg =null;// var val=reg=null; val 是私有的变量， reg 是全局的变量if(\"getComputedStyle\" in window)&#123; //true就是兼容，false就不兼容 val = window.getComputedStyle(curEle,null)[attr];&#125;else&#123; // IE6~8 if(attr===\"opacity\")&#123; var = curEle.currentStyle[\"filter\"]; reg =/^alpha\\(opacity=(\\d+(?:\\.\\d+)?)\\)/i; val = reg.test(val) ? reg.exec(val)[1]/100:1; &#125;else&#123; val = curEle.currentStyle[attr]; &#125;&#125;var reg = /^(-?\\d+(\\.\\d+)?)(px|pt|rem|em)?$/i;return reg.test(val)? parseFloat(val):val;&#125;console.log(getCss(box,\"height\"));console.log(getCss(box,\"float\"));","categories":[],"tags":[]},{"title":"可枚举和不可枚举","slug":"可枚举和不可枚举","date":"2017-12-28T09:10:34.000Z","updated":"2019-02-23T03:55:04.555Z","comments":true,"path":"2017/12/28/可枚举和不可枚举/","link":"","permalink":"http://yoursite.com/2017/12/28/可枚举和不可枚举/","excerpt":"","text":"for in 循环遍历的时候，默认的话是可以把自己私有的和在它所属类型上扩展的属性和方法都是可以遍历到的。一般情况下只需要遍历私有的即可。如下进行判断处理：obj.propertyIsEnumerable(key) 判断这个属性是否可枚举。 私有的属性才能枚举，公有的的是不能枚举的。在原型上的都是不可以枚举的。12345678for(var key in obj)&#123; if(obj.propertyIsEnumerable(key))&#123; console.log(key); &#125; if(hasOwnProperty(key))&#123; console.log(key); &#125;&#125; isPrototypeOf() 确定一个对象是否存在于另一个对象的原型链中12345Fuction Fn ()&#123; console.log(12);&#125;var res = new Fn();console.log(Fn.prototype.isPrototypeOf(res)) // true","categories":[],"tags":[]},{"title":"移动端事件","slug":"移动端事件","date":"2017-12-26T04:44:36.000Z","updated":"2019-02-23T03:55:04.560Z","comments":true,"path":"2017/12/26/移动端事件/","link":"","permalink":"http://yoursite.com/2017/12/26/移动端事件/","excerpt":"","text":"一， pc 端常用事件： click , mouseover,mouseout,mouseenter,mouseleave,mousemove,mousedown,mouseup,keydown,keyup,mousewheel,load,scroll,blur,focus,change… 二，移动端： click,load,scroll,blur,focus,change….TOUCH事件模型（处理单手指操作）, GESTURES事件模型（处理多手指操作） TOUCH：touchstart, touchmove,touchend,touchcancleGESTURES: gesturestart,gesurechange,gestureend, 1&gt; click : 在移动端click 属于单击事件，不是点击事件；在移动端的项目中如何区分单击和双击，使用click 会存在300s的延迟。主要是区分浏览器在第一次点击结束之后，还需要等待300s 看是否触发了第二次点击，如果触发了第二次点击就不属于click, 例子2&gt; 点击， 单击，双击， 长按单击和双击主要看300 ms 之后是否有再次点击点击和长按： 主要看750ms点击和滑动： （x/y 轴偏移量是否在30px以内，超过30 就是滑动）左右滑和上下滑：（x 轴便宜的距离&gt;y轴偏移的距离 == 右滑动 相反就是下滑）左滑动和右滑动：（偏移量的距离&gt;0 = 右滑动 相反是做滑动） 常用移动端事件库1, fastclick.js: 解决click事件300ms的延迟2, TOUCH.JS: 百度云手势事件库下载地址：https://github.com/Clouda-team/touch.code.baidu.com3, HAMMER.JS4, Zepto.js : 移动端的小型JQJQ由于是在PC 端使用，所以代码中包含了大量的对于IE 低版本的兼容处理，还提供了很对选择器类型以及DOM操作，动画等等…而Zepto主要用于移动端开发，没有处理ie的兼容问题,也是不分实现常用的选择器和方法,动画也只提供了animate所以 Zepto的原来代码要比JQ 小很多。 专门我移动端开发而诞生的，animate 动画还支持了的css3动画的操作 Zepto 常用事件操作：tap:点击singleTap: 单击doubleTap: 双击longTap:长按swipe: 滑动swipeUP:上滑动swipeDown: 下滑动swipeLeft: 左滑动swipeRight:右滑动","categories":[],"tags":[]},{"title":"字符串常用的方法","slug":"字符串常用的方法","date":"2017-12-25T07:22:08.000Z","updated":"2019-02-23T03:55:04.556Z","comments":true,"path":"2017/12/25/字符串常用的方法/","link":"","permalink":"http://yoursite.com/2017/12/25/字符串常用的方法/","excerpt":"","text":"定义：在JS 中用单/双引号包裹起来的就是字符串。12345678var str = 'good good study,day day up!';//=&gt;字符串就是由零到多个字符组成的//1、//第一个字符索引0//第二个字符索引1//...//以数字作为索引，从零开始的 //2、//有一个叫做length的属性，存储的是当前字符串中字符的个数（字符串的长度） str[0] -&gt;'g' 第一个字符str.length -&gt;26str[str.length-1] -&gt;'!' 最后一个字符str[100] -&gt;undefined 如果指定的索引不存在获取的结果是undefined","categories":[],"tags":[]},{"title":"HTML5新特性","slug":"HTML5新特性","date":"2017-12-24T03:34:58.000Z","updated":"2019-02-23T03:55:04.547Z","comments":true,"path":"2017/12/24/HTML5新特性/","link":"","permalink":"http://yoursite.com/2017/12/24/HTML5新特性/","excerpt":"","text":"HTML5基本概述HTML: 超文本标记语言（页面中不仅仅只有文字，而且可以呈现出图片，音视频等媒体资源）12345678910&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"\"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; XHTML:它是HTML比较规范严谨的一代版本文档声明比较复杂，需要特殊强调当前的页面需要严谨一些123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\"&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; XML: 可以扩展的标记语言（HTML中使用的标签都是W3C标准中规定的，XML允许我们自己扩展标签的）,他的作用不是用来写页面结构的而是用来存储一些数据的（可以扩展的标签作为标识，清晰明了的展示出数据结构。。。）1234567891011&lt;root&gt; &lt;student&gt; &lt;name&gt;李四&lt;/name&gt; &lt;age&gt;30&lt;/age&gt; &lt;/student&gt; &lt;student&gt; &lt;name&gt;王五&lt;/name&gt; &lt;age&gt;27&lt;/age&gt; &lt;/student&gt;&lt;/root&gt; HTML5: 当前HTML 最新的一代版本， 也是非常成功的一代版本，目前市场上基本都是基HTML5规范进行开发(他相对于传统的HTML增加了更多一些有助于开发的内容)12345678910&lt;!DOCTYPE html&gt;&lt;html lang='en'&gt;&lt;!--声明页面的语言模式：english，如果页面中出现了英文单词，浏览器会自主发起是否翻译的功能--&gt; &lt;head&gt; &lt;!--指定当前页面的编码格式是国际统一编码格式：UTF-8 GB2312中国编码...--&gt; &lt;meta charset='UTF-8'&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; HTML5提供的新语法规范1, 对原有语义化标签的升级标签语义化： 每一个html标签都有自己特殊的含义，在搭建页面结构的时候，应该让合理的标签做合适事情。2, HTML5 中新增的一些语义化标签1234567891011articel:文章区域header: 头部区域footer:尾部区域main : 主体内容section : 普通内容区域figure: 配图区域figcaption:配图说明aside:与主题无关的内容（一般用来放广告的区域）nav:导航区域...都是块元素 3,HTML5 新增加的标记标签12345678mark:用来标记需要高亮显示的文本time:用来标记日期文本``` 4, HTML5 对于原标签语义化的调整```htmlstrong:之前是加粗，现在重点是朗读（加粗的效果还有，但是语义不一样的）small: 之前是变小，现在是附属细则（效果变小）hr: 之前是一条直线，现在是分割线，用来分割两个区域。 1.autocomplete: 自动完成填充,会记录之前输入的内容,给你自动提示2.autofocus 打开页面自动获取鼠标的焦点3.form=’form的id’:一个form之外的表单元素也让其属于这个form4.width height :只存在域input 的type是image的表单元素5.multiple:可以选择多个文件6.required:必填的7.input的新type值文字:12345678910111213&lt;input type=\"text\"&gt; &lt;br&gt;网址:&lt;input type=\"url\"&gt; &lt;br&gt;邮箱:&lt;input type=\"email\"&gt; &lt;br&gt;密码:&lt;input type=\"password\"&gt;&lt;br&gt;数字:&lt;input type=\"number\" max=\"10\" min=\"0\" step=\"3\"/&gt;&lt;br&gt;色卡:&lt;input type=\"color\"&gt; &lt;br&gt;电话:&lt;input type=\"tel\"&gt; &lt;br&gt;日期:&lt;input type=\"date\"&gt;&lt;br&gt;日期:&lt;input type=\"time\"&gt;&lt;br&gt;日期:&lt;input type=\"datetime-local\"&gt;&lt;br&gt;日期:&lt;input type=\"month\"&gt;&lt;br&gt;日期:&lt;input type=\"week\"&gt;&lt;br&gt;范围:&lt;input type=\"range\"&gt;&lt;br&gt;重置:&lt;input type=\"reset\"&gt;&lt;br&gt;提交:&lt;input type=\"submit\"&gt;pattern=\"\":正则进行校验novalidate:不做校验 新增标签的兼容问题解决： 在当前页面的head中（css后），我们导入一个JS 插件： html5.min.js 它就是用来把页面内所有不兼容的H5语义化标签进行兼容处理：1》 把页面内的所有不兼容的标签进行替换2》把css 中使用标签选择器设置的样式（H5标签也替换成其他方式标准浏览器内不用引用1234567&lt;head&gt; &lt;!--[if lt IE 9]&gt; &lt;script src=\"js/html5.min.js\"&gt;&lt;/script&gt; &lt;![endif]--&gt;&lt;/head&gt;&lt;!--条件注释中的代码要严格区分大小写以及空格等细节问题--&gt; HTML5 表单的新特性一 传统表单类型1234567form input:text, password,submit,reset,button,radio,checkbox,file,hiddenbuttonselectlabeltextarea.... 二 HTML5 表单的新特性1, 给input 设置了很多新的类型input:search,url,email,tel,number,range,color,date,time,dataTime ….2, 优势作用提供更加强大的功能，方便开发。在移动端使用对应的input类型，当用户输入的时候可以调取出对应的虚拟键盘部分类型还提供了表单验证3,input 增加了一个属性： placeholder ,给表单框设置默认信息提示4, 二级下拉框（select是一级下拉框）123456&lt;input type=\"text\" id=\"department\" list=\"departmentList\"&gt;&lt;datalist id=\"departmentList\"&gt; &lt;option value=\"市场部\"&gt;市场部&lt;/option&gt; &lt;option value=\"技术部\"&gt;技术部&lt;/option&gt; &lt;option value=\"总裁办\"&gt;总裁办&lt;/option&gt;&lt;/datalist&gt; H5中的表单验证（内置规则不是特别好），所以真实项目中的表单验证依然延续传统的正则验证完成 html5 新曾其他的标签一,增加的媒体： 视频：audio 音频：video1&lt;video src=\"movie.ogg\" controls=\"controls\"&gt;如果浏览器不支持 video 标签。就会显示这里面的内容&lt;/video&gt; 1,优缺点：传统的音视频播放是基于flash来完成的，需要浏览器中安装 adobe flash player 插件 现在只需要基于audio或者video播放即可，但是对于音视频的格式有限制，对于浏览器也有限制 移动端对于flash的支持不好，但是基本上都支持audio和videoPC端的IE浏览器（低版本）不支持audio和video，但是支持flash二 绘画 canvas它是一个画布，允许我们在JS中通过代码绘制图形以及实现一些好玩的动画 百度统计图插件：Echarts就是基于canvas开发的三，提供了很多强大的JS API API：Application Programming Interface 应用程序接口（凡是提供一个共别人调取使用的都可以称之为接口,例如：使用AJAX从服务器端获取数据，需要一个URL地址，此地址就是一个API，浏览器提供给我们很多常用的方法，每一个方法都可以叫做API）四:本地存储webStorage:localStorage: 本地信息存储在没有H5本地存储之前，我们都使用cookie做的本地存储区别： localStorage,只要使用浏览器打开,存在里面的内容会被永久存储,关闭页面再打开任然存在,在其他的网页也可以获取123456789101112localStorage.lc=\"去哪儿\";alert(localStorage.zf);localStorage.setItem(\"QQ\",\"647812808\");localStorage.removeItem(\"QQ\");//实现一个查看当前浏览次数的方法if(!localStorage.getItem(\"n\"))&#123; localStorage.setItem(\"n\",1) &#125;else &#123; localStorage.setItem(\"n\",parseInt(localStorage.getItem(\"n\"))+1) &#125; alert(\"这是第\"+localStorage.getItem(\"n\")+\"次\") sessionStorage: 本地回话存储123456//sessionStorage:存储在浏览器上,只要浏览器不关闭,就会有,关闭浏览器就是消失,但是在其他的页面中获取不到if(!sessionStorage.getItem(\"code\"))&#123; sessionStorage.setItem(\"code\",1)&#125;else &#123; sessionStorage.setItem(\"code\",parseInt(sessionStorage.getItem(\"code\"))+1)&#125; 五: 获取本机地理位置 通过H5可以获取当前用户地理位置（精度、纬度、精准度…），再结合第三方地图（高德地图、百度地图、腾讯地图…）API接口，实现一些生活服务的推荐等六:提供了新的通信方式：websocket想要实现实时通讯类的产品，基本上现在都是基于socket.io这个框架来完成的七：提供操作手机硬件功能的API调取手机的重力感应器，实现摇一摇，或者实现一些小游戏调取手机的摄像头或者通讯录不是所有的手机浏览器都支持这些功能，即时支持这些功能的浏览器，在实现效果上也是不理想的（不稳定、卡顿等）八：H5离线缓存：manifest第一次连网请求完成页面，把信息缓存到本地，下一次即时断网的情况下，也可以看到上一次的信息","categories":[],"tags":[]},{"title":"jQuery源码理解","slug":"jQuery源码理解","date":"2017-12-15T12:34:06.000Z","updated":"2019-02-23T03:55:04.551Z","comments":true,"path":"2017/12/15/jQuery源码理解/","link":"","permalink":"http://yoursite.com/2017/12/15/jQuery源码理解/","excerpt":"","text":"为什么 $() = jQuery()原理：window.jQuery = window.$ = jQuery (jQuery就是闭包中的私有的函数)12$() =$jQueryvar $oDiv = jQuery(\"#div\") &lt;==&gt;$(\"#div\") $(“box”,context) 原理：123var jQuery = function (selector,context)&#123; return new jQuery.fn.init(selector,context)&#125; selector: 参数支持的类型：[string]选择器的类型 [object]js 原生的对象(把原生的对象转换为jQuery对象)[function]回调函数(等价于$(document).ready…) / $(function(){}) context: 不传默认为document; 传递的是一个原生对象能够上下文，但是传递的是一个jQuery对象，他默认会把其重构为选择器）返回值： 返回了一个jQuery 类的实例 (jQuery.fn)1234567jQuery.fn = jQuery.prototype =&#123; constructor = jQuery&#125;jQuery.extend = jQuery.fn.extend = function()&#123; jQuery.extend:把它当做一个普通的对象，在对象中增加了，extend 方法 jQuery.fn.extend : 在它的原型上也增加了一个extend方法&#125; jQuery选择器： 创建jQuery这个类的一个实例(jQuery对象)1$(\"box\")===$(\"box\") //false 在jQuery这个类的原型上定义了很多属性和方法，而是通过选择器获取的每一个实例都是可以调用这些方法：属性，css 文档操作，筛选….1$(\"*\").css(); jQuery当做一个普通的对象，在它自己的属性上增加了一个常用的方法： Ajax,工具 …$.ajax(); extend : 扩展1,向jQuery属性名上扩展(把它当做一个对象), 主要用来完善类库的，给类库增加核心的方法123456jQuery.extend(&#123; aa:function()&#123; console.log(\"aaa\"); &#125;&#125;)$.aa(); 2, 向jQuery的原型上扩展(把他当做一个类) 主要用来编写一些基于 jQuery插件123456jQuery.fn.extend(&#123; bb:function()&#123; console.log(\"bbb\") &#125;&#125;);$().bb()","categories":[],"tags":[]},{"title":"jQuery总结","slug":"jQuery总结","date":"2017-12-15T00:23:23.000Z","updated":"2019-02-23T03:55:04.551Z","comments":true,"path":"2017/12/15/jQuery总结/","link":"","permalink":"http://yoursite.com/2017/12/15/jQuery总结/","excerpt":"","text":"jQuery: 它是用原生的JS 来封装的常用方法的类库(解决了兼容问题)jQuery常用的方法选择器： 通过传递对应规则的内容，获取到页面中指定的元素/元素集合// jQuery 选择器获取到的结果是一个jQuery对象，可以使用jQuery中提供的那些属性和方法，但是不能直接使用浏览器内置的属性和方法。1, jQuery === $ //true12var $Div = jQuery(\"#div1\"); var $Div = $(\"#div1\"); // JS 获取到的结果是属于元素对象/元素集合/节点元素…她们就可以使用浏览器为期提供的那天天生自带的属性和方法12var oDiv = document.getElementById(\"div1\");console.log(oDiv.clientWidth); // jQuery 不能使用js 的方法和属性 ,js 也不能使用jQuery的属性和方法123var $Div = $(\"#div1\"); console.log($Div.clientWidth) // undefinedconsole.log($Div.getAttribute('爱学习')) // getAttribute is not a function js 和 jQuery 相互转换1》 把原生js 转变为jQuery12var oDiv = document.getElementById(\"div1\");var $oDiv = $(oDiv) // 就把原生获取到的oDiv 转换成jQuery 2》把jQuery 转换成 原生js 对象 :直接通过索引获取对应的元素即可12345var $oDiv = $(\"#div\");//第一种方法console.log($oDiv[0].getAttribute('爱学习')) //爱学习// 第二种$oDiv.get(0) 常用选择器(1)基本 #id $(“#div”); element $(‘div’); .class $(‘.className’) * $(‘*’) selector1,selector2,selectorN : $(“#div ,div, .className”)把符合每一个选择器获取到的jQuery对象最后融合在一起，一起获取到 (2)层次选择器： ancestor descendant $(“#div li”) // 获取子子孙孙辈分 parent &gt; child $(“#div&gt;li”) // 只获取儿子辈分的元素 prev + next $(“#div + “) // 获取他的下一个弟弟元素 $(“#div + li”) // 获取下一个弟弟并且标签名是ul的(一个元素) prev ~ siblings $(“#div ~ “) // 获取#div 的所有弟弟元素节点 $(“#div ~ ul “) // 在#div的所有弟弟元素中查找标签名为 ul 元素 (3)基本过滤器选择器 // 某一个集合下的 :first :last :not 除了谁 $(“#div&gt;div:not(.className)”) 支持className ,标签。 #div1 下所有子集DIV 中样式类名不包含className 的所有元素节点 :even :odd :eq 通过索引获取集合中的某一个，但是获取的结果依然还是一个jQuery对象（ 而 get 方法也是通过索引来获取的，但是获取到的结果是一个js原生对象 :gt $(“#div1&gt;div:gt(2)”) 大于索引2的(不包含索引2这一项) :lt $(“#div1&gt;div:lt(2)”) 小于索引2的(不包含索引2这一项) :header :animated (4)内容过滤器选择器 :contains $(“#div1 li:contains(“js”)”) // 获取的所有Li 中内容包含js 的元素。 :empty :has $(“#div div:has(ul)”) //查找在所有div中包含ul 的那些元素 :parent (5)可见性过滤器选择器 :hidden :visible (6)属性过滤器选择器 [attribute] [attribute=value] [attribute!=value] [attribute^=value] [attribute$=value] [attribute*=value] [attrSel1][attrSel2][attrSelN] (7)子元素过滤器选择器 :nth-child :first-child :last-child :only-child (8)表单选择器 :input :text :password :radio :checkbox :submit :image :reset :button :file :hidden (9)表单过滤器选择器 :enabled :disabled :checked :selected 方法和属性一： 回调函数的方法二： 常用的属性1》 attr : 获取和设置元素的自定义属性，等价于原生js中的get/setAttrbuteremoveAttr12345678var $box = $(\"#box\");$box.attr(\"data\",\"100\"); //设置属性值$box.attr(\"data\") // 获取属性值$box.attr(&#123; index:1, name:\"目的地\" &#125;); //批量设置自定义属性$box.removeAttr(\"data\") //移除data 属性 2》 prop: 获取和设置元素的属性(和attr是不同的两套方式，两者之间不能互相混用：用attr设置的只能用attr删除或者修改，获取；同理用prop设置的也只能用prop操作)// removeProp : 删除prop 内置的属性可以在html结构中体现出来，但是不是内置的属性是体现不出来的(但是是可以获取到值的)12345678var $box = $(\"#box\");$box.prop(\"data\",100); //设置属性值和修改$box.prop(\"data\"); // 获取属性值$box.prop(&#123; //批量设置自定义属性 index:1, name:\"poi列表\" &#125;)$box.removeProp(\"data\") //移除data 属性 attr 和 prop的区别： attr 一般都是用来操作自定义的属性，而prop一般都是操作元素的内置属性的(尤其是针对表单大部分都是用prop)3》 $() 支持传两个参数1234// jQuery(selector,context) context一般不用传递，默认是document，但是我们也可以指定具体的上下文来获取需要的元素var $box = $(\"#box\"), $boxDivList = $(\"div\", $box)$(\"div\",$box) &lt;==&gt; $(\"#box div\");$(\"#box &gt;div\") &lt;==&gt; $box.children(\"div\"); 4》 $boxDivList.addClass(“w1”); 通过jQuery选择器获取到是一个元素集合，然后让集合直接调用jQuery中提供的方法，相当于给集合中的每一个元素都调取了对应的方法(jQuery内置循环操作)5》 each() 可以遍历jQuery集合中的每一项(和数组的forEach类似)123$boxDivList.each(function(index,item)&#123; $(this).addClass('w2'); &#125;) css :1, css() : 获取(不传参数)/设置（传参数）当前元素的样式值3, offset : 不管父级参照物是谁，获取（不传参数）当前元素距离body的偏移距离(top:xxx,left:xxx)和设置(带参数)4, position: 获取(不传参数)/设置（传参数）当前元素距离父级参照物的偏移距离(top:xxx,left:xxx);5, scrollTop/scrollLeft :获取(不传参数)/设置（传参数）元素的卷去的高度 和设置6,width/height // 获取(不传参数)/设置（传参数）元素的 width和height 的值7,innerWidth/innerHeight // 获取(不传参数)/设置（传参数）元素的可视区域的宽高(等价于clientWidth和clientHeight) 设置的时候，保留padding的值，把width 值进行改变(width的最小值为0)8,outerWidth/outerHeight 获取(不传参数)/设置（传参数）元素的可视区域的宽高(包含边框)，设值和innerWidth 设置一样。 如果传递进来的是true ,默认的会把外边距margin的值也计算在内了。 9，jQuery 的链式写法原理：执行完成一个方法后的返回值的结果依然是一个jQuery对象，这样就可以继续调用下一个jQuery的方法，如果返回来的不是一个jQuery的对象就会报错 文档处理一， 向指定元素的末尾位置追加一个新元素1, append() :向指定元素的末尾位置追加一个新元素 语法：容器.append(元素)2，appendTo() : 向指定元素的末尾位置追加一个新元素 语法： 元素.appendTo(容器)1234var oDiv = document.createElement(\"div\");oDiv.id = \"div5\";$box.append(oDiv) ;把原生的js和 jQuery 元素节点追加到jQuery对象里面$(oDiv).appendTo($box); 二， 向指定元素的开头位置追加一个新元素语法： 通上末尾位置追加一个新元素1, prepend()2, prependTo()三，在每个匹配的元素之后/之前插入内容。1,after()2,before()四：把选择器获取到的元素追加到指定元素的前面或是后面(追加到同级相当于添加了一个哥哥或是弟弟)1，inserBefore()2，inserAfter()1234var oDiv = document.createElement(\"div\");oDiv.id = \"div5\";$(oDiv).inserBefore($box);$(oDiv).inserAfter($box); // 五： replaceAll(selector) : 用匹配到的元素替换所有selector 匹配元素替换123var oDiv = document.createElement(\"div\"); oDiv.id = \"div5\"; $(oDiv).replaceAll('ul') ; // 页面中所有的ul 都用oDiv 给替换了 六： remove() : 把匹配的结果在页面中移除，移除自己本身123$box.remove(); //删除本身$(\"ul\").remove() ; $(\"ul\").remove(\"#ul2\"); //删出所有ul 里面ID是#ul2 的哪一个。 七: detach([expr])：从DOM中删除所有匹配的元素。这个方法不会把匹配的元素从jQuery对象中删除，因而可以在将来再使用这些匹配的元素。与remove()不同的是，所有绑定的事件、附加的数据等都会保留下来。1234567//从DOM中把所有段落p删除&lt;p&gt;Hello&lt;/p&gt; how are &lt;p&gt;you?&lt;/p&gt;$(\"p\").detach(); //how are// 从DOM中把带有hello类的段落删除&lt;p class=\"hello\"&gt;Hello&lt;/p&gt; how are &lt;p&gt;you?&lt;/p&gt;$(\"p\").detach(\".hello\"); // how are &lt;p&gt;you?&lt;/p&gt; 八: clone() 克隆 筛选一， filter,children, find : 常用的三个筛选方法1,filter() : 同级过滤 首先通过选择器获取一个集合，在获取的内容中进行二次筛选1console.log($(\"*\",$box).filter(\"ul\")); 2,chiidren() : 子集过滤器123456console.log($box.children())console.log($box.children(\".w1\"))console.log($box.children(\"ul\"))console.log($box.children(\"#div1\"))console.log($box.children(\"#div1,#div2\"))console.log($box.children(\"[name='data']\")) 3,find() :后代过滤器123console.log($box.find()) // 空集合console.log($box.find(\"li\")) // $(\"#box li\")console.log($box.find([name='data'])) // $(\"#box [name ='data']\") jQuery 这个元素对象的私有属性中叫做selector这个属性存储的值是当前本次查找的选择器的内容； context是当前本次查找的上下文12$(\"*\",$box) // context: document , selector:\"#box *\"$(\"*\", document.getElementById(\"box\") // context:div#box ,selector:\"*\"; jQuery 中有两个each 和两个map 原理一样，map 支持返回值1&gt; 循环选择器获取到的jQuery 集合的每一项， 语法： $(“div”).each()123$(\"div\").each(function(index,item)&#123; console.log(item;) &#125;) 2&gt; 循环数组，类数组，对象中的每一项 语法：$.each()123456789$.each([23,43,11,44,33,32,3,34,5,6],function(index,item)&#123; console.log(item;)&#125;);$.each(document.getElementsByTagName(\"*\"),function(index,item)&#123; console.log(item);&#125;);$.each(&#123;name:\"李四\",age:'27'&#125;, function(index,item)&#123; console.log(item);&#125;); 3&gt; $.makeArray == likeArray 事件.stop()和.finish()$box.stop().hide():结束上一个动画，下面的动画紧接着当前的位置开始运动的.finish():结束上一个动画，并且让元素快速的到达目标位置，在开始下一个动画 效果动画不错的文章","categories":[],"tags":[]},{"title":"null和undefined的区别","slug":"null和undefined的区别","date":"2017-12-07T08:03:55.000Z","updated":"2019-02-23T03:55:04.552Z","comments":true,"path":"2017/12/07/null和undefined的区别/","link":"","permalink":"http://yoursite.com/2017/12/07/null和undefined的区别/","excerpt":"","text":"概念null :空对象指针 —&gt; 没有具体的值 —&gt; 一般都是我们手动设置初始的值为null,后期的话会给其赋值undefined : 未定义—&gt; 连这个属性都没有 —&gt; 一般都是浏览器默认值一， null使用场景1，我们设定一个变量，后期需要使用，那么我们前期设置默认值为null123456var timer = null;function move()&#123; window.clearTimeout(timer); timer = window.setTimeout(move,1000);&#125;move(); 2, 在js内存释放中，我们想释放一个堆内存，就让其值变为null即可12var obj = &#123;name:\"李翠英\"&#125;;obj = null; //刚开始开辟的这个堆内存没有被占用，浏览器会在空闲的的时候把它销毁 3, 我们通过DOM 中提供的属性和方法获取页面中的某一个元素标签，如果当前标签不存在，获取的结果就是null,而不是undefined。1document.getElementById(\"div1\") // 如果页面中没有#div1,获取的结果就是null 4, 在正则的exec/字符串的match 捕获中,如果当前要捕获的字符串和正则不匹配的话,捕获的结果为null1234var reg =/\\d+?/g;var str = \"zhufengpeixun\" ;reg.exec(str) //nullstr.match(reg) //nulll undefined 使用场景1, 在js 预解释的时候，只声明未定义，默认的值是undefined;12console.log(num); //undefinedvar num = 13; 2, 在一个函数中，如果没有写retrun,或者return 后面啥都返回,默认的返回值是underfind12345function fn()&#123;&#125;var res = fn();console.log(res); //undefined 3, 函数中设置了形参，但是执行的时候如果没有传递参数的值，那么形参默认值是undefined123456function fn(a,b,c)&#123; a =10; b = 20; c = undefined // arguments[2] =30;让形参c 的值边为30&#125;fn(10,20) 4，获取一个对象的属性名对应的属性值，如果当前的这属性名不存在的话，属性值默认是 undefined12var obj =&#123;&#125;;console.log(obj.name); //undefined 应用这个道理来检测当前的浏览器是否兼容一个方法window.getComputedStyle 获取当前元素经过浏览器计算的样式在标准浏览器里面我们获取到的结果是 function getComputedStyle(){[native code]}在IE6~8中，我们获取到的是 undefined,不兼容 getComputedStyle12345678910111213141516function getCss (curEle,attr)&#123; var val =null,reg =null; if(\"getComputedStyle\" in window)&#123; val = window.getComputedStyle(curEle,null)[attr]; &#125;else&#123; if(attr ===\"opacity\")&#123; val = curEle.currentStyle[\"filter\"]; //\"alpha(opacity=10)\" reg = /^alpha\\(opacity=(\\d+(?:\\.\\d+)?)\\)$/i; val = reg.test(val) ? reg.exec(val[1]/100):1; &#125; val = curEle.currentStyle[attr]; &#125; // 去掉单位的正则 reg = /^-?(\\d+(\\.d+)?)(px|pt|rem|em)?$/i; return reg.test(val)? parseFloat(val):val;&#125;","categories":[],"tags":[]},{"title":"js盒子属性","slug":"js盒子属性","date":"2017-12-06T13:51:16.000Z","updated":"2019-02-23T03:55:04.551Z","comments":true,"path":"2017/12/06/js盒子属性/","link":"","permalink":"http://yoursite.com/2017/12/06/js盒子属性/","excerpt":"","text":"JS盒子的十三个属性如下：client 系列的1，clientWidth: 内容的宽度+左右填充2，clientHeight: 内容的高度+上下填充（和内容溢出没有关系）3，clientLeft: 左边框的宽度（border[left/top]width)4, clientTop: 上边框的宽度内容的宽度和高度： 我们设置width/height这两个样式就是内容的宽和高；如果没有设置height值，容器的高度会根据里面的内容自己进行适应 offset 系列的5，offsetParent:当前父级参照物6，offsetWidth: 1，clientWidth+左右边框 （和内容溢出没有关系）7，offsetHeight: 1，clientWidth+上下边框（和内容溢出没有关系）8，offsetLeft:当前元素的外边框距离父级参照物的左边内边距的偏移量9, offsetTop: 当前元素的外边框距离父级参照物的上边内边距的偏移量 scroll 系列的一，scrollWidth /scrollHeight :和我们的内容溢出有关系。1》 在内容没有溢出的情况下他的值和 clientWidth/clientHeight 一样。2》 在有内容溢出的情况下获取结果如下规则： scrollWidth: 真是内容的宽度（包含溢出）+左填充 scrollHeight: 真是内容的高度（包含溢出）+上填充3》 获取的结果都是约等于值，因为：同一个浏览器我们是否设置overflow = “hidden” 对于最终的结果有影响；在不同的浏览器下获取的值也相等二， scrollLeft/scrollTop : 滚动条卷去的width/height 关于JS盒子模型的取值问题上面十三个属性获取到的结果永远不可能是小数，都是整数，浏览器会在原来真是的结果进行四舍五入。 关于操作浏览器本身的盒子模型信息1》 浏览器的可视窗口的宽度和高度（也就是平时的一屏的宽和高） 就是 clientWidth/clientHeight 的值2》scrollWidth/scrollHeight 是当前页面的的内容真是高度包含溢出的部分（即所有屏加起来的高度，是一个个大概值。还有兼容问题 一般我们需要些两套如下：1，获取浏览器当前的可视窗口：document.documentElement.clientWidth || document.body.clientWidth;document.documentElement.clientHeight|| document.body.clientHeight;document.documentElement.clientLeft|| document.body.clientLeft; 获取元素的样式方法1， box.style.属性名 的方法 只能获取到行内样式（外链的样式时获取不到的）2， 使用window.getComputedStyle 这个方法获取所有经过浏览器计算过得样式(只要当前的元素标签可以在页面中呈现出来，那么他的所有样式都是经过浏览器计算或渲染过得) 语法： window.getComputedStyle(box,null); 第一个参数：当前要操作的元素对象， 第二个参数是：当前元素的伪类（一般不写） 获取到的结果是 css styleDeclaration 这个类的一个实例：包含可当前元素的所有样式属性和值 如图： ; 通以上方法获取某个属性值如下图： ; 这个方法在IE 下有兼容问题在IE6~8 下使用 currentStyle俩获取所用经过浏览器计算过得样式console.dir(box.currentStyle).width 以上十三个属性和方法都是只读属性。只有scrollTop 和scorllLef这两个属性是唯一可以读和写的属性一，针对box1box.scrollTop = 0 // 直接回到顶部 scrollTop 是有边界的(最大值和最小值)；最小值： 0；最大值：是真是的高度减去当前容器一屏幕的高度。maxVal = box.scrollHeight-box.clientHeight 二， 针对整个屏幕 demo;","categories":[],"tags":[]},{"title":"正则","slug":"正则","date":"2017-12-03T23:45:39.000Z","updated":"2019-02-23T03:55:04.559Z","comments":true,"path":"2017/12/04/正则/","link":"","permalink":"http://yoursite.com/2017/12/04/正则/","excerpt":"","text":"正则的作用一， 正则：他就是一个规则，用来处理字符串的一个规则（正则就是用来处理字符串）处理：1》匹配： 判断一个字符串是否符合我们的规则 ，语法： test:reg.test(str);1234var reg = /\\d/ ; //包含一个0~9 之间的任意一个数字console.log(reg.test(\"今天天气真好啊\")）; //falseconsole.log(reg.test(\"123\")); //trueconsole.log(reg.test(\"今年是2017\")) //true 2》捕获： 把字符串中符合我们正则规则的内容捕获到 ,语法： exec: reg.exec(str);1234var reg = /\\d/;console.log(reg.exec(\"今天天气真好啊\")）; //nullconsole.log(reg.exec(\"123\")); //[\"1\", index:0,input:\"123\"]console.log(reg.exec(\"今年是2017\")); //[\"2\",index:3,input:\"今年是2017\"] 3》创建件一个正则的两种方式字面量的方式：var reg = /\\d/; 占一位实例创建方式：var reg = new RegExp(“”); // 传进来的是字符串 在字面量方式中，我们//之间包起来的所有的内容都是元字符，有的具有特殊的意义，大部分都是代表本身普通含义的元字符。4》 两种创建的正则的区别：1， 字面量方式中出现的一切都是元字符，不能进行变量值得拼接，而实例创建的方式是可以的2，字面量的方式中可以直接写\\d就可以，而在实例中需要把它转译\\d 常用的元字符：每一个正则表达式都是有元字符和修饰符组成的。元字符指在//之间具有某种意义的一些字符1》 具有某种特殊意义的元字符\\:转义字符，转译后字面符所代表的的含义。^:以某一个元字符开始$:以某一个元字符结束^和$ 两元字符是不占位的。\\n:匹配换行符.: 除了\\n 以外的任何字符12345678// 第一种情况 可以匹配任意的 单个 字符、英文字母、数字，以及它本身var reg=/^0.2$/ //以0开头，以2结尾，中间可以是除了\\n 的任意字符。console.log(reg.test(\"0.2\"))console.log(reg.test(\"0-2\"))// 第二种：有的时候，我们不想让“.”去匹配任何的字符，仅仅想让它匹配“.”这一单个字符，也就是仅匹配它本身，此时，可以使用“\\.”来对它进行转义。reg = /^0\\.2$/console.log(reg.test(\"0.2\"))console.log(reg.test(\"0-2\")) ():分组 把一个大正则划分成一个小正则。1var reg = /^（\\d+）zhufeng（\\d+）$/ x|Y : x 或者y 中的一个 字符组1，基本语法中括号是特殊标记，用以划定属于组内的字符的界限[xyz] : 所代表的含义是：“匹配x或者y 或者 z ”。字符组虽然由多个字符构成，但它仍只匹配单个 字符，而字符组能够匹配的单个字符，即是它定义中的字符（“[]”内的字符）。“[]”本身不进行字符匹配，它仅仅划定字符组边界。[]: 划定字符组边界2，在字符组中使用字符区间[a-z]:a到z 之间的任意字符如果要在字符组(“[”“]”内)中匹配“-”； 而在“[”“]”以外，“-”变成了一个普通字符，无需再进行转义3, 反义字符组 需要匹配“除了某些字符以外”的其他字符，这时候，我们可以使用反义字符组，其语法是：“[^字符集合]”[^a-z] : 除了a到z 之间的任意字符[^xyz] : 除了x,y,z 这三个以外的任意字符 \\d : 0~9 之间的任意一个数字\\D : 除了0~9之外的的任意字符\\b : 匹配边界符\\w : 数字，字母，下划线中的任意字符 [0-9a-zA-Z_]\\W : 所有单个非大小写字母、非数字、非下划线，与 [^a-zA-Z0-9_] 相同\\s : 匹配一个空白字符，空格，一个制表符， 2》 代表出现次数的量词元字符*: 出现0 到多次+: 出先1到多次？: 出现0 或者1一次{n}: 出现n次{n,}:出现n次到多次{n,m}: 出现n到m次 123var reg = /^\\d$/; // 代表以数字开始和结尾，中间必须是一个数字。// 简单验证手机号的正则var reg = /^1\\d&#123;10&#125;$/ 元字符应用规则一， []1》 在中括号中出现的所有的字符都是代表本身的意思（没有特殊含义）123var reg = /^[.]$/;console.log(reg.test(\"1\"))console.log(reg.test(\".\")) 2》 中括号中不识别两位数123var reg = /^[12]$/ // 1或者2 中的一个var reg = /^[12-45]$/ // 1,2-4中的一个,5 这三个中的一个var reg = /^[\\w-]$/ // 数字，字母，下划线， 中杠，中的任意字符 3》二 ，()1,分组的作用一：改变x|y的默认优先级1234var reg = /^18|19$/; 代表的意思是以1或8 开头的，以1或者9 结尾的斗能匹配上。// 18 ,19,181,119,819,1819....var reg = /^(18|19)$/ 代表必须是以18 开头或是19 结尾的// 18 2, 分组引用12345// \\1 和第一个分组出现的一模一样的内容，\\2和第二个分组出现的一模一样的内容// 一模一样： 和对应的分组中的内容的值都要一模一样var reg = /^(\\w)\\1(\\w)\\2$/;console.log(reg.test('bbff')) // true;console.log(reg.test('b0f-')) // false; 3, 分组捕获 –》 正则在捕获的时候，不仅仅把大正则匹配的内容捕获到，而且还可以把小分组匹配的内容捕获到123456789 var reg = /^(\\d&#123;2&#125;)(\\d&#123;4&#125;)(\\d&#123;4&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(\\d)(\\d|X)$/; var str = '130521198404102075'; console.log(reg.exrec(str))//ary = [\"130521198404102075\", \"13\", \"0521\", \"1984\", \"04\", \"10\", \"20\", \"7\", \"5\", index: 0, input: \"130521198404102075\"] var reg2 = /^(\\d&#123;2&#125;)(\\d&#123;4&#125;)(\\d&#123;4&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(?:\\d)(?:\\d|X)$/; var str = '130521198404102075'; console.log(reg2.exrec(str))//ary = [\"130521198404102075\", \"13\", \"0521\", \"1984\", \"04\", \"10\", \"20\", index: 0, input: \"130521198404102075\"] （?:） 在分组中？: 的意思是只匹配不捕获。 有效数字的的正则分析： 有效数字包含： 整数，负数，小数，零。1） “.” 可以出现也可以不出现，但是一旦出现，后面必须跟着一位或者多位数字2）最开始可以使+/- 也可以没有3）整数部分，可以是一位或者多位数字，但是多位数时不能以0 开头1var reg = /^[+-]?(\\d|([1-9]+\\d+))(\\.\\d+)?$/ 年龄18到65之间分析：拆分为 18-19，20-59，60-651var reg = /^(1[8-9]|[2-5]\\d|6[0-5])$/ 验证邮箱的647812808@qq.com647812808@qq.com.cnlicuying@quner.cnli_cui_ying@163.com分析：@ 左边的：数字，字母，下划线 ， ‘-‘ ,’.’ @右边的点之前： 数字和字母， - .xxxx: .字母（两到四位数）出现1-2次var reg = /^[\\w.-]+@[0-9a-zA-Z]+(.[a-zA-z]{2,4}){1,2}$/ 身份证号码简版： var reg = /^\\d{17}(\\d|X)$/ 正则捕获exec –&gt;正则捕获 正则捕获到的内容格式: 1&gt;捕获到的内容是一个数组 数组中的第一项是当前大正则捕获到的内容 index : 捕获内容在字符串中开始的索引位置 input:捕获的原字符串 2&gt; 正则捕获的特点 1）懒惰性： 每一次执行exec 只捕获第一个匹配的内容，在不进行处理的情况下在多次执行，捕获的还是第一个匹配的内容。 2） lastIndex : 正则每一次捕获在字符创中开始查找的位置，默认值是0. 如何解决正则的懒惰性 ？ –&gt; 在正则的末尾加一个修饰符 “g”1234567891011var reg = /\\d+/gvar str = \"ljkfsk20160804jkfskj2017\";//第一次执行console.log(reg.lastIndex) //0console.log(res.exec(str)) [\"20160804\", ...]//第二次执行console.log(reg.lastIndex) //14console.log(res.exec(str))//['2017',...]// 第三次执行console.log(reg.lastIndex) //25console.log(res.exec(str)) //null 3) 自己编写的程序获取正则捕获的所有的内容 123456789101112function execArr(reg,str)&#123; var ary = [],res = reg.exec(str); while(res)&#123; ary.push(res[0]); res = res.exec(str); &#125; return ary&#125;var reg = /\\d+/g;var str = '2018加油加油再加油，发发发，8888'；arr = execArr(reg,str);console.log(arr) 正则的修饰符修饰符： g ,i,mglobal : 全局查找ignoreCase: 忽略大小写multiline: 多行匹配4) 贪婪性 正则的每一次捕获都是按照匹配最长的结果捕获的， 例如：上面的捕获到的2 也符合正则，2018也符合正则，我们默认捕获到的就是2018.123var reg = /\\d+/g;var str = \"jiayou2018ganchao2017xingfu2019\";console.log(reg.test(str)) // ['2018' ...] 5) 如何解决正则的贪婪性呢？ –&gt;只需要在量词的后面添加一个 ？ 即可123var reg = /\\d+?/g;var str = \"jiayou2018ganchao2017xingfu2019\";console.log(reg.test(str)) // ['2' ...] ? 在正则中的五种作用1， 放在一个普通的元字符后面代表出现0 -1次 2， 放在一个量词元字符后面代表是取消捕获时的贪婪性3， (?:） 在分组中？: 的意思是只匹配不捕获。4, 形式：(?=pattern)所谓正向预查，意思就是：要匹配的字符串，后面必须紧跟着pattern！123456789var reg = /cainiao(?=8)/;var str='cainiao9';alert(reg.exec(str));//返回null。var reg = /cainiao(?=8)/;var str='cainiao8';alert(reg.exec(str));// 返回 cainiao//匹配cainiao。需要注意的是，括号里的内容并不参与真正的匹配，只是检查一下后面的字符是否符合要求而已，例如上面的正则，返回的是cainiao，而不是cainiao8。 5,形式(?!pattern)和?=恰好相反，要求字符串的后面不能紧跟着某个pattern，于正向预查正好相反12345678var reg = /cainiao(?=8)/;var str='cainiao9';alert(reg.exec(str));//返回 cainiaovar reg = /cainiao(?=8)/;var str='cainiao8';alert(reg.exec(str));// null 正则的捕获方法： 正则的exec 方法 字符串的match 方法， 字符串的replace 方法一， 字符串的match方法 把所有和正则匹配的字符都获取到12345678910var reg = /\\d+/;var reg2 = /\\d+/g;var reg3 = /\\d+?/g;var str = '拼搏2018，努力2019，笑看2020'；var ary= str.match(reg)var ary2= str.match(reg2)var ary3= str.match(reg3)console.log(ary) // [\"2018\", index: 2, input: \"拼搏2018，努力2019，笑看2020\"]console.log(ary2) // [\"2018\", \"2019\", \"2020\"]console.log(ary3) //[\"2\", \"0\", \"1\", \"8\", \"2\", \"0\", \"1\", \"9\", \"2\", \"0\", \"2\", \"0\"] match方法的局限性： 在分组捕获的情况下，match 只能获取带大正则匹配的内容，而对于小分组正则捕获的内容是无法获取到的1234567891011121314 var reg = /nuli(\\d+)/g; var str = 'nuli2018nuli2019nuli2020'; // 使用exec 需要执行三次结果入下： 可以获取大正则和分组的正则内容 console.log(reg.exec(str)) //[\"nuli2018\", \"2018\", index: 0, input: \"nuli2018nuli2019nuli2020\"] console.log(reg.exec(str)) //[\"nuli2019\", \"2019\", index: 8, input: \"nuli2018nuli2019nuli2020\"] console.log(reg.exec(str)) //[\"nuli2020\", \"2020\", index: 16, input: \"nuli2018nuli2019nuli2020\"]0: \"nuli2020\"1: \"2020\"index: 16input: \"nuli2018nuli2019nuli2020\"length: 2__proto__: Array(0)// 使用match 方法的结果：也就体现了match 的局限性的体现console.log(str.match(reg)) // [\"nuli2018\", \"nuli2019\", \"nuli2020\"] 区别： 就在于有没有捕获到分组的内容 二， replace 的应用replace :将原有的字符替换成我们新的字符1） 在不使用正则的情况下，执行一次replace 只替换字符串中的一个字符。2） 在replace 中我们可以一次批量的把所有正则匹配到的内容替换掉—》replace 是支持正则的。replace第一项值是一个正则的实现原理是：先按照正则制定的规则，到我们的字符串中把正则匹配的内容捕获到，然后在每一次捕获到之后，都把捕获到的内容替换成新的内容。1） 我们正则表达式捕获几次，对应后面的function 方法就执行几次。2）每次执行function 的时候，里面传递的参数值arguments 和我们单独执行exec捕获的内容一致),即使有分组我们也可以获取到分组的不活的内容3）在function 中，通过return 来返回替换的内容不写return ,默认使用undefined来进行替换如果不想实现替换，捕获内容是什么我们就返回什么。12345678910111213141516var str = \"lisilisi2016zhangsanzhangsan2017\"; str = str.replace(/(\\d+)/g,function()&#123; console.log(arguments) //每一次捕获到的内容和exec执行的结果一样 // 分组内容 arguments[1] 第一个分组捕获的内容 return yanyan 把捕获到的内容替换成return 后面的值 &#125;) console.log(str) var str = \"20171205\"; var arr = [\"零\",\"壹\",\"贰\",\"叁\",\"肆\",\"伍\",\"陆\",\"柒\",\"捌\",\"玖\"]; str = str.replace(/\\d/g,function()&#123; //var num = arguments[0]; //var str = arr[num]; //return str return arr[arguments[0]] &#125;) console.log(str)","categories":[],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://yoursite.com/tags/js基础/"}]},{"title":"call和apply","slug":"call和apply","date":"2017-11-28T12:29:34.000Z","updated":"2019-02-23T03:55:04.549Z","comments":true,"path":"2017/11/28/call和apply/","link":"","permalink":"http://yoursite.com/2017/11/28/call和apply/","excerpt":"","text":"call1234567891011// Function.prototype.call = function()&#123;&#125;var obj = &#123;name:\"珠峰培训\"&#125; function fn()&#123; console.log(this); &#125; fn() obj.fn() //obj.fn is not a function fn.call(obj) call 方法的作用：首先我们让原型上的call方法执行，在执行call方法的时候，我们让fn方法中的this 变为第一个参数值。然后再把fn 这个函数执行； 1234567891011121314var obj = &#123;name:\"珠峰培训\"&#125; function fn()&#123; console.log(this); &#125;Function.prototype.myCall = fu.ction(context)&#123; //让this这个函数中的“this\" 关键字变成“context\"的值 var that = eval( this.toString().replace(\"this\",\"obj\")); this() //让fn 执行&#125;fn.mySCall(obj) // this是fn 里面的this fn.sum(obj) //this是sum 里面的this function sum()&#123;console.log(this)&#125; 1234567function fn1()&#123;console.log(1)&#125;;function fn2()&#123;console.log(2)&#125;;fn1.call(fn2); //只改变this，但没有用的。fn1.call.call(fn2) fn1.call.call.call.call.call(fn2)Function.prototype.call(fn1)Function.prototype.call.call.call(fn1)","categories":[],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://yoursite.com/tags/js基础/"}]},{"title":"函数的三种角色","slug":"函数的三种角色","date":"2017-11-28T11:48:48.000Z","updated":"2019-02-23T03:55:04.554Z","comments":true,"path":"2017/11/28/函数的三种角色/","link":"","permalink":"http://yoursite.com/2017/11/28/函数的三种角色/","excerpt":"","text":"函数本身也会有自己的属性：1》length:0;形参的个数2》name:Fn;3》prototype:类的原型，在原型上定义的方法都是当前Fn这个类的实例公有的方法。4》proto 把函数当做一个普通的对象，指向Function这个类的原型 一，一个函数存在多面性：12345678910111213141516function Fn()&#123; //普通函数 var num = 500; // 普通函数 this.x = 100; // 只有带有this.xxx 的才是实例私有的属性和法方&#125;Fn.prototype.getX = function()&#123; console.log(this.x);&#125;Fn.aaa = 1000; // 普通对象var f = new Fn; // 执行的时候就变成一个类。console.log(f.num ) //当做类(this.xxx才是实例继承的东西)console.log(f.aaa) var res = Fn();console.log(res())// 普通函数执行， Fn 里面的this 指向Windowsconsole.log(Fn.aaa) //普通对象 1, “普通函数” : 它本身就一个普通函数, 执行的时候形成私有作用域（闭包）形参赋值，预解释，代码执行，执行完成后栈内存销毁或是不销毁。2,”类”: 他有自己的实例，也有一个叫做prototype 属性是自己的原型，他的实例都是可以指向自己的原型3,”普通对象” : 和 var object={}中的object 一样，就是一个普通的对象，他作为对象可以有一些自己的私有的属性，也可以通过proto 找到Function.prototype这三者之间没有关系。","categories":[],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://yoursite.com/tags/js基础/"}]},{"title":"面向对象(二)","slug":"面向对象(二)","date":"2017-11-26T13:21:27.000Z","updated":"2019-02-23T03:55:04.562Z","comments":true,"path":"2017/11/26/面向对象(二)/","link":"","permalink":"http://yoursite.com/2017/11/26/面向对象(二)/","excerpt":"","text":"“原型继承”是JS 中最常用的一种继承方式12345678910function A ()&#123; this.x =100,&#125;A.prototype.getX = function()&#123; console.log(this.x);&#125;;function B ()&#123; this.y = 200,&#125;B.prototype = new A; //继承父类A 的所有私有和公有的属性和方法 原型继承：就是子类B 想继承父类A中的所有的属性个方法（私有加公有的）只需要让B.prototype = new A 即可。;特点： 它是把父类中的私有的和公有的属性和方法都继承到了子类原型上（都成了子类的公有方法）。核心： 原型继承并不是把父类中的属性和方法克隆一份一模一样的给B，而是让子类B和父类A 之间增加了原型链的链接，以后B的实例n 想要父类A中的getX 方法，只需要一级一级向上查找来使用。; call 继承 结果是： 把父类私有的属性和方法克隆一份一模一样的，作为子类私有的属性12345678910111213function A()&#123; this.x =100;&#125;A.prototype.getX = function()&#123; console.log(this.x)&#125;function B ()&#123; this.y = 200; A.call(this); //把A执行让A中的this 变成子类B 的实例&#125;var n = new B;console.log(n.x) 冒充对象继承： 把父类私有的加公有的属性和方法克隆一份给子类私有的12345678910111213141516function A()&#123; this.x =100;&#125;A.prototype.getX = function()&#123; console.log(this.x)&#125;function B ()&#123; this.y = 200; var temp = new A; for(var key in temp)&#123; this[key] = temp[key] // 这里的this 指的是 n &#125; temp null;&#125;var n = new B;console.log(n.x) 混合模式继承是，原型+call 的继承。1234567891011121314function A()&#123; this.x =100;&#125;A.prototype.getX = function()&#123; console.log(this.x)&#125;function B ()&#123; A.call(this); //把A执行让A中的this 变成子类B 的实例&#125;B.prototype = new A;B.prototype.constructor = B;var n = new B;console.log(n.x) 继承组合的继承1234567891011121314 function A()&#123; this.x =100;&#125;A.prototype.getX = function()&#123; console.log(this.x)&#125;function B ()&#123; A.call(this); //把A执行让A中的this 变成子类B 的实例&#125;B.prototype = objectCreate(A.prototype) ;B.prototype.constructor = B;var n = new B;console.log(n.x) 中间类继承法1234function avgFn()&#123; arguments.__proto__ = Array.prototype; //arguments就可以直接用数组的所有方法 arguments.sort()&#125;","categories":[],"tags":[]},{"title":"Date相关的知识点","slug":"Date相关的知识点","date":"2017-11-24T00:45:32.000Z","updated":"2019-02-23T03:55:04.546Z","comments":true,"path":"2017/11/24/Date相关的知识点/","link":"","permalink":"http://yoursite.com/2017/11/24/Date相关的知识点/","excerpt":"","text":"将时间戳转换成日期格式// 获取当前的年,月,日,时,分,秒12345678910111213141516171819var date = new Date(); // 当前时间戳date.getFullYear(); // 获取完整的年份(4位,1970)date.getMonth()+1; // 获取月份(0-11,0代表1月,用的时候记得加上1)date.getDate(); // 获取日(1-31)date.getTime(); // 获取时间(从1970.1.1开始的毫秒数)date.getHours(); // 获取小时数(0-23)date.getMinutes(); // 获取分钟数(0-59)date.getSeconds(); // 获取秒数(0-59)// 例子：//比如需要这样的格式 yyyy-MM-dd hh:mm:ssvar date = new Date(1398250549490);Y = date.getFullYear() + '-';M = (date.getMonth()+1 &lt; 10 ? '0'+(date.getMonth()+1) : date.getMonth()+1) + '-';D = date.getDate() + ' ';h = date.getHours() + ':';m = date.getMinutes() + ':';s = date.getSeconds(); console.log(Y+M+D+h+m+s); // 输出结果：2014-04-23 18:55:49 将日期格式转换成时间戳// 也很简单var strtime = ‘2014-04-23 18:55:49:123’;var date = new Date(strtime); //传入一个时间格式，如果不传入就是获取现在的时间了，这样做不兼容火狐。// 可以这样做var date = new Date(strtime.replace(/-/g, ‘/‘)); // 有三种方式获取，在后面会讲到三种方式的区别time1 = date.getTime();time2 = date.valueOf();time3 = Date.parse(date); /三种获取的区别：第一、第二种：会精确到毫秒第三种：只能精确到秒，毫秒将用0来代替比如上面代码输出的结果(一眼就能看出区别)：139825054912313982505491231398250549000 / Date()参数形式有7种new Date(“month dd,yyyy hh:mm:ss”);new Date(“month dd,yyyy”);new Date(“yyyy/MM/dd hh:mm:ss”);new Date(“yyyy/MM/dd”);new Date(yyyy,mth,dd,hh,mm,ss);new Date(yyyy,mth,dd);new Date(ms); 比如:new Date(“September 16,2016 14:15:05”);new Date(“September 16,2016”);new Date(“2016/09/16 14:15:05”);new Date(“2016/09/16”);new Date(2016,8,16,14,15,5); // 月份从0～11new Date(2016,8,16);new Date(1474006780); 实例展示demo理解","categories":[],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://yoursite.com/tags/js基础/"}]},{"title":"字符串类","slug":"字符串","date":"2017-11-23T07:01:44.000Z","updated":"2019-02-23T03:55:04.556Z","comments":true,"path":"2017/11/23/字符串/","link":"","permalink":"http://yoursite.com/2017/11/23/字符串/","excerpt":"","text":"字符串对象是字符串类的实例。一个字符串是有多个字符组成的。str.length 获取字符串中字符的个数（字符串的长度）字符串中也存在索引，也是从零开始，”evsdfb “ 里面所有的空格，换行等这些特殊字的符号也是一个字符。字符串常用的方法： 1&gt; charAt(索引) 获取指定索引位置的字符 2&gt; charCodeAt(索引) 获取指定索引位置的字符对应的ASCII值 ASCII值：每一个字母，汉子，特殊字符号都有一个对应的码值(Unicode) 123for(var i=0;i&lt;str,length;i++)&#123; console.log(str.charCodeAt(i));&#125; 3, 字符串截取的substr(n,m) 从索引n开始截取m个字符。(包含m ) 将找到的字符串返回substring(n,m) 从索引n开始，找到索引m 处（不包含m)将找到的字符串返回slice(n,m) 从索引n开始，找到索引m 处（不包含m)将找到的字符串返回 。slice 支持负数为索引，str.length + 负数索引4，查找字符的索引indexOf(字符): 获取指定字符字符串中出现的索引位置lastIndexOf(字符) :获取指定字符在字符串中最后一次出现的索引位置。如果没有这个字符，返回的是-1， 4,转换大小写 toLowerCase() :将所有字母转换成小写toUpperCase() :将所有字母转换成大写 5, 替换repalce(要替换的老字符, 替换的新字符)var str = “djfnlmfs”;console.log(str.repalce(“j”,’o’)) //“dofnlmfs” 6, 将字符串按照指定的分割符拆分成数组splice(分隔符)var s = “1+2+4” ;console.log(s.split(“+”)); 案例练习：1234567891011var time = \"2017-11-24 12:33:5\";//2017年11月24日 12时55分03秒// 按照空格，把字符串拆成[\"2017-11-24\",\"12:33:5\"]// 拿出数组的第一项在按照 — 拆成[\"2017\",\"11\",\"24\"]//拿出数组的第二项 再按照 ： 拆成[\"12\",\"33\",\"5\"]function formatTime ()&#123; var arg = time.s.split(\" \"); var firstArg = arg[0].split(\"-\"); var sendArg = arg[1].split(\":\"); console.log(firstArg)&#125; demo理解 获取URL后面的参数获取地址栏中URL地址问号传递的参数值https://www.baidu.com/s?wd=javascript&amp;rsv_spt=1&amp;issp=1目标：把问号传递的参数值分别的解析出来obj = {wd:’javascript’,rsv_spt:1,issp:1}1234567891011121314151617function queryURLParameter(url) &#123; //=&gt;url:传递的参数(我们当前要解析的URL地址) var quesIndex = url.indexOf('?'),obj = &#123;&#125;; if (quesIndex === -1) &#123; //-&gt;url中没有问号传参:直接返回空对象 return obj; &#125; url = url.substr(quesIndex + 1); var ary = url.split('&amp;'); for (var i = 0; i &lt; ary.length; i++) &#123; var curAry = ary[i].split('='); obj[curAry[0]] = curAry[1]; &#125; return obj; &#125; console.log(queryURLParameter('https://www.baidu.com/s?wd=javascript&amp;rsv_spt=1&amp;issp=1')); console.log(queryURLParameter('https://www.baidu.com/s?wd=node')); 12345678910String.prototype.myQueryURLParameter = function myQueryURLParameter() &#123; var obj = &#123;&#125;,reg = /([^=?&amp;]+)=([^=?&amp;]+)/g; this.replace(reg, function () &#123; var arg = arguments; obj[arg[1]] = arg[2]; &#125;); return obj; &#125;; var str = 'https://www.baidu.com/s?wd=javascript&amp;rsv_spt=1&amp;issp=1'; console.log(str.myQueryURLParameter());","categories":[],"tags":[{"name":"js 继基础","slug":"js-继基础","permalink":"http://yoursite.com/tags/js-继基础/"}]},{"title":"常用数学方法","slug":"常用数学方法","date":"2017-11-23T02:09:19.000Z","updated":"2019-02-23T03:55:04.557Z","comments":true,"path":"2017/11/23/常用数学方法/","link":"","permalink":"http://yoursite.com/2017/11/23/常用数学方法/","excerpt":"","text":"常用的数学方法一，Math1&gt; Math.abs() 取绝对值2&gt; Math.ceil() 向上取整3&gt; Math.floor() 向下取整4&gt; Math.round() 四舍五入5&gt; Math.max() 求最大值6&gt; Math.min() 求最小值7&gt; Math.random() 获取（0-1）之间的随机小数获取n~m 之间的随机整数Math.random(Math.random()*(m-n)+n)12345678910111213141516171819 function getRandom(n,m)&#123; n = Number(n); m = Number(m); if(isNaN(n)||isNaN(m))&#123; return Math.round(); &#125; if(n&gt;m)&#123; var temp = n; n = m; m = temp &#125; return Math.round(Math.random()*(m-n)+n); &#125;//获取4位 0-61之间的随机数var arg=[];for(var i=0;i&lt;4;i++)&#123; arg.push(getRandom(0,61));&#125;console.log(arg) ES6 新增Math.trunc() :方法用于去除一个数的小数部分，返回整数部分。12345Math.trunc(4.1) // 4Math.trunc(4.9) // 4Math.trunc(-4.1) // -4Math.trunc(-4.9) // -4Math.trunc(-0.1234) // -0 对于非数值，Math.trunc内部使用Number方法将其先转为数值。1234Math.trunc(NaN); // NaNMath.trunc('foo'); // NaNMath.trunc(); // NaNMath.trunc(undefined) // NaN Math.sign() 用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。它会返回五种值。 参数为正数，返回+1；参数为负数，返回-1；参数为 0，返回0；参数为-0，返回-0;其他值，返回NaN。12345Math.sign(-5) // -1Math.sign(5) // +1Math.sign(0) // +0Math.sign(-0) // -0Math.sign(NaN) // NaN 如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回NaN。12345678Math.sign('') // 0Math.sign(true) // +1Math.sign(false) // 0Math.sign(null) // 0Math.sign('9') // +1Math.sign('foo') // NaNMath.sign() // NaNMath.sign(undefined) // NaN","categories":[],"tags":[{"name":"js 基础","slug":"js-基础","permalink":"http://yoursite.com/tags/js-基础/"}]},{"title":"引用数据类型","slug":"引用数据类型","date":"2017-11-22T09:11:17.000Z","updated":"2019-02-23T03:55:04.558Z","comments":true,"path":"2017/11/22/引用数据类型/","link":"","permalink":"http://yoursite.com/2017/11/22/引用数据类型/","excerpt":"","text":"栈内存，作用域，的理解。在刚开始加载页面的时候，浏览器会天生自带一个供我们当前js 代码执行的环境，我们把这个环境称之为“栈内存” 也叫作用域。而且开始加载页面的那个作用域称之为全局作用域（Window）在全局作用域先声明的变量叫全局变量，也叫做通用变量。栈内存/作用域: 是用来从上到下执行js 代码的和基本数据类型的值存在了栈内存里。堆内存: 是用来存储引用数据类型里面的值得。123456var num= 12;var obj = &#123; name:\"李四\", age: 34, job:\"IT\"&#125; 当开始加载js 代码之前，首先会把当前全局作用域下所有带有var 和function 关键字的进行提前声明或者定义，我们把这种机制叫做“预解释”,也叫做变量提升.声明：declare 就是var 变量名。定义： defined 就是给变量赋值引用数据类型：先开辟一个内存空间，把属性名和属性值存起来，我们把这个用来存储值的内存空间叫做”堆内存”。实例详解1&lt;div id=\"box\" style=\"width:100px\";height=\"100px\"&gt;实例详解&lt;/div&gt; 1234// t通过DOM法方获取的元素都是对象数据类型的，用typeof检测返回的结果是“object”。既然是对象数据类型的，就存在相关的属性名和属性值。var oDiv = document.getElementById(\"box\");console.dir(oDiv);oDiv.style.backgroundColor = \"red\"; 图解：var oDiv = document.getElementById(“box”);; oDiv.style.backgroundColor = “red”;; var ostyle = oDiv.style;ostyle.backgrondColor = “red”;; var c = oDiv.style.baclgroundColor; // 是一个基本类型的值c = “red” 是无法改变背景颜色的。 ;","categories":[],"tags":[]},{"title":"JS 预解释","slug":"JS-预解释","date":"2017-11-22T07:42:32.000Z","updated":"2019-02-23T03:55:04.548Z","comments":true,"path":"2017/11/22/JS-预解释/","link":"","permalink":"http://yoursite.com/2017/11/22/JS-预解释/","excerpt":"","text":"预解释定义：1&gt;预解释发生的环境： 预解释是放生在当前作用域下的， 把带var 和 function 关键字的变量提升到当前作用域的顶层(函数的提升最高，会覆盖同名的其他变量)，但只是声明或者定义。2&gt; 针对的对象是 带var 和 function 关键字的， 带var 的变量只是声明，而function 关键字的是声明加定义。3&gt; 一个function 在代码执行之前，就会在（进行预解释的时候）就把声明和定义完成了，在接下来执行代码的过程中，如果在遇到定义的那块代码，就直接跳过就好。; 12345678910111213141516console.log(total) // undefined var变量只是提升但没有定义var total= 0;sum(1,2,3) //6 因为函数的在预解释时候已经把函数提升到最高的顶层，然后在开始执行。所以函数在定义代码之前也可以执行。function sum()&#123; var total = null; for(var i = 0;i&lt;arguments.length;i++)&#123; var val = Number(arguments[i]); console.log(val) if(isNaN(val))&#123; continue; &#125; total+=val ; &#125; return total; &#125;sum(1,\"2\",3,\"a\") //6 ; 4&gt; 函数开始执行就会形成一个私有作用域,(栈内存)，首先进行就是预解释，其次代码执行(在这个函数中定义的变量都是私有的变量)形成的这个作用域保护里面的私有变量不受外界的干扰。我们把这种机制叫做闭包。5&gt; 函数执行一次就形成一个新的私有作用域，一般情况每一次形成的私有作用域都会自动消毁。 JS中的预解释的理解一，预解释是毫无节操的一种机制，自从有了预解释，从此节操是路人。1》预解释的时候不管条件是否成立，都要把带var的进行提前声明1234if(!(\"num\" in window))&#123; // in : 是判断num是否为window 这个对象的一个属性，是的话返回true,不是的话返回的是false. var num = 12&#125;console.log(num) //undefined 带var 的变量会提升值作用域顶端，但是不会赋值，所以（”num“ in window）为真，取反为falsa.后面代码就不会执行了。所以是 undefined. 2》 预解释的时候至预解释”=“ 左边的，右边的值不参与预解释。3》 自执行函数也是不能预解释的。因为自执行函数是定义可执行一起完成的，所以当代码执行到这个位置的时候定义和执行一起完成了。4》 在函数里里面，return 下面声明和定义的变量不会执行但是会预解释。变量提升。后面的是返回值，也是不做预解释的。12345678function fn()&#123; //预解释 console.log(num); //undefined 而不是报错 return function()&#123; // 因为是返回值，所以不会预解释 &#125; var num = 100;&#125; 5》 如果在预解释的时候，如果名字已经声明过了，不需要重新的声明，但是需要重新赋值在JS中如果变量的名字和函数的名字重复了，也算冲突。1234var fn = 13;function fn ()&#123; console.log(\"ok\")&#125; 1234567891011fn(); //2function fn()&#123; console.log(1)&#125;;fn(); //2var fn = 10;fn(); // 报错function fn()&#123; console.log(2)&#125;fn() 匿名函数包含两种1, 函数表达式 : 把函数定义的部分当做一个值给变量或是元素的绑定事件123456789var fn = function()&#123;&#125;oDiv.onclick =function()&#123;&#125;window.setTimeout(function()&#123;&#125;,1000); 2, 自执行函数: 定义和执行放在一起操作了。定义完了紧接着就执行了。12345678910111213141516// 第一种 ;(function(name)&#123; console.log('我的名字叫做'+name) &#125;)('李四'); // 第二种 ~function(name)&#123; console.log('我的名字叫做'+name) &#125;('李四'); // 第三种 +function(name)&#123; console.log('我的名字叫做'+name) &#125;('李四'); // 第四种 !function(name)&#123; console.log('我的名字叫做'+name) &#125;('李四');","categories":[],"tags":[]},{"title":"数据类型检测","slug":"数据类型检测","date":"2017-11-22T02:28:31.000Z","updated":"2019-02-23T03:55:04.558Z","comments":true,"path":"2017/11/22/数据类型检测/","link":"","permalink":"http://yoursite.com/2017/11/22/数据类型检测/","excerpt":"","text":"常用的数据检测方法1,typeof 用来检测数据类型的运算符,使用typeof检测数据类型 ,首先返回的都是一个字符串，其次是字符串中包含了对应的数据类型。例如：”number”,”string”,”boolean”,”undefined”,”function”,”object”. 12345678910111213console.log(typeof typeof typeof function()&#123;&#125;) //\"string\"function fn(num1,mun2)&#123; if(typeof num2===\"undefined\")&#123; num2 =0; &#125; //num2 = num||0&#125;function fn(callback)&#123; typeof callback === \"function\" ?callback():null; // 相同 //callback &amp;&amp; callback();&#125; 使用typeof检测数据类型,首先返回的都是一个字符串， 其次是字符串中包含了对应的数据类型 12//例如：\"number\" ,\"string\",\"boolean\",\"undefined\",\"function\",\"object\" // 局限性： typeof null //“object”; 2, instanceof 检测某一个实例是否属于某个类123var obj = [2,4,5];console.log(obj instanceof Array) //true console.log(obj instanceof RegExp) // false 局限性：1&gt; 不能检测基本的数据类型 不能用来检测和处理字面量方式创建出来的基本数据类型值对于基本数据类型来说，字面量方式创建出来的结果和实例方式创建出来的结果有一定的区别:从严格意义上讲，只有实例创建出来的结果才是标准的对象数据类型值，也是标准的Number 这个类的实例；对于字面量方式创建出来的结果是基本的数据类型值，不是严禁的实例，但是由于JS 的松散特点，导致了可以使用Number.prototype上提供的方法2&gt; 特性： 只要在当前实例的原型链上，我们用其检测出来的结果都是true12345678var ary =[];console.log(ary instanceof Array) //trueconsole.log(ary instanceof Object) //truefunction fn()&#123;&#125;console.log(fn instanceof Fuction) //trueconsole.log(fn instanceof Object) // true ;3&gt;在类的原型继承中，我们最后检测出来的结果未必准确12345function Fn()&#123;&#125;Fn.prototype = new Array; //原型链继承var f = new Fn; //f 不是数组 但是 console.log(f instance Array) // true 3, constructor 作用和instance 非常相似12345678910 var obj =[]; console.log(obj.constructor === Array) //true console.log(obj.constructor === RegExp) //false // 能检测基本数据类型 var num =1; console.log(num.constructor ===Number) // true// constructor 检测Object 和instance 不一样一般情况下检测不了原型上的 var reg = /^$/; console.log(reg.constructor === RegExp) // true console.log(reg.constructor === Object) // false 局限性：我们可以把类的原型进行重写，在重写的过程中很有可能出现把之前的construcor 给覆盖了，这样检测出来的结果也不准确123456function Fn ()&#123;&#125;Fn.prototype = new Array;var f = new Fn;console.log(f.constructor); //Array 在Js 对于特殊的数据类型null 和undfined,她们的所属类是Null和undefined， 但是浏览器把这个两个类保护起来了，不允许我们在外面访问使用。 4,Object.prototype.toString.call() 最准确的最常用的方式 首先获取Object 原型上的toString 方法，让方法执行，并且改变方法中的this关键字的指向。Object.prototype.toString 作用是返回当前方法的执行主体(方法中的this) 所属信息12345678910111213141516var obj = &#123;name:'lisi'&#125;console.log(obj.toString()) ;// toString中的this是obj，返回的是obj所属类的信息 \"[object,Object]\"//第一object 代表当前实例是对象数据类型的(固定死的) 第二个Object代表的是obj所属类型是Objectconsole.log()var ary=[];console.log(Object.prototype.toString.call(ary)===\"[object Array]\") // truevar reg = /^\\[object Object\\]$/;console.log(reg.test(Object.prototype.toString.call(ary))) // truefunction Fn ()&#123;&#125;Fn.prototype = new Array;var f = new Fn;console.log(Object.prototype.toString.call(f)===\"[object Array]\"); //false 1&gt; toString 的理解:转换为字符串：Number.prototype.toString() 对于Number ,string, boolean,Array,RegExp,Date, function 原型上的toString方法都是把当前的数据类型转化为字符串的类型(它们的作用仅仅是用来转换为字符串的); 但是Object.prototype.toString 并不是用来转换为字符串的({name:lisi}).toString() // “[object Object]”Math.toString() // “[object Object]”; console.log((1).toString()) // Number.prototype.toString 转换为字符串console.log((128).toString(2/8/10)) // 把数字转换为二进制/八进制/十进制 字符串上的 toString() 也是把字符串转化为字符串但是不支持参数","categories":[],"tags":[]},{"title":"作用域链","slug":"作用域链","date":"2017-11-18T08:39:13.000Z","updated":"2019-02-23T03:55:04.553Z","comments":true,"path":"2017/11/18/作用域链/","link":"","permalink":"http://yoursite.com/2017/11/18/作用域链/","excerpt":"","text":"如何区分全局变量和私有变量一， 全变量： 在全局作用域下定义的变量就是全局变量。1, 在全局作用域中，带var和不带var 关系区别：带var 的变量可以进行预解释， 所以在赋值前面执行不会报错；不带var 的变量是不能预解释的，在前面执行就会报错。1234console.log(num) // undefined var num = 12; console.log(num2) // Uncaught ReferenceError: num2 is not defined 当前变量不存在 num2 = 12 关系： 不带var 的变量(num =12) 相当于给window 增加了一个叫做num 的属性名，属性值是12.而带var num=12 首先它相当于给全局作用域增加一个全局变量num,但是不仅仅如此，它也相当于给window 增加了一个叫做num 的属性名，属性值是12.二， 在”私有作用域中声明的变量“和”函数形参“都是私有的变量。1,作用域链： 在私有作用域中，我们代码执行的时候遇到了一个变量，首先我们需要确定它是否为私有的变量，(看否是有var 关键字和是否是形参),如果是私有变量，则和外面的没有任何的关系。如果不是私有的，则会往当前作用域的上一级进行查找，如果上一级作用域还没有则继续往上一级查找，直到查到全局作用域(window).2, 私有作用域中出现的一个变量不是私有的，则会往上一级作用域进行查找，上级没有则继续向上查找，一直找到window为止，如果window下面有没有呢？ 1&gt;如果我们是获取值： console.log(total) 就会报错123456function fn()&#123; console.log(total); // Uncaught ReferenceError: num2 is not defined 当前变量不存在 total =100;&#125;fn();console.log(total) // 因为报错，所以报错后的所有代码在没有进行处理的情况下是不会执行的。 2&gt; 如果我们是设置值：total = 100; 相当于给window增加了一个属性名total,属性值是100。12345function fn()&#123; total = 100&#125;fn();console.log(total) //100 当函数执行的时候(直接目的：让函数体中的代码执行)，首先会形成私有的作用域，然后按照如下体执行步骤：1） 如果有形参，就给形参先赋值。2） 在进行私有作用域内的预解释3）私有作用域中的代码有上到下执行。123456789console.log(total) //undefinedvar total = 0 ;function fn(num1,num2)&#123; console.log(total) //undefined var total = num1+num2 console.log(total) //300&#125;fn(100,200);console.log(total) //0 如何查找上一级作用域?看当前函数是在哪个作用域下定义的，那么他的上一级作用域就是谁–》和函数在哪执行的没有任何的关系 123456789var num = 12;function fn()&#123; var num = 120; return function()&#123; console.log(num) &#125;&#125;var f = fn();fn(); // 120 ;1234~function ()&#123; var num = 1200; fn() //120 他是在上一级function fn()&#123;&#125; 这个函数执行形成作用域， 查找上一级作用域和方法在那定义的有关，在哪执行无关。&#125;() 关于内存释放和作用域销毁;里面三个栈内存两个堆内存 一， 堆内存是用来存放引用类型的代码12345// 开辟了一个堆内存 ,这个内存被obj1 占用了。var obj1 = &#123; name:\"张三\"&#125;var obj2 = obj1 ; // 这个内存又被obj2 占用的 不能销毁： 对象数据类型或者函数数据类型在定义的时候首先都会开辟一个堆内存，堆内存有一个引用的地址，如果外面有变量引用了这个内存地址，我们就说这个内存被占用了，就不能销毁了。销毁/释放内存，只需要把所有引用它的变量值赋值为null 即可。如果当前的堆内存没有任何变量占用，那么浏览器会在空闲的时候把它销毁…12obj1 = null;obj2 = null; 二， 栈内存（作用域）1，全局作用域： 只有当页面关闭的时候全局作用域才会销毁 2， 私有作用域（只有函数执行会产生私有作用域） 1&gt; 一般情况下，函数执行会形成一个新私有作用域，私有作用域中的代码执行完毕后，形成的作用域就会主动释放和销毁。 2&gt; 当前私有作用域中的部分内存被作用域以外的变量占用了，那么当前的这个作用域就不能销毁了。; A, 函数执行反回了一个引用数据类型的值，，并且在函数的外面被一个其他的变量给接受了，这种情况下一般形成的私有作用域都不会销毁。12345678910function fn()&#123; var num =100; return function()&#123; num++; console.log(num) &#125;&#125;var f = fn(); // fn 执行形成的私有作用域就不能销毁f() // 101 B,在一个私有作用域中给DOM元素的事件绑定方法，一般情况下我们的私有作用域都不销毁123456var oDiv = document.getElemnetById(\"div1\");~function()&#123; oDiv.onClik = function()&#123; &#125;&#125;() //当前自执行函数形成的这个私有作用域是不会被销毁的 ; C ， 下述情况属于不立即销毁： fn 返回的函数没有别其他的变量占用但是还需要只需一次，所以暂时不销毁，当返回的值执行完成后，浏览器会在空闲的时候把它销毁。 1234567function fn()&#123; var num = 100; return function()&#123; &#125;&#125;fn()() // 首先执行 fn函数，返回一个小函数对应的内存地址，然后紧接着让返回的小函数再执行 作用域练习题 i++ 和 ++i 都是自身累加1，在和其他的值进行运算的时候是有区别： i++： 先拿自身进行运算，运算完成本身在+1； ++i： 先本身进行累加1 ，然后在拿累加后的值去运算。1234567891011121314151617181920212223242526272829303132 function fn()&#123; var i =10; return function(n)&#123; console.log(n+(++i)) &#125; &#125; var f = fn(); f(10); f(20); f(30); 2 fn()(10); 不立即销毁 fn()(20) function fn(i)&#123; return function(n)&#123; console.log(n+i++) &#125; &#125; var f = fn(13); f(12); f(14) fn(15)(12); fn(16)(13) ``` 实例```html&lt;ul&gt; &lt;li class=\"fff\"&gt;aaaaa&lt;/li&gt; &lt;li class=\"fff\"&gt;bbbb&lt;/li&gt; &lt;li class=\"fff\"&gt;cccc&lt;/li&gt; &lt;li class=\"fff\"&gt;dddd&lt;/li&gt; &lt;li class=\"fff\"&gt;ffff&lt;/li&gt;&lt;/ul&gt; 12345678var oDiv = document.getElementsByClassName(\"fff\"); for (var i = 0; i &lt; oDiv.length; i++) &#123; ~function(l)&#123; oDiv[i].onclick=function()&#123; alert(l); &#125; &#125;(i) &#125; 综合练习题123456789101112131415161718var num =20;var obj = &#123; num:30, fn: (function(num)&#123; this.num*=3; num +=15; var num = 45; return function()&#123; this.num*=4; num+=20; console.log(num); &#125; &#125;)(num) //注意这里的num 是全局作用域下的num，因为obj对象不能形成私有作用域。如果想使用obj 里的num，就必须写成obj.num&#125;var fn = obj.fn;fn(); obj.fn(); console.log(window.num,obj.num) 123456789var test = (function(a) &#123; this.a = a; return function(b) &#123; return this.a + b; &#125;&#125;(function(a, b) &#123; return a;&#125;(1, 2)));console.log(test(1)); 1234567var arr = Array.from(&#123;length:100&#125;);var arr2 =arr.map((v,i)=&gt;&#123; v=i return v&#125;)console.log(arr2)","categories":[],"tags":[]},{"title":"编码","slug":"编码","date":"2017-11-16T14:04:09.000Z","updated":"2019-02-23T03:55:04.562Z","comments":true,"path":"2017/11/16/编码/","link":"","permalink":"http://yoursite.com/2017/11/16/编码/","excerpt":"","text":"encodeURIComponent(URIstring) 函数可把字符串作为URL 组件进行编码。参数： URIstring 必需。一个字符串，含有 URI 组件或其他要编码的文本。返回值： URLstring 的副本，其中的某些字符将被十六进制的转义序列进行替换。 案例：123document.write(encodeURIComponent(\"http://www.w3school.com.cn”)); //http%3A%2F%2Fwww.w3school.com.cndocument.write(encodeURIComponent(\"http://www.w3school.com.cn/p 1/“)) //http%3A%2F%2Fwww.w3school.com.cn%2Fp%201%2Fdocument.write(encodeURIComponent(\",/?:@&amp;=+$#”)) //%2C%2F%3F%3A%40%26%3D%2B%24%23 应用场景：当你需要编码URL中的参数的时候，那么encodeURIComponent是最好方法。 最常用的encodeURI和encodeURIComponent对URL编码是常见的事，所以这两个方法应该是实际中要特别注意的。它们都是编码URL，唯一区别就是编码的字符范围，其中encodeURI方法不会对下列字符编码 ASCII字母、数字、~!@#$&amp;()=:/,;?+’encodeURIComponent方法不会对下列字符编码 ASCII字母、数字、~!()’所以encodeURIComponent比encodeURI编码的范围更大。 decodeURIComponent() 函数 可对 encodeURIComponent() 函数编码的 URI 进行解码。1234var test1=\"http://www.w3school.com.cn/My first/\"document.write(encodeURIComponent(test1)+ \"&lt;br /&gt;\") //http%3A%2F%2Fwww.w3school.com.cn%2FMy%20first%2Fdocument.write(decodeURIComponent(test1)) //http://www.w3school.com.cn/My first/","categories":[],"tags":[]},{"title":"ES6事件绑定","slug":"ES6事件绑定","date":"2017-11-15T04:20:43.000Z","updated":"2019-02-23T03:55:04.546Z","comments":true,"path":"2017/11/15/ES6事件绑定/","link":"","permalink":"http://yoursite.com/2017/11/15/ES6事件绑定/","excerpt":"","text":"react绑定事件方式1，触发点击事件时才执行 onChanageTab()这个函数，然后把结果赋给onTap123onTap =&#123;()=&gt;&#123; this.onChanageTab() &#125;&#125; 2 ,触发点击事件时才执行 onChanageTab这个函数，但这个函数只是定义但没有执行123456789 onTap =&#123;()=&gt;&#123; this.onChanageTab &#125;&#125;``` 3,不用触发点击事件，onChanageTab() 这个函数就执行了，然后就把值赋给了ontap```javascript onTap =&#123; this.onChanageTab() &#125; onTap12&lt;Touchable touchClass =\"tap-opacity\" onTap =&#123;()=&gt; &#123;this.onChanageTab()&#125;&#125;&gt; //这个组件里定义的。&lt;/Touchable&gt; react 原生的方式：123456789101112131415161718192021onClick = &#123;()=&gt;&#123;alert(‘click')&#125;&#125;class Square extends React.Component&#123; constructor(props)&#123; super(props); this.state=&#123; value:null &#125; &#125; changeStateVal()&#123; this.setState(&#123; value:'hello,word' &#125;) &#125; render()&#123; return( &lt;button className=\"Square\" onClick=&#123;()=&gt;&#123;this.changeStateVal()&#125;&#125;&gt; &#123;this.state.value&#125; &lt;/button&gt; ) &#125;&#125;","categories":[],"tags":[]},{"title":"原型和原型链","slug":"原型和圆型链","date":"2017-11-13T06:02:26.000Z","updated":"2019-02-23T03:55:04.554Z","comments":true,"path":"2017/11/13/原型和圆型链/","link":"","permalink":"http://yoursite.com/2017/11/13/原型和圆型链/","excerpt":"","text":"概念：1， 每一个对象（实例也是对象）都有一个天生自带的属性：下划线下划线proto下划线下划线,这个属性指向当前所属的原型2， 每一个函数(类也是一个函数)都有一个天生自带的属性：prototype(原型)，并且这个属性存储的值是一个对象数据类型的数据， 浏览器默认会给这个属性开辟一个堆内存，在这个内存中存储了相关的属性和方法。 1&gt; 其中constructor 就是天生自带的一个属性，constructor等于当前函数本身。 2&gt; 下划线下划线proto下划线下划线: prototype对应的值也是一个对象数据类型的值，所以也天生自带proto这个属性。 3&gt; 我们自己写的方法和属性：这部分属于当前类的公有属性和方法 1234567891011function Fn(num)&#123; this.a=num; this.b = function ()&#123; console.log(this.a) &#125;&#125;Fn.prototype.c =567;var fn1 = new Fn(); var fn2 = new Fn();console.log(fn1.a) //123console.log(fn2.a) //123 添加公有方法 有两种方式1，给实例的fn1 和fn2 的 proto原型链上添加方法2， 直接在Fn 上直接添加方法。 查找机制： 首先找当前实例的私有属性，如果私有属性中存在，找的就是私有属性有的方法，如果私有属性中没有，默认根据proto查找所属类prototype上的公有属性，公有属性里面有的话就是公有属性的，如果公有属性也没有，就根据proto在往上一级查找…直到找到Object这个基类的prototype为止，如果基类上也没有，则代表当前实例没有这个属性，返回的是undefined。; 批量添加原型公有方法和属性1&gt; 设置别名的方法12345678910111213141516171819202122232425function Fn()&#123; this.x = 100;&#125;//原始的方法Fn.prototype.getX = function()&#123; console.log(this.x)&#125;;Fn.prototype.getY = function()&#123; console.log(this.x)&#125;;Fn.prototype.getZ = function()&#123; console.log(this.x)&#125;;//起别名 的方式var pro = Fn.prototype; // 把原来原型指向的地址赋值给我们的pro对象变量，现在它们操作的是同一个内存别名空间pro.getX = function()&#123; console.log(this.x)&#125;;pro.getY = function()&#123; console.log(this.x)&#125;;pro.getZ = function()&#123; console.log(this.x)&#125;;var f1 = new Fn; 2&gt; 重构原型对象的方式: 自己新开辟一个堆内存，储存我们公有的属性和方法，把浏览器原来的给pro开辟的那个替换调。` javascriptfunction Fn(){ this.x = 100;}Fn .prototyoe ={ constructor:Fn, a:function(){ }, b:function(){ } }var fn = new Fn; console.log(f.constructor) 指向object 基类。// 1, 只有浏览器天生给Fn.prototype 开辟的堆内存里面才有constructor，而我们自己开辟的这个内存没有这个属性，这样construction指向不再是Fn而是object。我们没有做任何处理的时候，为了和原来的保持一致，我们需要手动的增加constructor 的指向Fn. //2,用这种方式给内置类增加公有的属性//例如给内置类Array 增加数组去重的方法//原始的方法 这种方式可以一个一个的修改内置的方法，当我们通过下述方式在数组的原型上增加方法，如果方法名和原来的内置方法名重复了，就会把原来数组内置的方法修改掉。因此我们以后再内置类上的原型上修改，增加方法，命名都需要加特殊的前缀。Array.prototype.unique = function(){ console.log(“this”)}var ary = [1,2,4,5,6,5,4,3,2,1]Array.prototype.sort = function(){ console.log(“ok”)}ary.sort();console.log(ary);//第二种方法Array.prototype = { constructor:Array, unique: function(){ } }//我们这种方法会把之前已经存在于原型上的属性和方法给替换调，所以我们这种方式修改内置类的，浏览器会屏蔽掉的。","categories":[],"tags":[]},{"title":"循环语句 ","slug":"循环语句","date":"2017-11-10T08:52:57.000Z","updated":"2019-02-23T03:55:04.558Z","comments":true,"path":"2017/11/10/循环语句/","link":"","permalink":"http://yoursite.com/2017/11/10/循环语句/","excerpt":"","text":"for 循环的四步曲：1&gt; 设置初始值 var i= 0；2&gt; 设置循环执行的条件 i&lt;5;3&gt; 执行循环体中的内容 {}4&gt; 每一轮循环完成后都执行我们的i++累加操作 break : 结束循环体 i++ 操作不执行 但 continue : 结束当前这一轮的的循环，然后在执行下一轮。i++ 还会执行在循环体内遇到break 和continue 这两个关键字，循环体中后面的代码就不执行了。 12345678910for(var i=0;i&lt;10;i++)&#123; if(i&lt;=5)&#123; i+=2; continue; &#125; i+=3; break; console.log(i) // 永远不会执行&#125;console.log(i) //9 1234567var oList = document.getElementById('list');var oLis = oList.getElementsByTagName('li');for(var i=0;i&lt;oLis.length;i++)&#123; var cur = oLis[i]; /修改class cur%2===0 ? cur.className=\"c1\" :cur.cur.className=\"c2\"&#125; for in 循环在遍历的时候，默认的话可以把自己私有的和他所属类原型上扩展的属性和方法都可以遍历到，但是一般情况下，我们遍历一个对象只需要遍历私有的即可，我们可以使用一下的判断进行处理：1234567if(obj.propertyIsEnumerable(key))&#123; console.log(key);&#125;// 在遍历时最常使用if(obj.hasOwnProperty(key))&#123; console.log(key)&#125;","categories":[],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://yoursite.com/tags/js基础/"}]},{"title":"数据类型","slug":"数据类型","date":"2017-11-10T03:50:15.000Z","updated":"2019-02-23T03:55:04.558Z","comments":true,"path":"2017/11/10/数据类型/","link":"","permalink":"http://yoursite.com/2017/11/10/数据类型/","excerpt":"","text":"常见的数据类型（简单数据类型和引用数据类型）1，简单数据类型： null ,undefined ,number,string ,Boolean2, 引用数据类型：object : Array(数组类) ,RegExp(正则类) ,时间(Date类), 字符串类(string) ,布尔类（Boolean）Math(数学类) Boolean 类型： 1， ! : 一个叹号是取反，首先将值转化成布尔类型的值，然后取反 console.log(!3) //false console.log(!null) //true2, !! :将其他的数据类型转化成Boolean类型，相当于Boolean()12console.log(Boolean('javascript');console.log(!!'javascript') 数据类型的转换规则一 ，一个叹号是取反，首先将值转化成布尔类型的值，然后取反. 如果只有一个值，判断这个值是真还是假，遵循：只有： 0 ，NaN ，” “ ,null,undefined 这五个是假值，其余的都是真值。 console.log(![]) //false二， 如果是两个值比较是否相等，遵循这个规则： 1， val1 == val2 两个值可能不是同一种数据类型，但值也会为真。因为==比较的话，会进行默认的数据类型转换。 但对象，数组，函数的比较时永不相等。 1&gt; 对象 == 对象 永远不相等 2&gt; 对象 == 字符串 //true 先将对象转换为字符串（调用对象的toString()方法），然后在进行比较 例如：[] == ‘’ //true [] 转化为字符串 “” ,然后在比较 {} 转化为字符串”[object object]” 例如： 1 = ’1‘ // true [] == [] //false {}=={} //false （{}） == ‘’ ; // false []==false //true 3&gt; 对象 == 布尔类型 对象先转化为字符串（toString）, 然后把字符串再转化为数字(Number ‘ ‘ 变成0)，布尔类型也转化为数字（true是1，false是0），最后在让两个数字比较 4&gt; 对象 == 数字 对象先转化为字符串（toString）, 然后把字符串再转化为数字(Number ‘ ‘ 变成0) 5&gt; 数字 == 布尔 布尔类型转换为数字在比较 6&gt; 数字 == 字符串 字符串转换成数字，在比较 7&gt; 字符串 == 布尔 都转换为数字在比较 8&gt; null == undefined 结果是true 9&gt; null 或者 undefined 和其他任何的数据类型比较都不相等。 三， 三个等号 绝对相等 val1 === val2 绝对比较 数据类型必须一致。 基本数据类型和引用类型的区别基本数据类型存储的是值而引用类型保存的是一个引用指针。","categories":[],"tags":[{"name":"js 基础","slug":"js-基础","permalink":"http://yoursite.com/tags/js-基础/"}]},{"title":"css选择器","slug":"css选择器","date":"2017-11-03T12:27:00.000Z","updated":"2019-02-23T03:55:04.550Z","comments":true,"path":"2017/11/03/css选择器/","link":"","permalink":"http://yoursite.com/2017/11/03/css选择器/","excerpt":"","text":"一，基本选择器1， ：通用选择器，匹配任何元素。 例如： {margin:0;paddig:0}2, E ：标签选择器， 匹配所有使用E标签的元素。 例如： p{font-size:2rem}3，.info: class选择器。匹配所有class属性包含info的元素。 例如： .infor{color:#000} p.info{color:#000}4, #footer : id 选择器。 例如：#footer{backgruond:#fefefe} p#footer{background:#fefefe} 二 多元素组合选择器5，E F ： 多元素选择器，同时匹配所有E元素或F元素，E和F之间用逗号分隔例如：div , p { color:#f00; }6，E F:后代元素选择器，匹配所有属于E元素后代的F元素，E和F之间用空格分隔例如：#nav li { display:inline; }7，E&gt;F： 子元素选择器，匹配所有E元素的子元素F例如： div &gt; strong { color:#f00; }8，E+F ： 毗邻元素选择器，匹配所有紧随E元素之后的同级元素F（兄弟节点）例如：p + p { color:#f00; }9，E ~ F 匹配任何在E元素之后的同级F元素（所有弟弟节点） 三，属性选择器10，E[att] :匹配所有具有att属性的E元素，不考虑它的值。（注意：E在此处可以省略，比如”[cheacked]”。以下同。）例如： p[title]{color:#f00}11， E[att=val] :匹配所有att属性等于”val”的E元素例如：div[class=error] { color:#f00; }12，E[att~=val]: 匹配所有att属性具有多个空格分隔的值、其中一个值等于”val”的E元素例如：td[headers~=col1] { color:#f00; }13，E[att|=val] :匹配所有att属性具有多个连字号分隔（hyphen-separated）的值、其中一个值以”val”开头的E元素，主要用于lang属性，比如”en”、”en-us”、”en-gb”等等例如：p[lang|=en] { color:#f00; } 四: 伪类选择器 E:first-child: 匹配父元素的第一个子元素例如：p:first-child { font-style:italic; } E:link : 匹配所有未被点击的链接 E:visited: 匹配所有已被点击的链接 E:active : 匹配鼠标已经其上按下、还没有释放的E元素 E:hover: 匹配鼠标悬停其上的E元素 E:focus: 匹配获得当前焦点的E元素 E:lang(c) : 匹配lang属性等于c的E元素 五, 伪元素 E:first-line 匹配E元素的第一行例如：p:first-line { font-weight:bold; color;#600; } E:first-letter 匹配E元素的第一个字母例如：.preamble:first-letter { font-size:1.5em; font-weight:bold; } E:before 在E元素之前插入生成的内容例如：.cbb:before { content:””; display:block; height:17px; width:18px; background:url(top.png) no-repeat 0 0; margin:0 0 0 -18px; } E:after 在E元素之后插入生成的内容例如：a:link:after { content: “ (“ attr(href) “) “; } 六，CSS 3 属性选择器 E[att^=”val”] 属性att的值以”val”开头的元素 E[att$=”val”] 属性att的值以”val”结尾的元素 E[att*=”val”] 属性att的值包含”val”字符串的元素 七，CSS 3中与用户界面有关的伪类序号 选择器 含义 E:enabled 匹配表单中激活的元素 E:disabled 匹配表单中禁用的元素 E:checked 匹配表单中被选中的radio（单选框）或checkbox（复选框）元素 E::selection 匹配用户当前选中的元素 八， CSS 3中的结构性伪类32, E:root 匹配文档的根元素，对于HTML文档，就是HTML元素33, E:nth-child(n) : 匹配其父元素的第N个子元素，第一个编号为1.34, E:nth-last-child(n) 匹配其父元素的倒数第n个子元素，第一个编号为135, E:nth-of-type(n) 与:nth-child()作用类似，但是仅匹配使用同种标签的元素36, E:nth-last-of-type(n) 与:nth-last-child() 作用类似，但是仅匹配使用同种标签的元素37, E:last-child 匹配父元素的最后一个子元素，等同于:nth-last-child(1)38, E:first-of-type 匹配父元素下使用同种标签的第一个子元素，等同于:nth-of-type(1)39, E:last-of-type 匹配父元素下使用同种标签的最后一个子元素，等同于:nth-last-of-type(140, E:only-of-type 匹配父元素下使用同种标签的唯一一个子元素，等同于:first-of-type:last-of-type或 :nth-of-type(1):nth-last-of-type(1)41, E:empty 匹配一个不包含任何子元素的元素，注意，文本节点也被看作子元素 九，css3 反选伪类 42, E:not() :匹配不符合当前选择器的任何元素 例如：:not(p) { border:1px solid #ccc; } 十， CSS 3中的 :target 伪类 E:target 匹配文档中特定”id”点击后的效果","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"npm模块安装机制简介","slug":"npm模块安装机制简介","date":"2017-10-31T12:00:17.000Z","updated":"2019-02-23T03:55:04.552Z","comments":true,"path":"2017/10/31/npm模块安装机制简介/","link":"","permalink":"http://yoursite.com/2017/10/31/npm模块安装机制简介/","excerpt":"","text":"npm 是Node 的模块管理器，功能极其强大。 安装别人写好的模块1$mpm install npm install 命令是用来安装模块到node_modules 目录例如： $ npm install &lt;文件名&gt; 过程是安装之前 npm install 会先检查，node_modules 目录之中是否已经存在指定的模块。 如果存在，就不在重新安装了，即使远程仓库已经有了一个新版版本，也是如此。 如果希望一个模块不管是够安装过，npm 都要强制重新安装可以使用 $ nom install &lt;模块名&gt; –force || $npm install &lt;模块名&gt; -f npm updata 跟新已安装模块的命令$ npm updata &lt;模块名&gt; 它会先到远程仓库查询最新的版本，然后在查询本地版本，如果本地版不存在或者远程版本比较新，就会安装 缓存目录npm install或npm update命令，从 registry 下载压缩包之后，都存放在本地的缓存目录。这个缓存目录，在 Linux 或 Mac 默认是用户主目录下的.npm目录，在 Windows 默认是%AppData%/npm-cache。通过配置命令，可以查看这个目录的具体位置。 $ npm config get cache$HOME/.npm你最好浏览一下这个目录。 $ ls ~/.npm 或者$ npm cache ls你会看到里面存放着大量的模块，储存结构是{cache}/{name}/{version}。 $ npm cache ls react~/.npm/react/react/0.14.6/~/.npm/react/react/0.14.6/package.tgz~/.npm/react/react/0.14.6/package/~/.npm/react/react/0.14.6/package/package.json每个模块的每个版本，都有一个自己的子目录，里面是代码的压缩包package.tgz文件，以及一个描述文件package/package.json。除此之外，还会生成一个{cache}/{hostname}/{path}/.cache.json文件。比如，从 npm 官方仓库下载 react 模块的时候，就会生成registry.npmjs.org/react/.cache.json文件。这个文件保存的是，所有版本的信息，以及该模块最近修改的时间和最新一次请求时服务器返回的 ETag 。 { “time”:{ “modified”:”2016-01-06T23:52:45.571Z”, // … }, “_etag”:”\\”7S37I0775YLURCFIO8N85FO0F\\””}对于一些不是很关键的操作（比如npm search或npm view），npm会先查看.cache.json里面的模块最近更新时间，跟当前时间的差距，是不是在可接受的范围之内。如果是的，就不再向远程仓库发出请求，而是直接返回.cache.json的数据。.npm目录保存着大量文件，清空它的命令如下。 $ rm -rf ~/.npm/* 或者$ npm cache clean 模块的安装过程总结一下，Node模块的安装过程是这样的。发出npm install命令npm 向 registry 查询模块压缩包的网址下载压缩包，存放在~/.npm目录解压压缩包到当前项目的node_modules目录注意，一个模块安装以后，本地其实保存了两份。一份是~/.npm目录下的压缩包，另一份是node_modules目录下解压后的代码。但是，运行npm install的时候，只会检查node_modules目录，而不会检查~/.npm目录。也就是说，如果一个模块在～/.npm下有压缩包，但是没有安装在node_modules目录中，npm 依然会从远程仓库下载一次新的压缩包。这种行为固然可以保证总是取得最新的代码，但有时并不是我们想要的。最大的问题是，它会极大地影响安装速度。即使某个模块的压缩包就在缓存目录中，也要去远程仓库下载，这怎么可能不慢呢？另外，有些场合没有网络（比如飞机上），但是你想安装的模块，明明就在缓存目录之中，这时也无法安装。","categories":[],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}]},{"title":"文本截子方法","slug":"文本截子方法","date":"2017-10-22T08:07:23.000Z","updated":"2019-02-23T03:55:04.559Z","comments":true,"path":"2017/10/22/文本截子方法/","link":"","permalink":"http://yoursite.com/2017/10/22/文本截子方法/","excerpt":"","text":"单行文本溢出隐藏加省略号的方法(有一些浏览器需要设置宽和高)text-overflow: ellipsis; 12345678.box&#123; overflow:hidden; &#125;.box p&#123; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;&#125; WebKit浏览器或移动端的页面-webkit-line-clamp用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的WebKit属性。常见结合属性：1,display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。2,-webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。3,text-overflow: ellipsis;，可以用来多行文本的情况下，用省略号“…”隐藏超出范围的文本123456overflow : hidden;text-overflow: ellipsis;display: -webkit-box;//文本的行数-webkit-line-clamp: 2;-webkit-box-orient: vertical; 不换行截子的css 样式`css选择器 { display:block;/行内元素需加/ word-break:keep-all;/ 不换行，二选一/ white-space:nowrap;/ 不换行 ，二选一/ overflow:hidden;/ 内容超出宽度时隐藏超出部分的内容 / text-overflow:ellipsis;/ 当对象内文本溢出时显示省略标记(…) ；需与overflow:hidden;一起使用。/}1， white-space : 属性设置如何处理元素内空白。 ; 2, word-break: css3新增的 自动换行的处理方法，可能值为： ; 隐藏多余的文字的CSS样式：1， overflow:属性规定当内容溢出元素框时发生的事情。可能取值为： ; 2, text-overflow(CSS3新增属性) :属性规定当文本溢出包含元素时发生的事情。可能取值为： ; 这里要注意的是只有overflow和text-overflow两个属性同时使用才会达到多出宽度的文字用省略号代替。","categories":[],"tags":[{"name":"css基础","slug":"css基础","permalink":"http://yoursite.com/tags/css基础/"}]},{"title":"Dom总结","slug":"Dom总结","date":"2017-10-08T07:13:07.000Z","updated":"2019-02-23T03:55:04.546Z","comments":true,"path":"2017/10/08/Dom总结/","link":"","permalink":"http://yoursite.com/2017/10/08/Dom总结/","excerpt":"","text":"一，DOM的概念和属性1，什么是DOMDOM 是Document Object Model 的缩写。是对XML文档的内容进行表示的模型。它把XML文档看作是一系列node和node间的关系，每一个node都当做一个对象，所有又叫做文档对象模型。我们可以把DOM理解为DOM树(html文档)，有很多的节点(元素)构成。 2，DOM的属性节点三要素(节点的属性)： 节点的类型（nodeType），节点的值(nodeValue)，节点的名称(nodeName)1,节点的类型（nodeType):只读属性,表示的是该节点的类型。属性可用来区分不同类型的节点， 比如常用类型： 元素(1),属性(2)和文本(3)。123456nodeType == 1; //元素节点 大写的标签名nodeType == 2 ;// 属性节点 nodeType == 3; // 文本节点 #textnodeType == 8 ; //注释节点 nodeType ==9 ; //document文档节点var type = node.nodeType; 2，节点的值(nodeValue)：Node.nodeValue 属性返回或设置当前节点的值。 语法:1let value = node.nodeValue; //value是一个包含当前节点的值的字符串（如果有的话） 常用的三种节点类型中，元素节点是没有nodeValue 值的，返回的是null; 文本节点返回的是文本的内容，属性节点返回的是该属性的属性值 如果nodeValue的值为null,则对它赋值也不会有任何效果.3，节点的名称(nodeName):返回当前节点的节点名称, 只读属性. 语法：1let str = node.nodeName; 遍历节点树4, Node.childNodes (获取所有的子节点)返回包含指定节点的子节点的集合(空格和换行都当做文本节点处理)，该集合为即时更新的集合包含所有类型的节点。 Node.children （获取所有元素节点） 返回的都是元素节点的所有子节点（只是元素节点的集合）有兼容问题，火狐不支持，IE包含注释节点6, Node.parentNode 返回指定的节点在DOM树中的父节点.(永远是一个元素节点)7，Node.firstChild/firstElementChild （获取所有子节点中的第一个节点）只读属性返回树中节点的第一个子节点，如果节点是无子节点，则返回 null。(包含所有类型节点)8，Node.lastChild/lastElementChild （获取所有子节点中的最后一个）是一个只读属性，返回当前节点的最后一个子节点。如果父节点为一个元素节点，则子节点通常为一个元素节点，或一个文本节点，或一个注释节点。如果没有子节点，则返回 null。9, Node.nextSibling/nextElementSibling（获取下一个弟弟节点）是一个只读属性，返回其父节点的 childNodes 列表中紧跟在其后面的节点，如果指定的节点为最后一个节点，则返回 null。10, Node.previousSibling /previousSiblingElementSibling(获取上一个各个节点)返回当前节点的前一个兄弟节点,没有则返回null.11， document 节点是没有父元素。document节点的parentNode属性将返回null. document.nodeType的值是9.文本内容12，innerHTML : 获取元素节点的内容13，Node.innerText 是一个表示一个节点及其后代的“渲染”文本内容的属性。14， Node.textContent 属性表示一个节点及其后代的文本内容。 语法：1234// 获得文本内容:let text = element.textContent;// 设置文本内容:element.textContent = \"this is some sample text\"; (1)描述:如果 element 是 Document，DocumentType 或者 Notation 类型节点，则 textContent 返回 null。如果你要获取整个文档的文本以及CDATA数据，可以使用 document.documentElement.textContent。如果节点是个CDATA片段，注释，ProcessingInstruction节点或一个文本节点，textContent 返回节点内部的文本内容（即 nodeValue）。对于其他节点类型，textContent 将所有子节点的 textContent 合并后返回，除了注释、ProcessingInstruction节点。如果该节点没有子节点的话，返回一个空字符串。在节点上设置 textContent 属性的话，会删除它的所有子节点，并替换为一个具有给定值的文本节点。(2)与innerText的区别Internet Explorer 引入了 node.innerText。意图类似，但有以下区别：textContent 会获取所有元素的内容，包括 p标签 元素，然而 innerText 不会。innerText意识到样式，并且不会返回隐藏元素的文本，而textContent会。由于 innerText 受 CSS 样式的影响，它会触发重排（reflow），但textContent 不会。与 textContent 不同的是, 在 Internet Explorer (对于小于等于 IE11 的版本) 中对 innerText 进行修改， 不仅会移除当前元素的子节点，而且还会永久性地破坏所有后代文本节点（所以不可能再次将节点再次插入到任何其他元素或同一元素中）。(3)与innerHTML的区别正如其名称，innerHTML 返回 HTML 文本。通常，为了在元素中检索或写入文本，人们使用innerHTML。但是，textContent通常具有更好的性能，因为文本不会被解析为HTML。此外，使用textContent可以防止 XSS 攻击。 二，DOM 中常用的增删改查方法1，创建节点 和 文本节点1234567//动态创建元素节点var oDiv = document.createElement('div');//它创建的是一个元素节点，所以nodeType等于1，oDiv.nodeName将返回oDiv;// 文本节点var text = document.createTextNode('I love js');//它创建的是一个文本节点，所以nodeType等于3，text.nodeName将返回#text; 2, 复制节点 Node.cloneNode() 方法返回调用该方法的节点的一个副本.语法：1234let dupNode = node.cloneNode(deep);//node 将要被克隆的节点// dupNode 克隆生成的副本节点//deep 可选 是否采用深度克隆,如果为true,则该节点的所有后代节点也都会被克隆,如果为false,则只克隆该节点本身. 需要注意的1，克隆一个元素节点会拷贝它所有的属性以及属性值,当然也就包括了属性上绑定的事件(比如onclick=”alert(1)”),但不会拷贝那些使用addEventListener()方法或者node.onclick = fn这种用JavaScript动态绑定的事件.2，在使用Node.appendChild()或其他类似的方法将拷贝的节点添加到文档中之前,那个拷贝节点并不属于当前文档树的一部分,也就是说,它没有父节点.3，如果deep参数设为false,则不克隆它的任何子节点.该节点所包含的所有文本也不会被克隆,因为文本本身也是一个或多个的Text节点.4 ，如果deep参数设为true,则会复制整棵DOM子树(包括那些可能存在的Text子节点).对于空结点(例如img和input元素),则deep参数无论设为true还是设为false,都没有关系,但是仍然需要为它指定一个值.5 ，如果克隆后，Id 一样，需要用setAttribute(‘id’,’another_id’),改变新的节点。 以上 创建节点 和 文本节点,复制节点 都是游离状态，不会自动添加到文档中，需要配合 appendChild()或者 insertBefore()方法或者replaceChild()方法。3，插入节点 appendChild()语法：123var oDiv = document.createElement('div');document.appendChild(oDiv)// 插入指定节点的最后一个子节点列表后添加一个新的子节点。 移动元素功能 查看demo 4, 插入节点 insertBefore() 在当前节点的某个子节点之前再插入一个子节点。语法：1var insertedElement = parentElement.insertBefore(newElement, referenceElement); insertedElement: 是被插入后的新节点，即 newElementparentElement :这个方法是由父元素调用的。newElement: 是要插入的新节点referenceElement : 在插入newElement之前的那个节点位置.(如果没有这个参数的话就和appendChild()方法一样)1234var parentElement = document.getElementById('parentElement');var childElement = document.getElementById('childElement');var span = document.createElement(\"span\");;var newElement = parentElement.insertBefore(span,childElement); 5, 删除节点 removeChilid() 从DOM中删除一个子节点。返回删除的节点.语法：1let removeEle = parentNode.removeChilid(ele); removeEle : 删除的节点parentNode: 父元素调用这个方法ele: 要删除的元素案例一：指定父元素123456789&lt;div id=\"top\" align=\"center\"&gt; &lt;div id=\"nested\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var d = document.getElementById(\"top\"); var d_nested = document.getElementById(\"nested\"); var throwawayNode = d.removeChild(d_nested);&lt;/script&gt;` 结果是1&lt;div id=\"top\" align=\"center\"&gt;&lt;/div&gt; 案例二： 未指定父元素12345678&lt;div id=\"top\" align=\"center\"&gt; &lt;div id=\"nested\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;var d_nested = document.getElementById(\"nested\");var p = d_nested.parentNode;p.removeChilid(d_nested);&lt;/script&gt; 结果同上 6, 替换节点 replaceChild(）用指定的节点替换当前节点的一个子节点，并返回被替换掉的节点。语法：1replacedNode = parentNode.replaceChild(newChild, oldChild); newChild : 用来替换 oldChild 的新节点。如果该节点已经存在于DOM树中，则它会被从原始位置删除。oldChild : 被替换掉的原始节点。replacedNode: 和oldChild相等。parentNode:父元素调用这个方法案例：12345678910&lt;div&gt;&lt;span id=\"childSpan\"&gt;foo bar&lt;/span&gt;&lt;/div&gt;&lt;script&gt; var sp1 = document.createElement(\"span\"); sp1.setAttribute(\"id\", \"newSpan\"); var sp1_content = document.createTextNode(\"新的span元素的内容.\"); sp1.appendChild(sp1_content); var sp2 = document.getElementById(\"childSpan\"); var parentDiv = sp2.parentNode; parentDiv.replaceChild(sp1, sp2);&lt;/script&gt; 结果：123&lt;div&gt; &lt;span id=\"newSpan\"&gt;新的span元素的内容.&lt;/span&gt;&lt;/div&gt; 7,设置/获取/删除/判断是否有属性的一系列方法语法:123456789101112131415161718192021setAttribute() // 设置元素的属性（包含自定义属性） 修改了html元素的结构。var a = document.createElement(\"p\");a.setAttribute('title','my demo');// &lt;p title=\"my demo\"&gt;&lt;/p&gt;getAttribute() // 获取属性方法&lt;div id=\"tab\" title='标题'&gt;&lt;/div&gt;var a = document.getElementById('tab');var b = a.getAttribute('title')//结果： console.log(b) // 标题hasAttribute() //方法返回一个布尔值，表示当前元素节点是否包含指定属性。var d = document.getElementById('div1');if (d.hasAttribute('align')) &#123; d.setAttribute('align', 'center');&#125;removeAttribute() //从当前元素节点移除属性。// HTML代码为 &lt;div id=\"div1\" align=\"left\" width=\"200px\"&gt;&lt;/div&gt;document.getElementById('div1').removeAttribute('align');// 现在的HTML代码为 &lt;div id=\"div1\" width=\"200px\"&gt;&lt;/div&gt; 这个方法在IE6-8 先不能修改class属性。 8，查找节点12345678910111213141516171819202122// 返回当前文档中第一个类名为 \"myclass\" 的元素,移动端我们获取元素常用的方法（IE6/7/8 不兼容）var el = document.querySelector(\"#myclass\"); //获取一个// 返回一个文档中所有的class为\"note\"或者 \"alert\"的div元素var els = document.querySelectorAll(\"div.note, div.alert\"); //获取多个类数组集合document.querySelectorAll('input[type =\"radio\"]')// 2, document.getElementById('xxx')// 获取元素id 在整个文档中，通过元素的ID 获取到这个元素对象，上下文是document.// 若果页面中id 重复了，那么这个方法默认只获取第一个元素，在IE 6/7 下，input里面neme 也当id 使用；还不区分大小写。// 若果没有获取到，返回null.var el = document.getElementById('xxx');// 3，获取节点的name获取节点,主要应用于表单具有name属性的元素。 返回是具有同样名称的节点类数组 然后，我们可以通过要获取节点的某个属性来循环判断是否为需要的节点var els = document.getElementsByName(elementName) //应用于获取具有同样name 的表单元素// 获取元素class通过元素的类名（class值）var els = document.getElementsByClassName('highlight');// 4,document.getElementsByTagName('td');// 获取元素标签元素 通过节点的Tag获取节点集合，同样该方法也是返回一个类数组// document称之为上下文(content),就是我们自己可以限定当前获取元素的范围。var els = document.getElementsByTagName('td'); // 5, document.getElementsByClassName(‘tab’);通过元素的类名获取class 值。var eles = document.getElementByClassName(‘tab’) // 6，document.body //获取body// 7, document.documentEelement // 获取HTML 文档 9. hasChildNodes方法返回一个布尔值,表明当前节点是否包含有子节点.1element.hasChildNodes() 总结有三种方法可以判断当前节点是否有子节点。node.firstChild !== nullnode.childNodes.length &gt; 0node.hasChildNodes()","categories":[],"tags":[{"name":"js 基础","slug":"js-基础","permalink":"http://yoursite.com/tags/js-基础/"}]},{"title":"flex布局","slug":"flex","date":"2017-09-20T11:17:05.000Z","updated":"2019-02-23T03:55:04.550Z","comments":true,"path":"2017/09/20/flex/","link":"","permalink":"http://yoursite.com/2017/09/20/flex/","excerpt":"","text":"Flex布局是什么Flex 是Flexible Box 的缩写，意为‘弹性布局’，任何一个容器都可以制定为Flex 布局12345678// 块级元素指定Flex.box&#123; display:flex;&#125;// 行内元素使用flex span&#123; display:inline-flex&#125; Webkit 内核的浏览器，必须加上-webkit前缀。1234 .box&#123; display:-webkit-flex; display:flex;&#125; 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。 flex 常见的布局1，子元素均分父盒子的宽度123456.box&#123; display:flex;&#125;.box .item&#123; flex:1;&#125; 2, 左中右布局(左边和右边盒子宽度固定，中间的盒子根据内容自适应)12345678910111213141516171819202122232425.box&#123; display: flex; width: 1000px; margin: 0 auto; height: 400px; background: #ccc; padding: 20px;&#125;.box .item&#123;margin-left: 20px;background:red;border: 1px solid green;&#125;.box li:nth-child(1)&#123; width:200px; margin-left:0; background:yellow;&#125; .box li:nth-child(2)&#123; flex:1; overflow: hidden; &#125;.box li:nth-last-child(1)&#123; width:200px;&#125; demo3，子元素这行问题demo 属性划分针对容器(父盒子的属性) 大致有六个，如下：1，flex-direction:row（-&gt;) | row-reverse(&lt;-) | column (向上)| column-reverse（向下）; 项目排列的方向2，flex-wrap : nowrap（默认不换行） | wrap （换行，第一行在上面）| wrap-revers （换行，第一行在下面） ; 换行问题3，flex-flow :属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap;flex-direction || flex-wrap;4，justify-content:flex-start(左) | flex-end(右) | center(居中) | space-between(两端对齐)| space-around(项目两侧的间隔相等); 项目在主轴上(水平方向)的对齐方式。5，align-items : flex-start(顶部) | flex-end(底部) | center(垂直居中) | baseline(第一行文字的基线对齐) | stretch(默认值如果项目未设置高度或设为auto，将占满整个容器的高度。); 垂直方向的对齐(容器的垂直反方向的对齐)6，align-content : flex-start | flex-end | center | space-between(与交叉轴两端对齐，轴线之间的间隔平均分布。) | space-around(每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。)| stretch; 针对子元素的（item)1,order : 通过 值得大小改变子元素在文档流里的位置。(值： 1，2，3 数值来表示)2,flex-grow : 义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 默认值 0 ；3,flex-shrink :同上相反，缩小比例。如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。4,flex-basis : 子元素占据固定的空间。5,flex : 属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。6,align-self :auto | flex-start | flex-end | center | baseline | stretch; 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 具体使用参考文章具体使用参考","categories":[],"tags":[{"name":"css 基础","slug":"css-基础","permalink":"http://yoursite.com/tags/css-基础/"}]},{"title":"数组去重","slug":"数组去重","date":"2017-09-20T11:05:16.000Z","updated":"2019-02-23T03:55:04.559Z","comments":true,"path":"2017/09/20/数组去重/","link":"","permalink":"http://yoursite.com/2017/09/20/数组去重/","excerpt":"","text":"思路是，创建新数组，进行比较。demo参考文章1参考文章2","categories":[],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://yoursite.com/tags/js基础/"}]},{"title":"cookie操作","slug":"cookie操作","date":"2017-09-20T03:13:37.000Z","updated":"2019-02-23T03:55:04.549Z","comments":true,"path":"2017/09/20/cookie操作/","link":"","permalink":"http://yoursite.com/2017/09/20/cookie操作/","excerpt":"","text":"cookie用法1，写入cookie123456789101112//创建和覆盖一个cookie docCookies.setItem(name, value[, end[, path[, domain[, secure]]]])docCookies.setItem('add_clicked'+ bookId,\"1\",Infinity,'/','travel.qunar.com');//参数： name(必填)指 要创建和覆盖的cookie的名字(string); value(必填)cookie 的值。//一下参数都是可选项。// end(Infinity) 期限值 最大是年龄秒数 一年为31536e3, 永不过期的cookie 为Infinity// path(/路径) 如果没有定义，默认为当前文档位置的路径。(string or null)。路径必须为绝对路径// domain(域名) 如果没有定义，默认为当前文档位置的路径的域名部分// secure cookie只会被https传输 (boolean或null)。 2， 获取一个cookie 的方法1docCookies.setItem(name); //如果cookie 不存在则返回null 3, 删除一个cookie1docCookies.removeItem(name); //删除一个cookie 4,检测是否存在某一个cookie1docCookies.hasItem(name) 5, 得到所有cookie的列表1docCookies.key(); //返回一个这个路径所有可读的cookie的数组。 不错的文章","categories":[],"tags":[{"name":"jq基础","slug":"jq基础","permalink":"http://yoursite.com/tags/jq基础/"}]},{"title":"Javascript回调函数的理解","slug":"回调函数理解","date":"2017-09-18T01:23:37.000Z","updated":"2019-02-23T03:55:04.555Z","comments":true,"path":"2017/09/18/回调函数理解/","link":"","permalink":"http://yoursite.com/2017/09/18/回调函数理解/","excerpt":"","text":"回调函数的定义：回调函数是：函数也可以作为参数传递给另外一个函数，这个作为参数的函数就是回调函数。123456789// 有名回调函数function add(num1,num2,callback)&#123; var sum = num1+num2; callback(sum)&#125;function print(sum)&#123; console.log(num);&#125;add(1,3,print) // 4 匿名回调函数1234567function add(num1,num2,callback)&#123; var sum = num1+num2; callback(sum);&#125;add(3,5,function(sum)&#123; console.log(sum);&#125;) //8 jQuery中大量的使用了回调函数123$('#btn').click(funcion()&#123; console.log('1234')&#125;) 回调函数的特征1， 不会立刻执行因为回调函数是作为参数传给另一个函数的。传递的只是函数定义并没有立即执行。回调函数在函调用函数数中也要通过()运算符调用才会执行。2，回调函数是个闭包 ，能访问其外层定义的变量3，执行前需要类型判断在执行回调函数前最好确认其是一个函数123456789function add(num1,num2,callback)&#123; var sum = num1+num2; if(typeof callback === 'function')&#123; callback(sum); &#125;&#125;add(3,4,function(sum)&#123; console.log('回调函数值')&#125;) 4, this的使用注意在回调函数调用时this的执行上下文并不是回调函数定义时的那个上下文，而是调用它的函数所在的上下文。123456789101112var obj = &#123; sum:0; add: function(num1+num2)&#123; this.sum = num1+num2; &#125;&#125;;function add(num1,num2,callback)&#123; callback(num1+num2);&#125;add(1,2,obj.add);console.log(obj.sum); //0console.log(window.sum); //3 上述代码调用回调函数的时候是在全局环境下，因此this指向的是window，所以sum的值是赋值给windows的。关于this执行上下文的问题可以通过apply方法解决。1234567891011121314var obj = &#123; sum: 0, add: function(num1, num2)&#123; this.sum = num1 + num2; &#125;&#125;;function add(num1, num2, callbackObj, callback)&#123; callback.apply(callbackObj, [ num1, num2 ]);&#125;;add(1,2, obj, obj.add);console.log(obj.sum); //=&gt;3console.log(window.sum); //=&gt;undefined 5,允许传递多个回调函数一个函数中可以传递多个回调函数，典型的例子如jQuery123456789101112131415161718function successCallback() &#123; // Do stuff before send​&#125;​function successCallback() &#123; // Do stuff if success message received​&#125;​​function completeCallback() &#123; // Do stuff upon completion​&#125;​function errorCallback() &#123; // Do stuff if error received​&#125;$.ajax(&#123; url: \"http://fiddle.jshell.net/favicon.png\", success: successCallback, complete: completeCallback, error: errorCallback&#125;); 回调函数的优点和使用场景优点 DRY，避免重复代码。可以将通用的逻辑抽象。加强代码可维护性。加强代码可读性。分离专职的函数。使用场景 异步编程。事件监听、处理。setTimeout、setInterval方法。通用功能，简化逻辑。","categories":[],"tags":[]},{"title":"定时器","slug":"定时器","date":"2017-09-17T13:52:12.000Z","updated":"2019-02-23T03:55:04.557Z","comments":true,"path":"2017/09/17/定时器/","link":"","permalink":"http://yoursite.com/2017/09/17/定时器/","excerpt":"","text":"定时器setTimeout: 设置一个定时器，在定时器到期后执行函数和代码1234//timeoutId 定时器的ID ;func: 延迟后执行的函数;delay: 延迟的时间（单位：毫秒），默认值为0var timeoutId = setTimeout(function()&#123; console.log(1)&#125;,300); 定时器是又返回值的，返回的结果是一个数字 代表第几个定时器window.clearTimeout()方法 取消延迟操作语法：1window.clearTimeout(timeoutId); setIntervalId 以固定的时间间隔重复调用一个函数或者代码段123 SetIntervalId = setInterval(function()&#123; console.log(4)&#125;,300) setTimeout()和 setIntervalId() 的区别setTimeout() 执行一次setIntervalId() 执行N次1234567891011121314151617181920212223242526272829// 死循环var t = true; setTimeout(function()&#123; console.log('fffjojfojwfow') t = false;&#125;, 1000); //t =true alert永远都不会执行，因为JS是单线程的，且定时器的回调将在等待当前正在执行的任务完成后才执行，而while(t) &#123;&#125;直接就进入了死循环一直占用线程，不给回调函数执行机会while(t)&#123;&#125;alert('end');// 题目二for (var i = 0; i &lt; 5; i++) &#123; setTimeout(function () &#123; console.log(i); //5 &#125;, 0);&#125; // 题目三var obj = &#123; msg: 'obj', shout: function () &#123; alert(this.msg); &#125;, waitAndShout: function() &#123; setTimeout(function () &#123; this.shout(); &#125;, 0); &#125;&#125;;obj.waitAndShout(); // 报错，window没有定义shout() 方法 setTimeout有最小时间间隔限制，HTML5标准为4ms，小于4ms按照4ms处理，但是每个浏览器实现的最小间隔都不同 window.clearInterval()方法 取消掉用setInterval设置的重复执行动作语法：1clearInterval(intervalID) ID是个整数,是由setInterval()返回的. 使用场景 使用递归的方法让setTimeout 实现一个和setInterval 一样的功能 123456789 var count = 10; var timer = null; function move()&#123; window.clearTimeout(timer) count++; console.log(count); timer = window.setTimeout(move,1000)&#125;move()","categories":[],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://yoursite.com/tags/js基础/"}]},{"title":"函数(function)","slug":"函数-function","date":"2017-09-17T08:30:36.000Z","updated":"2019-02-23T03:55:04.553Z","comments":true,"path":"2017/09/17/函数-function/","link":"","permalink":"http://yoursite.com/2017/09/17/函数-function/","excerpt":"","text":"函数：是一段JavaScript代码，它只定义一次，但是可以被执行和多次调用。（具备某个功能的一个方法）函数本身是没有什么意义的，只有执行这个函数就实现对应的功能才能体现自己的价值 ECMAScript规定的函数声明方式有三种：1&gt;普通函数声明：12345678function sum(num1,num2)&#123; return num1+num2;&#125;2&gt; 使用表达式方式来：使用变量初始化发生声明函数```javascriptvar sum = function(num1,num2)&#123; return num1+num2&#125; 3&gt; 使用Function构造函数声明1234567891011121314151617181920var sum = new Function('num1','num2','num1+num2')### 一，函数有两部分组成的：创建一个函数，执行一个函数1，创建一个函数 ：首先开辟一个新的内存空间，浏览器为其分配一个十六进制的地址，我们假设地址为：xxxfff000,其次是把函数中的JS代码 当做“字符串”存储到内存空间，然后把这个地址赋值给当前函数名(即：sum = xxxfff00)```javascript // 创建一个函数 function 方法名()&#123; // 函数体：存储某个功能的代码 &#125; 方法名() // 执行函数 function sum()&#123; var total = null; total = 1+1; &#125; sum //sum 不加小括号代表：函数体本身 输出函数本身的代码。 sum(); // 把函数执行的结果输出 sum(); sum();// 执行函数 ，函数可以多次执行，一般情况下每一次执行函数和上一次没有任何关系 二， 函数执行的目的： 把函数之前存储的那些字符串变成js 代码，然后再让js代码从上到下依次的执行分三步执行：1&gt; 当函数执行的时候，首先会提供一个供函数体中代码执行的环境 -&gt; ‘私有作用域&gt; 2&gt;: 把函数体中的代码字符串变为代码从上到下执行。闭包机制：函数执行的时候，首先会形成一个新的私有作用域，供函数体中的代码从上到下执行，形成的那个私有的作用域把我们函数体中的代码包裹起来，保护了里面变量的私有变量 不收外界的干扰(外面获取不到也修改不了) 我们把函数执行的时候形成的这种保护机制就叫做“闭包”。 三,函数的四要素1，关键字 function2, 函数名称标识符(函数名)3,一对圆括号 （） 传参数使用4, 一对{} 函数执行的语句，即函数体5,自执行原理：在一个表达式后面加上括号()，该表达式会立即执行。123var tensquare = (function(x)&#123; return x*x;&#125;(10)); 四,函数的参数有形参和实参1，形参和实参的区别：形参是在函数定义时所写的参数，相当于函数中定义的变量。实参是在调用的函数时传入的参数123456// a, b 是形参 function add(a,b)&#123; return a+b; &#125; // 2,5 是实参 add(2,5); 五，函数内部的属性： arguments和this 两个对象。1，函数中argunments: 函数天生自带的（不管写没写形参，也不管是否传递值，arguments始终存在），用来接收函数传递进来的参数值得一个集合。观察他的结构发现，它是以数字作为索引，索引从零开始逐级递增，索引0储存的就是第一个参数的值，索引1，存储的是第二个参数值，索引N存储的是N+1个参数值。。。。。有一个叫做length的属性，这个属性是动态的判断一共传递了多少个参数。和数组的形式一样，，但不叫数组，叫类数组。类数组有自己特殊的属性callee 属性代表的是： 函数本身1,任意数的求和：1234567891011121314 function sum()&#123; var total = null; for(var i = 0; i&lt;argumnents.length;i++)&#123; cur = Number(arguments[i]) //把传进来的参数转化成数字类型的。 if(!isNaN(cur))&#123; total += cur &#125; &#125; return tatal &#125;console.log(sum(100,300,500,200)) //1000console.log(sum()) // nullconsole.log(sum(100,200,'400') //300400console.log(sum(100,200,'400','JavaScript') //NaN 2，this 对象this引用的是函数据以执行操作的对象，或者说函数调用语句所处的那个作用域。当在全局作用域中调用函数时，this对象引用的就是window(window是一个对象，是JavaScript中最大的对象，是最外围的对象)。 六， return 作用： 返回值的，终止函数体中的代码1.返回值作用：12345678910111213function sum(sum1,sum2)&#123; var total = null; total = num1+num2; return total ;//出口 return 就是当前函数提供给我们的出口，因为不提供出口的话，闭包的机制导致了在 // 函数体内的变量total，外面无法获取到里面的total的值，如果想在外面用total的值，必须通过return把total的值返回给外面即可---&gt;返回值机制 // 但并不是把变量返回给外面，而是把变量存储的值返回给外面 即：return total==&gt;return 200;&#125;console.log(sum(100,100)) //入口var total = sum(100,200) // 这句话含义是： 先把sum函数执行，然后把sum 函数执行的结果的返回值，赋值给变量total。(查看sum执行的结果，只需要看sum中是否存在return. 有return 的话,return 后面返回的值是什么，函数的结果就是什么值，；如果没有return，那么默认的返回值是 undefined)console.log(total) //报错， total is not defined 即total这变量没有定义//原因是，函数在执行的时候，首先形成一个私有的作用域，保护里面的内容不受外界干扰(闭包的机制)，导致了在函数体中定义的变量total,在函数体的外面不能直接获取到。 2， 终止函数的作用1234567function sum(num1,num2)&#123; var total = null total = num1+num2; return ; // 后面没有内容的话，就是终止函数体内的代码，return 下面的的代码都不会执行 console.log(total) //永远不会执行&#125;sum(200,400) 七，匿名函数 Js 中常用到的的两种方式1， 自执行函数：定义函数和执行函数一起完成。12345678;(function(num)&#123; console.log(num)&#125;)(100);// 其他形式 都是自执行函数。+function(num)&#123;console.log(num)&#125;(100);-function(num)&#123;console.log(num)&#125;(100);!function(num)&#123;console.log(num)&#125;(100);~function(num)&#123;console.log(num)&#125;(100); 2， 用作函数表达式 ：即把函数定义的部分当做一个值赋值给一个变量或者元素的某个行为123oDiv.onclick = function()&#123; ....&#125; 八,函数表达式： 12345678 //匿名函数表达式var square = function(x)&#123; return x*x;&#125;// 具名函数表达式var f = function fact(x)&#123;rentur x*x;&#125;// 函数表达式还可以作为参数传给其他函数data.sort(function(a,b)&#123;return a-b&#125;); 函数声明提升(函数的提升高变量提升)函数声明定义：如果function foo(){}被包含在一个函数体内，或者位于程序的最顶部的话，那它就是一个函数声明。1234function foo()&#123;&#125; //声明函数(function()&#123; function bar()&#123;&#125;&#125;)(); // 声明在函数体内的一部分 函数提升 1234567891011121314151617181920212223242526272829303132333435363738394041function hoistFunction()&#123; foo(); //I am hoisted function foo()&#123; console.log('I am hoisted') &#125;&#125;hoistFunction(); //编译后的代码function hoistFunction()&#123; function foo()&#123; console.log('I am hoisted') &#125; foo(); // //I am hoisted&#125;// 同一个作用域中存在多个同名函数声明，后面出现的将会覆盖前面的函数声明：function hoistFunction()&#123; function foo()&#123; console.log(1) &#125; foo(); // 2 function foo()&#123; console.log(2) &#125;&#125;// 函数声明和表达式遇到时，的结果function hoistFunction() &#123; foo(); // 2 // 函数表达式： var foo = function() &#123; console.log(1); &#125;; foo(); // 1 //函数声明 function foo() &#123; console.log(2); &#125; foo(); // 1&#125;hoistFunction();//函数声明的优先级最高，会被提升至当前作用域最顶端，所以第一次调用时实际执行了下面定义的函数声明，//然后第二次调用时，由于前面的函数表达式与之前的函数声明同名,所以foo赋值的函数表达式覆盖了同名函数声明。 九, 函数的四种调用方式,每种方式的不同方式在于 this 的初始化。JS 中的this代表得是当前行为执行的主体;js 中的context 代表的是当前行为执行的环境；this 是谁和函数在哪到哪定义的和在哪执行的都没关系；如何区分this?1&gt; 函数执行： 首先看函数名前面有没有“.” 有的话“.” 前面是谁this就是谁；没有“.” this指的是window。1234567891011121314151617function fn()&#123; console.log(this)&#125;var obj = &#123;fn:fn&#125;;fn() //windowobj.fn() //objfunction sum()&#123; fn(); //window&#125;sum();var oo = &#123; sum:function()&#123; //this指 oo fn()// fn 里面的this指window &#125;&#125; 2&gt;自执行函数里面的this永远指向window3&gt; 给元素的某一个事件绑定方法，当事件触发的时候,执行对应的方法，方法中的this是当前的元素12345678910111213141516document.getElementById('div1').onclick = fn //fn 中的this 是#div document.getElementById('div1').onclick = function()&#123; //this 指的是div1 fn() // fn里面的this 指的是window&#125;4&gt; 在构造函数模式中，类中（函数体中）出现的this.xxx=xxx 中的this是当前类的一个实例。``` 1, 作为函数```javascript function myFunction(a,b)&#123; return a*b ; &#125; myFunction(10,2) //20 this指向window //以上函数不属于任何对象。但是在 JavaScript 中它始终是默认的全局对象。 2，作为方法123456789//函数作为对象方法调用，会使得 this 的值成为对象本身。var myObect = &#123; firstName =\"xu\", lastName = \"lili\", fullName: function () &#123; return this.firstName + \" \" + this.lastName; &#125;&#125;myObect.fullName(); // xu lili this指 myObect 3，作为构造函数12345678//如果函数调用前使用了 new 关键字, 则是调用了构造函数。function myFunction(arg1, arg2) &#123; this.firstName = arg1; this.lastName = arg2;&#125;// 创建新对象var x = new myFunction(\"John\",\"Doe\");x.firstName; //返回 John this指myFunction() 4，通过他们的call()和apply() 方法间接调用作为函数方法调用函数在 JavaScript 中, 函数是对象。JavaScript 函数有它的属性和方法。call() 和 apply() 是预定义的函数方法。 两个方法可用于调用函数，两个方法的第一个参数必须是对象本身。12345678910function myFunction(a, b) &#123; return a * b;&#125;myObject = myFunction.call(myObject, 10, 2); // 返回 20function myFunction(a, b) &#123; return a * b;&#125;myArray = [10, 2];myObject = myFunction.apply(myObject, myArray); // 返回 20 两个方法都使用了对象本身作为第一个参数。 两者的区别在于第二个参数： apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，而call则作为call的参数传入（从第二个参数开始）。在 JavaScript 严格模式(strict mode)下, 在调用函数时第一个参数会成为 this 的值， 即使该参数不是一个对象。在 JavaScript 非严格模式(non-strict mode)下, 如果第一个参数的值是 null 或 undefined, 它将使用全局对象替代 5，函数还可以作为值传给另外一个函数。函数也可以是值， 可以将函数赋值给一个变量，作为参数传给另外一个函数。123456789101112131415161718function box(sum,num)&#123; return sum+num;&#125;function sum(num)&#123; return num+10;&#125;var result = box(sum(10),10)console(\"result:\"+result) //30function box(sum,num)&#123; return sum(num);&#125;function sum(num)&#123; return num+10;&#125;var result=box(sum,10);console.log(result) //20 案例：假如一个对象数组，我们想根据某个对象对象属性进行排序，而传递给数组sort() 方法的比较函数要接受两个参数，既要比较的值。可是我们还需要一种方式来指明按照那个属性来排序。就可以定义一个函数，它接受一个属性名，然后根据这个属性名来创建一个比较函数。 123456789101112131415161718var data = [&#123;name:'lisi',age:28&#125;,&#123;name:\"wangwu\",age:56&#125;,&#123;name:\"zhangsan\",age:46&#125;] function createComparisonFunction(prototypeName)&#123; return function(object1,object2)&#123; var value1 = object1[prototypeName]; var value2 = object2[prototypeName]; if(value1&lt;value2)&#123; return -1; &#125;else if(value1&gt;value2)&#123; return 1; &#125;else&#123; return 0; &#125; &#125; &#125;var res1 = data.sort(createComparisonFunction('age'));var res2 = data.sort(createComparisonFunction(name));console.log(res1) // [&#123;name:'lisi',age:28&#125;,&#123;name:\"zhangsan\",age:46&#125;,&#123;name:\"wangwu\",age:56&#125;]console.log(res2) // [&#123;name:'lisi',age:28&#125;,&#123;name:\"zhangsan\",age:46&#125;,&#123;name:\"wangwu\",age:56&#125;] 十，函数属性和方法1&gt; javascript中的函数就是对象，因此函数也就有属性和方法，每个函数都包含两个属性:length和prototype.其中，length属性表示函数希望接受的命名参数的个数。1234function box (num1,num2)&#123; return num1+num2&#125;console.log(box.length) //2 2&gt; prototype 属性，它保存所有实例方法的真正所在也就是原型。prototype属性有两个方法： call()和apply() 每个函数都包含着两个非继承而来的方法，这两个方法的用途都在特定的作用域中调用函数，实际上等于设置函数体内this对象值1234567891011function box(num1,num2)&#123; return num1+num2&#125;function sayBox (num1,num2)&#123; return box.apply(this,[num1,num2]) // this指向window&#125;function sayBox2(num1,num2)&#123; return box.apply(this,arguments) &#125;console.log(sayBox(10,10)+'&lt;br/&gt;') //20console.log(sayBox2(10,10)) //20 (2)call()方法和apply()方法延伸call()方法和apply()方法相同，它们的区别仅仅在于接收参数的方式不同。对于call()方法而言，第一个参数是作用域，没有变化，变化的只是其余参数都是直接传递给函数的。1234567function box(num1,num2)&#123; return num1+num2&#125;function callBox(num1,num2)&#123; return box.call(this,num1,num2) //区别apply()&#125;console.log(callBox(10,10)) //20 (3) call()和apply()真正的作用是扩展函数懒以运行的作用域1234567891011var color = \"red\" ;var box = &#123; color:\"blue\"&#125;;function sayColor()&#123; return this.color;&#125;console.log(sayColor() +'&lt;br/&gt;'); // redconsole.log(sayColor.call(this)+'&lt;br /&gt;'); // redconsole.log(sayColor.call(window)+'&lt;br /&gt;'); //redconsole.log(sayColor.call(box)) //blue","categories":[],"tags":[{"name":"js 基础","slug":"js-基础","permalink":"http://yoursite.com/tags/js-基础/"}]},{"title":"css布局水平垂直居中","slug":"css布局水平垂直居中","date":"2017-09-16T06:29:16.000Z","updated":"2019-02-23T03:55:04.549Z","comments":true,"path":"2017/09/16/css布局水平垂直居中/","link":"","permalink":"http://yoursite.com/2017/09/16/css布局水平垂直居中/","excerpt":"","text":"水平居中行内元素方案一： 在块级父容器中让行内元素居中，只需使用 text-align: center;使用类型元素有： inline/inline-block/inline-table/flex 元素实现居中 块级元素1，固定宽的块级元素 margin: 0 auto;2，绝对定位实现水平居中1234567.ele&#123; position:absolute; width:100px; left:50%; top:50% margin:-50px 0 0 -50px;&#125; 不设置宽高3,CSS3的flex实现水平居中方法 不限定宽度 12345678910111213141516 // 是让mother 里的a2 在mother盒子里水平垂直居中 display: flex; align-items: center; justify-content: center;// mother 没有固定宽高的 下面相对定位是让mother的高度和mod1高度一致即高度100%； position:absolute; left:0; top:0; right:0; bottom:0;``` 4, position+transform 实现水平垂直居中![在线demo](/demos/2017/0917-4/vertical.html)里面的的第二个模块 ```css transform:translate(-50%,-50%); 是相对自身原来的位置发生位移的。类似 position:relative;5, 绝对定位和margin 1234567891011.content&#123;position:relative&#125; .content .box&#123;position:absolute;margin:auto;left:0;top:0;right:0;bottom:0&#125;","categories":[],"tags":[{"name":"css基础","slug":"css基础","permalink":"http://yoursite.com/tags/css基础/"}]},{"title":"css定位","slug":"定位","date":"2017-09-15T11:22:53.000Z","updated":"2019-02-23T03:55:04.556Z","comments":true,"path":"2017/09/15/定位/","link":"","permalink":"http://yoursite.com/2017/09/15/定位/","excerpt":"","text":"CSS定位方式 display属性和 position定义：display CSS属性指定用于元素的呈现框的类型。 没有继承详细文档在 HTML 中，默认的 display 属性取决于 HTML 规范所描述的行为或浏览器/用户的默认样式表。在 XML中，其默认值为 inline。1，每一个元素都有默认的display属性，使用值：block,inline和 inline-block ,table-cell.①：block 宽高可以自行设置，默认宽度由父容器决定，默认高度有内容决定。自己独占一行。②：inline 宽度和高度都有内容决定，与其他元素共占一行。③：inline-block 具有block 设置宽，高，也有inline 与其他元素共占一行的特性。④: table-cell 此属性指让标签元素以表格单元格的形式呈现，单元格有一些比较特殊的属性，可以设置元素的垂直居中等。2， display 的值为none时 可以关闭一个元素的显示；当你使用 none 所有的后代元素他们的显示也会被关闭。文档渲染的过程中就好像在文档树中这个元素不存在一样。 position属性 没有继承，适用于所有元素。1，元素在页面中的布局遵守一套文档流的方式，默认的定位属性值为static。设置：top, right, bottom,; left 和 z-index 属性无效。2，元素如果被定位了，那么它的top,left,bottom,right值就会生效,但如果同时设置了四个top,left,bottom,right值，那么就认left 和 top 的值。 一,position:relative （相对定位）1， 默认的效果图position:relative 基准线是相对于元素自身在普通文档流内的位置展示该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。position:relative未定义对 table-*-group, table-row, table-column, table-cell, table-caption 元素应用的效果。2, position:relative left:100px;bottom:100px 的效果图例子position:relative left:100px;bottom:100px 基准线是相对于元素自身在普通文档流内的位置向右移动100px,向上移动100px;隐藏在浏览器顶部100px;3, 二,absolute（绝对定位）设置了绝对定位之后，元素脱离文档流，其他的元素会调整位置来弥补它偏离后剩下的空隙。元素偏移是相对于是它最近的设置了定位属性（position值不为static）的元素。如果元素为块级元素（display属性值为block)，那么它的宽度也会由内容撑开。因为：默认文档流中块级元素，如果没有设置宽度属性，会自动填满整行。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。行内元素设置了绝对定位的话，行内元素就具有设置宽高的属性在线demo展示;绝对定位元素不占据空间。绝对定位元素相对于最近的非 static 祖先元素定位。当这样的祖先元素不存在时，则相对于根级容器定位。所以在工作中尽量不要直接用绝对定位，必须配合设置了（position值不为static）的属性一起使用。在线demo2 三， fixed(固定定位)也是绝对定位设置了固定定位之后，元素相对的偏移的参考是可视窗口（浏览器），即使页面滚动，元素仍然会在固定位置。元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。 四,sticky 粘性定位元素 position:sticky盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 table 时），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。position: sticky 对 table 元素的效果如demo在线demo 相关资料相关参考资料 relative 限制同源属性1,position:relative(相对定位) 和 position:absolute（绝对定位）的限制 例如：父盒子是position:relative，子盒子是position:absolute 那么子盒子的top,left,right,bottom,z-index 都以父盒子我基准移动。 在绝对定位里 z-index的值是越大越在上面。如果父盒子有相对定位则要看相对定位的 z-index 的值得大小，看是否在一个基准线上，然后在以 z-index的值是越大越在上面。2, 父盒子设置 overflow:hidden隐藏不了设置 position:absolute 的元素的。加相对定位就以相对元素的值剪切 尽量避免使用relative属性的原则","categories":[],"tags":[{"name":"css 基础","slug":"css-基础","permalink":"http://yoursite.com/tags/css-基础/"}]},{"title":"盒子模型","slug":"盒子模型","date":"2017-09-15T11:22:53.000Z","updated":"2019-02-23T03:55:04.560Z","comments":true,"path":"2017/09/15/盒子模型/","link":"","permalink":"http://yoursite.com/2017/09/15/盒子模型/","excerpt":"","text":"盒模型的概念（box model) 是css 中的一个重要概念。每一元素在网页中都是一个独立的盒子. 例如：图1; css3 中新增了一种盒子模型计算方式： box-sizing 属性1， 默认值是 content-box,新增的值是，padding-box 和 border-content 目前padding-box 暂不支持。123456789 .box&#123; width:100px; height:100px; box-sizing: content-box; border: 10px solid red; padding: 10px; margin: 20px auto; background:#ccc;&#125; 浏览器显示： 真实盒子模型： 2, box-sizing: border-content 123456789 .box&#123; width:100px; height:100px; box-sizing: border-content; border: 10px solid red; padding: 10px; margin: 20px auto; background:#ccc;&#125; 浏览器显示： 真实盒子模型： demo理解 盒子和盒子之间的垂直外边距叠加问题一，合并条件：两个或多个毗邻的(普通流)中的块元素垂直方向上的 margin 会折叠 1, 相邻元素叠加相邻的两个元素,(兄弟元素) 如果它们的上下边距相遇，即会产生叠加 （取比较大的值）; ; 2, 父子元素 父元素设置margin-top:20px； 子元素设置：margin-top:10px; ; 3, 空元素（即没有内容,内边距,边框)(本身发生叠加) ;二，解决方案 1,尽量使用padding来达到目的 2，在可能叠加的外边距之间添加透明边框或者内边距分开 3，给元素添加float 属性 4，绝对定位 5，在可能叠加的元素间添加空的块元素 注释：只有普通文档流中块框的垂直外边距才会发生外边距合并。行内框、浮动框或绝对定位之间的外边距不会合并。","categories":[],"tags":[{"name":"css 基础","slug":"css-基础","permalink":"http://yoursite.com/tags/css-基础/"}]},{"title":"Es6中对象","slug":"Es6中对象","date":"2017-09-08T13:54:15.000Z","updated":"2019-02-23T03:55:04.547Z","comments":true,"path":"2017/09/08/Es6中对象/","link":"","permalink":"http://yoursite.com/2017/09/08/Es6中对象/","excerpt":"","text":"对象赋值 Es允许把声明的变量直接赋值给对象。1234let name = \"lisi\";let skill = \"web\";var obj = &#123;name,skill&#125;;console.log(obj); //&#123;name: \"lisi\", skill: \"web\"&#125; 对象key值得构建有时候我们会在后台取出key 的值， 而不是我们前端定义好的，这时候我们如何构建我们的key值呢？比如我们在后台取出了一个key 值，然后可以用[] 数组的形式，进行对象的构建1234567let name = \"lisi\";// let skill = \"web\";let key = 'skill';objlet obj = &#123;name, [key]:'web'&#125;;console.log(obj.skill); // 'web' 自定义对象方法123456let obj =&#123; add:function(a,b)&#123; return a+b; &#125;&#125;console.log(obj.add(1,2)) 对象比较 Object.is()Es6 以前判断如下：123var obj1 = &#123;name:'lisi'&#125;;var obj2 =&#123;name:'lisi'&#125;;console.log(obj1.name===obj2.name) //true; ES6 提供的方法123var obj1 = &#123;name:'lisi'&#125;;var obj2 =&#123;name:'lisi'&#125;;console.log(Object.is(obj1.name,obj2.name)) //true 区分=== 和is () 的区别： === 为同值相等； is()为严格相等相关具体比较文章1234console.log(+0===-0);console.log(NaN === NaN);console.log(Object.is(-0,+0));console.log(Object.is(NaN,NaN)); Object.assign() 和并对象123456789var state =&#123; data:null, query:&#123; page:1, limit:20 &#125;&#125;let newState = Object.assign(&#123;&#125;,state);console.log(newState) //与一个空对象合并，也就复制了一份原来一模一样的新对象","categories":[],"tags":[]},{"title":"ES箭头函数","slug":"ES箭头函数","date":"2017-09-08T10:27:02.000Z","updated":"2019-02-23T03:55:04.547Z","comments":true,"path":"2017/09/08/ES箭头函数/","link":"","permalink":"http://yoursite.com/2017/09/08/ES箭头函数/","excerpt":"","text":"Es6 函数新增加了默认值1234function add(a,b=1)&#123; return a+b;&#125;console.log(add(2)) //3 1,获得需要传递的参数个数如果你在使用别人的框架时，不知道别人的函数需要传递几个参数怎么办？ES6为我们提供了得到参数的方法(xxx.length).我们用上边的代码看一下需要传递的参数个数。1234567function add(a,b)&#123; if(a ===0)&#123; throw new Error('this is error'); &#125; return a+b;&#125;console.log(add.length) 这时控制台打印出了2，但是如果我们去掉严谨模式，并给第二个参数加上默认值的话，这时候add.length的值就变成了1，也就是说它得到的是必须传入的参数。 箭头函数123456let f = v =&gt;v; //等同于 let = function(v)&#123;return v;&#125;//箭头函数支持的写法let f = () =&gt;s;let add =(a,b=1) =&gt; a+b;let add =(d,b)=&gt;&#123;return a+b&#125;console.log(add(1)); 使用箭头函数时需要注意以下几点：&lt; 函数体内的this对象，绑定定义时所在的对象，而不是使用时所在的对象（this指向window）&lt; 不可当作构造函数，也就是说不能使用new命令，否则会抛出错误&lt; 不可以使用arguments对象，因为该对象在函数体内不存在 {}的使用 箭头函数中不可加new，也就是说箭头函数不能当构造函数进行使用。对象的函数解构函数能解构JSON，那解构我们的数组就更不在话下了，我们看下边的代码。我们声明一个数组，然后写一个方法，最后用…进行解构赋值。12345678910111213141516171819let arr = ['lisi','前端','react'];function fun(a,b,c)&#123; console.log(a,b,c)&#125;fun(...arr)### in 的用法in 是用来判断对象或者数组中是否存在某个值的。对象判断```javascriptlet obj = &#123; a:'lisi', b:'前端开发'&#125;console.log('a' in obj) //返回true ### 数组判断//Es5 ```javascriptlet arr = [,,,,];console.log(arr.lenght); //5 数组中其实全是空值，这就是一个坑啊。那用ES6的in就可以解决这个问题 1234let arr =[,,,,,];console.log(0 in arr) // false 在这里的0 指的是数组下标位置是否为空ler arr = ['lisi','react'];console.log(0 in arr) // true 在这里的0 指的是数组下标位置是否为空 数组的遍历方法 forEach() //forEach循环的特点是会自动省略为空的数组元素，相当于直接给我们筛空了。当是有时候也会给我们帮倒忙。12let arr = ['1','2','name','sex','love'];arr.forEach((val,index)=&gt;console.log(index,val)); 2, filter12let arr = ['lisi','wangwu','react']arr.filter(x=&gt;console.log(x)); 3,some12345678let arr = ['lisi','name','love','web'];arr.some(x=&gt;console.log(x))// lisi name love webview4,map() map在这里起到一个替换的作用```javascriptlet arr = ['3','4','5','6'];console.log(arr.map(x=&gt;'web'));// ['web','web','web','web'] 数组转换字符串1,数组输出成字符串的形式123let arr =['react','css ','js','node',];console.log(arr.join('|')); //react| css| js | node//join()方法就是在数组元素中间，加了一些间隔，开发中很有用处。 2,toString()方法12let arr =['react','css ','js','node',];console.log(arr.toString()) //react,css,js,node","categories":[],"tags":[]},{"title":"面试题总结（四）","slug":"面试题总结（四）","date":"2017-09-07T14:37:19.000Z","updated":"2019-02-23T03:55:04.564Z","comments":true,"path":"2017/09/07/面试题总结（四）/","link":"","permalink":"http://yoursite.com/2017/09/07/面试题总结（四）/","excerpt":"","text":"对象判断属性是否存在例如：12345678if(!('a' in window))&#123; var a = 3;&#125;console.log(a) // undefined// 原因： var 声明一个变量是全局变量（window)。 //一般var ,function 声明变量后再运行前一般是先提声明后赋值。//先执行 var= undefined; 然后在执行if()// 而 ‘a' in window 是判断window里面是否有 a 这属性。返回的是布尔值（true/false) 如何检查JavaScript 变量类型？ 常见手段: typeof() , instanceof(), constructor,toSring如果你要判断的是基本数据类型 或是javaScript内置对象，使用tostring; 如果要判断的是自定义类型 请使用 instanceof 区分常见类型检查手段的区别：1,typeof 操作符返回的类型是字符串， 他的返回值有6种取值：12345678910typeof 3 //numbertypeof 'abc' // stringtypeof &#123;&#125; // objecttypeof true // booleantypeof undefined // undefinedtypeof function()&#123;&#125; // functiontypeof [] // object typeof null //object null是基本数据类型，它的类型显然是Null。其实这也/反映了null的语义，// 它是一个空指针表示对象为空，而undefined才表示什么都没有。 //总之，typeof只能用于基本数据类型检测，对于null还有Bug。 所有的对象的typeof 都是”object”, 不能用于检测用户自定义类型。 比如： Date RegExp, Array,DOM Eleemnt的类型都是”object“ 2,instanceof 操作符用于检查某个对象的原型链是否包含某个构造函数的prototype属性 例如：语法：123obj instanceof constructor// 参数 object 要检测的对象. constructor某个构造函数//instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。 instanceof 是通过原型链来检查类型的，所以只适用于任何”object”的类型检查 obj的原型链上有很多对象（成为隐式原型），比如：obj.proto, obj.proto.proto, …如果这些对象里存在一个p === Widget.prototype，那么instanceof结果为true，否则为false。例如：12345678//直接原型关系function Animal()&#123;&#125;;(new Animal) instanceof Animal // true//原型链上的间接原型 function Cat()&#123; Cat.prototype = new Animal; (new Animal) instanceof Animal &#125; instanceof也可以用来检测内置兑现，比如Array, RegExp, Object, Function：12345[1,2,3] instanceof Arraay //true[1, 2, 3] instanceof Array // true/abc/ instanceof RegExp // true(&#123;&#125;) instanceof Object // true(function()&#123;&#125;) instanceof Function // true instanceof对基本数据类型不起作用，因为基本数据类型没有原型链。 constructor 属性返回一个指向创建了该对象原型的函数引用。需要注意的是，该属性的值是那个函数本身。例如：123function Animal()&#123;&#125;var a = new Animala.constructor === Animal // true constructor不适合用来判断变量类型。首先因为它是一个属性，所以非常容易被伪造：123var a = new Animala.constructor === Arraya.constructor === Animal // false 另外constructor指向的是最初创建当前对象的函数，是原型链最上层的那个方法：12345678function Cat()&#123;&#125;Cat.prototype = new Animalfunction BadCat()&#123;&#125;BadCat.prototype = new Cat(new BadCat).constructor === Animal // trueAnimal.constructor === Function // true 与instanceof类似，constructor只能用于检测对象，对基本数据类型无能为力。 而且因为constructor是对象属性，在基本数据类型上调用会抛出TypeError异常： 3，toString()toString方法是最为可靠的类型检测手段，它会将当前对象转换为字符串并输出。 toString属性定义在Object.prototype上，因而所有对象都拥有toString方法。 但Array, Date等对象会重写从Object.prototype继承来的toString，所以最好用Object.prototype.toString来检测类型。123456789101112toString = Object.prototype.toString;toString.call(new Date); // [object Date]toString.call(new String); // [object String]toString.call(Math); // [object Math]toString.call(3); // [object Number]toString.call([]); // [object Array]toString.call(&#123;&#125;); // [object Object]// Since JavaScript 1.8.5toString.call(undefined); // [object Undefined]toString.call(null); toString也不是完美的，它无法检测用户自定义类型。 因为Object.prototype是不知道用户会创造什么类型的， 它只能检测ECMA标准中的那些内置类型。因为返回值是字符串，也避免了跨窗口问题。当然IE弹窗中还是有Bug，不必管它了。 现在多少人还在用IE？多少人还在用弹窗？和Object.prototype.toString类似地，Function.prototype.toString也有类似功能， 不过它的this只能是Function，其他类型（例如基本数据类型）都会抛出异常。 总结typeof只能检测基本数据类型，对于null还有Bug；instanceof适用于检测对象，它是基于原型链运作的；constructor指向的是最初创建者，而且容易伪造，不适合做类型判断；toString适用于ECMA内置JavaScript类型（包括基本数据类型和内置对象）的类型判断；基于引用判等的类型检查都有跨窗口问题，比如instanceof和constructor。总之，如果你要判断的是基本数据类型或JavaScript内置对象，使用toString； 如果要判断的时自定义类型，请使用instanceof。 有时Duck Typing的方式也非常可行，貌似已经成为了前端的惯例。 比如jQuery是这样判断一个Window的：123isWindow: function(obj)&#123; return obj &amp;&amp; typeof obj === 'object' &amp;&amp; \"setInterval\" in obj;&#125; 实现 ES6 里面的Array.isArray()代码实现123Array.isArray = function(arg)&#123; return Object.prototype.toString.call(arg) ==='[object Array]';&#125;","categories":[],"tags":[]},{"title":"ES6中新增的数组知识(三)","slug":"ES6笔记","date":"2017-09-06T13:37:07.000Z","updated":"2019-02-23T03:55:04.547Z","comments":true,"path":"2017/09/06/ES6笔记/","link":"","permalink":"http://yoursite.com/2017/09/06/ES6笔记/","excerpt":"","text":"ES6中新增的数组知识Array.from() 用于将类数组转化为真正的数组,还可以遍历set 和Map.1，JSON 数组的转换JSON 数组的格式写法：123456789101112// 标准的JSON数组格式，跟普通的JSON对比是在最后多了一个length属性let json = &#123; '0':'lisi', '1': \"前端妹子\", '2': '爱学习', length:3&#125;//轻松使用ES6的语法转变成数组 let arr = Array.from(json) //该函数可以方便地替代ES5中使用Array.prototype.slice来进行数组转换。 console.log(arr) //['lisi','前端妹子','爱学习']// ES5 的写法var arr1 =[].slice.call(json) 主要应用DOM 操作返回的NodeList 集合,以及函数内部的arguments 对象12345678let ps = document.querySelectorAll('p');let pArr = Array.from(ps);console.log(pArr)// arguments对象function foo() &#123; var args = Array.from(arguments); // ...&#125; 数组的遍历1,Array.of()方法：用来将一组值转换为数组1234let arr = Array.of(2,3,4,5,6);console.log(arr); //[2,3,4,5,6]let arr2 = Array.of('张三','lisi','wangwu');console.log(arr2) //['张三','lisi','wangwu'] 2,find( )实例查找 满足条件就停止查找新增数组实例方法：find()和findIndex()。两者的参数都是一个回调函数，返回第一个回调函数返回值为true的元素的值（或下标）。这两个函数解决了ES5中indexOf()函数不能找到NaN元素的问题。 必须有一个已经存在的数组，然后使用的方法， find方法是从数组中查找。在find方法中我们需要传入一个匿名函数，函数需要传入三个参数： value：表示当前查找的值。 index：表示当前查找的数组索引。 arr：表示当前数组。 123456789let arr = [2,3,4,5,6] ;console.log( arr.find(function(value,index,arr)&#123; return value&gt;3; &#125;)) //4let arr2 = ['张三','lisi','wangwu'];console.log(arr2.find(function(value,index,arr)&#123; return value == \"lisi\"; &#125;)) // lisi 3,新增数组实例方法：fill(),使用指定值对数组进行填充。参数为一个时将数组所有元素替换为参数的值，参数为三个时，将指定起始位置（第二个参数）和终止位置（第三个参数）替换为目标值（第一个参数） 包含起始值，但不包含终止值。123var arr = ['a','sds','gb','rf'];arr.fill('lisi',1,3)console.log(arr) 4,新增数组实例方法：ectries(),keys(),values(),三个都返回遍历器：123456789101112131415161718192021222324252627282930// 输出下标for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let elem of ['a', 'b'].entries()) &#123; console.log('index+'+val)&#125;//entries()实例方式生成的是Iterator形式的数组，那这种形式的好处就是可以让我们在需要时用next()手动跳转到下一个值。我们来看下面的代码：let arr = ['lisi','qunar','前端开发'];let list = arr.entries();console.log(list) //Array Iterator &#123;&#125; 就支持手动循环console.log(list.next().value); //[0,\"lisi\"]console.log(list.next().value);// [1,\"qunar\"]console.log(list.next().value); //[3,\"前端开发”]for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 \"a\"// 1 \"b\" 5,新增数组推导的写法，用于快捷地从当前数组生成指定数组（ES5中可以使用map()和filter()实现）：12345678910111213141516171819//ES5:var a1 = [1, 2, 3, 4];var a2 = a1.map(function(i)&#123;return i * 2&#125;);var a3 = a1.filter(function(i)&#123;return i &gt; 2&#125;);var a4 = a1.filter(function(i)&#123;return i &gt; 2&#125;) .map(function(i)&#123;return i * 2&#125;);a2 // [2, 4, 6, 8]a3 // [3, 4]a4 // [6,8]//ES6:var a1 = [1, 2, 3, 4];var a2 = [for (i of a1) i * 2];var a3 = [for (i of a1) if (i &gt; 2) i];var a4 = [for (i of a1) if (i &gt; 2) i * 2];//同时实现ES5中的map和filter a2 // [2, 4, 6, 8]a3 // [3, 4]a4 // [6,8] 6,for…of数组索引:有时候开发中是需要数组的索引的，那我们可以使用下面的代码输出数组索引。`javascriptlet arr = [‘lisi’,’fddsf’,’dfgfkfg’];for(let index of arr.keys()){ console.log(index+’:’+val)}","categories":[],"tags":[]},{"title":"ES6笔记(一)","slug":"ES6笔记(一)","date":"2017-09-06T12:18:16.000Z","updated":"2019-02-23T03:55:04.546Z","comments":true,"path":"2017/09/06/ES6笔记(一)/","link":"","permalink":"http://yoursite.com/2017/09/06/ES6笔记(一)/","excerpt":"","text":"新增块级作用域（let与const关键字）1， 新增了声明块级使用域变量的关键字let。与var相比，使用let声明的变量有如下特点：let ：声明的变量所在作用域为块级，变量不存在变量提升 ，不允许重复声明否则会报错。代码块： {} 包起来的代码，形成了一个作用域，就是块级作用域。 比如： if, for, while1234567891011//es5 实现方式(function()&#123; for (var i = 0;i &lt; 10;i++)&#123; console.log(i) &#125;&#125;)();// Es6 实现方式 for(let i=0;i&lt;10;i++)&#123; console.log(i) &#125; 需要注意的是，ES6中函数本身的作用域在其块级作用域(就是匿名函数自执行)之类（相当于使用let声明了），这样，在if条件内声明的函数就不会像ES5因函数提升而总会被声明。2，const 一旦赋值，再也修改不了。声明时一定要初始化值。同样不能重复定义，用途是：防止意外修改变量。 全局对象属性 全局对象是最顶层的对象，在浏览器环境指的是window对象，在Node.js指的是global对象。ES5规定，所有全局变量都是全局对象的属性。 ES6规定，var命令和function命令声明的全局变量，属于全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。 变量的解构赋值1，数组形式解构赋值1234let [a,b,c] =[1,2,3];// 就等于 let a= 1,b=2,c =3// 数组可以设置默认值 undefined 和null 的区别：let[a,b='lisi'] =['李四',undefined] ;let[c,d='wangwu'] =['王五',null] ; 2,对象形式的解构赋值123456789101112let &#123;bar, foo&#125; = &#123;foo:'aaa', bar = 'bbb'&#125;;console.log(foo) //aaaaconsole.log(bar) //bbb// 方式二：let &#123;first: f, last: l&#125; = &#123;first: \"hello\", last: \"world\"&#125;;console.log(f)console.log(l)// 如果是先定义后赋值的话 需要在赋值的时候需要添加();let foo;&#123;foo&#125; = &#123;foo:\"aaa\"&#125;;console.log(foo) // 这样的话在编译的时候就会报错的， 解决方案就是在(&#123;foo&#125;=&#123;foo:\"aaa\"&#125;) // aaa 就能编译好了。 字符串解构12345678const [a,b,c,d,e,f] = &quot;shuais&quot;//a = s,//b = h,//c = u,//d = a,//e = i,//f = s; 对象扩展运算符（…）：1，传多个参数例如：1234567891011function jspang(...arg)&#123; console.log(arg[0]); console.log(arg[1]); console.log(arg[2]); console.log(arg[3]);&#125;jspang(1,2,3);//这时我们看到控制台输出了 1,2,3，undefined，这说明是可以传入多个值，//并且就算方法中引用多了也不会报错。//给筛选组件 传需要的所有参数 （month，days...)&lt;FilterTab &#123;...pageInfo.query&#125; /&gt; 2, 解决问题123456let arr1 = ['www','qunar','com'] let arr2 = arr1 console.log(arr2) arr2.push('lisi') console.log(arr1) //console.log(arr2) arr1 的值也被改变了 这一问题 我们利用对象的扩展运算符来解决123456let arr1 = ['www','qunar','com'] let arr2 = [...arr1] console.log(arr2) arr2.push('lisi') console.log(arr1) console.log(arr2) rest运算符 也是三个点, 看图理解1234567891011function sum(first,...arg)&#123; // ES5 输出方式 //for (var i = 0; i &lt; arg.length; i++) &#123; // console.log(i); // &#125; // es6 for(let val of arg)&#123; console.log(val); &#125;&#125;sum(1,2,3) 这时候控制台打印出了7，说明我们arg里有7个数组元素，这就是rest运算符的最简单用法。","categories":[],"tags":[]},{"title":"ES6笔记(二)","slug":"ES6笔记(二)","date":"2017-09-06T12:18:16.000Z","updated":"2019-02-23T03:55:04.546Z","comments":true,"path":"2017/09/06/ES6笔记(二)/","link":"","permalink":"http://yoursite.com/2017/09/06/ES6笔记(二)/","excerpt":"","text":"字符串模版1,es5 和es6 拼接对比12345let lisi='李四';let blog1 = '非常高兴你能看到这篇文章，我是你的老朋友'+lisi+'。我们一起学习字符串模版。';let blog2 = `非常高兴你能看到这篇文章，我是你的老朋友$&#123;lisi&#125;。我们一起学习字符串模版。`;console.log(blog1)console.log(blog2) 2,还支持运算符12345let a = 2;let b = 3;let result = `$&#123;a+b&#125;`;console.log(result)// 5 字符串查找※传统上JavaScript只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。1，查找是否存在ES6 直接用includes() 就可以判断布尔值(true/false)，不在返回索引值。123456789101112131415let lisi = \"李四\"let blog1 = `非常高兴你能看到这篇文章，我是你的老朋友$&#123;lisi&#125;。我们一起学习字符串模版。`;console.log(blog1.includes(lisi))// true//startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部.console.log(blog1.startsWith(lisi));//false//endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部.console.log(blog1.endsWith(lisi));//false//repeat()返回一个新字符串，表示将原字符串重复n次。可以方便地构建由重复字符或字符串构成的字符串：// 以| 结尾复制lisi 三遍console.log('lisi|'.repeat(3)) ES6数字操作ES6将ES5中的全局方法：isFinite(),isNaN(),parseInt(), parseFloat()移至Number上，分别变为Number.isFinite(),Number.isNaN(),Number.parseInt(), Number.parseFloat()。这样做是为了逐步减少全局方法，使语言逐步模块化。1，数字判断和转换 数字验证Number.isFinite( xx )12345let a= 11/4;console.log(Number.isFinite(a));//trueconsole.log(Number.isFinite('lisi'));//falseconsole.log(Number.isFinite(NaN));//falseconsole.log(Number.isFinite(undefined));//false 2,NaN验证NaN是特殊的非数字，可以使用Number.isNaN()来进行验证。下边的代码控制台返回了true。1console.log(Number.isNaN(NaN)) 判断是否为整数Number.isInteger(xx)12let a=123.1;console.log(Number.isInteger(a)); //false 4,整数转换Number.parseInt(xxx)和浮点型转换Number.parseFloat(xxx)123let a='9.18';console.log(Number.parseInt(a)); //9console.log(Number.parseFloat(a));//9.18 5,整数取值范围操作整数的操作是有一个取值范围的，它的取值范围就是2的53次方。12let a = Math.pow(2,53)-1;console.log(a); //9007199254740991 6.最大安全整数 和最小安全整数12console.log(Number.MAX_SAFE_INTEGER);console.log(Number.MIN_SAFE_INTEGER); 7, 安全整数判断isSafeInteger( )123let a= Math.pow(2,53)-1;console.log(Number.isSafeInteger(a));//false 8,Math对象新增的方法:12345678910111213141516Math.trunc(n) 去除一个数的小数部分Math.sign(b) 判断一个数是正数、负数还是0.Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine）Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine）Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent）Math.cbrt(x) 返回x的立方根Math.clz32(x) 返回x的32位二进制整数表示形式的前导0的个数Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine）Math.expm1(x) 返回eˆx - 1Math.fround(x) 返回x的单精度浮点数形式Math.hypot(...values) 返回所有参数的平方和的平方根Math.imul(x, y) 返回两个参数以32位整数形式相乘的结果Math.log1p(x) 返回1 + x的自然对数Math.log10(x) 返回以10为底的x的对数Math.log2(x) 返回以2为底的x的对数Math.tanh(x) 返回x的双曲正切（hyperbolic tangent)","categories":[],"tags":[]},{"title":"JSON的理解","slug":"JSON的理解","date":"2017-09-01T01:45:20.000Z","updated":"2019-02-23T03:55:04.548Z","comments":true,"path":"2017/09/01/JSON的理解/","link":"","permalink":"http://yoursite.com/2017/09/01/JSON的理解/","excerpt":"","text":"一，json 是什么？1，是一种轻量级数据交换的格式，是纯文本的字符串，是作为一种代替XML数据格式角色出现。简单易读方便转换跨平台。是JavaScript语言里的一个子集 json 的两种结构：1，是名称和值的集合 它被理解为对象（object），纪录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组 （associative array）。2，值的有序列表（An ordered list of values）。在大部分语言中，它被理解为数组（array）。 json的具体形式对象： {‘名称’：‘值’，‘名称’：‘值’}数组： 数组是值（value）的有序集合。一个数组以“[”（左中括号）开始，“]”（右中括号）结束。值之间使用“,”（逗号）分隔。[1,2,3,4,5,] JSON字面量又是什么?解析：123// javascript 对象字面量的写法var obj1 = new Object(); //创建一个对象var obj2 = &#123;&#125; //字面量 在看看下面的一段代码12345var person = &#123; 'name':'lisi', 'age':'24', 'sex': '男'&#125; 从上我们可以看出这就是用字面量表示一个对象，而这个格式就是json格式的， 因为本身json就是JavaScript语法集的一种，所以json字面量就是用json格式的JavaScript对象字面量。 与javasript 字面量对比json放到JavaScript中执行是合法代码，是JavaScript对象字面量，但是JavaScript对象字面量不一定是json1234567891011121314var person=&#123; \"name\":\"xianyu\", \"age\":24, \"love\":\"Online Game\"&#125;//和var person=&#123; name:'xianyu', age:24, love:'Online Game', skill:function()&#123; alert('basketball') &#125;&#125; 一， json必须是符合以下1.键一定要用双引号，值如果是字符串也要用双引号包括2.数据只包括，数字，布尔，数组，null，对象，字符串二，而JavaScript对象字面量属性不用引号也可以，而且值可以是任何类型，函数，undefined或者是正则都是可以的 。json只是JavaScript语法集中的一种，还有很多其他部分的东西都是不符合json的规范。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"面试总结（三)","slug":"面试总结（三)","date":"2017-08-31T07:55:45.000Z","updated":"2019-02-23T03:55:04.563Z","comments":true,"path":"2017/08/31/面试总结（三)/","link":"","permalink":"http://yoursite.com/2017/08/31/面试总结（三)/","excerpt":"","text":"一，阐述HTML的书写规范，书写css 的base (基础类型)+ common(普通类型)+custom(页面类)模式。HTML规范:1，严格使用xhtml书写规范。&emsp;属性值必须使用双引号括起来。&emsp;所有标签都必须合理嵌套。&emsp;不是标签一部分的特殊符号都用编码表示。2，所有标签和属性名称都必须小写。(包括自定义属性名)3，不使用属性简写：readonly4，标签的使用 遵循“标签语义化” 的原则，避免标签滥用。5，html要求结构清晰，结构层级扁平化处理6，合理使用id、class选择符&emsp;框架，全局，模块class使用连字符区别 “f-th ”“m-case”&emsp;id、class命名遵照骆驼命名法中小驼峰写法，命名要有意义，一目了然&emsp;标签如果有需要特殊说明、标注状态更换、class或id是简写等情况，应在该标签上方以注释的形式标注出完整意思（通用简写除外）7,a标签要求有 title 属性，一下情况除外： &emsp;1.导航a标签 &emsp;2.广告位，客户没有要求的a标签。 &emsp;3.图片或栏目标题 图片做“查看详情” &emsp;img标签需要添加alt属性，以说明这张图片内容，增加搜索引擎检索。 &emsp;前缀或后缀图标用i的背景图片构造 &emsp;禁止使用键盘空格。若必须使用空格，则使用” “ css 规范&emsp; 1，编码设置：采用 UTF-8 编码，在 CSS 代码头部使用：（注意，必须要定义在 CSS 文件所有字符的前面（包括编码注释），@charset 才会生效。）&emsp; 2，命名空间规范&emsp;&emsp; 布局：以 g 为命名空间，例如：.g-wrap 、.g-header、.g-content。&emsp;&emsp; 状态：以 s 为命名空间，表示动态的、具有交互性质的状态，例如：.s-current、s-selected。&emsp;&emsp; 工具：以 u 为命名空间，表示不耦合业务逻辑的、可复用的的工具，例如：u-clearfix、u-ellipsis。&emsp;&emsp; 组件：以 m 为命名空间，表示可复用、移植的组件模块，例如：m-slider、m-dropMenu。&emsp;&emsp; 钩子：以 j 为命名空间，表示特定给 JavaScript 调用的类名，例如：j-request、j-open。 二，let var 和const 的区别？已及 H =&gt;h(app)是什么意思？H =&gt;h(app)是:1234567// ES5 (function (h) &#123; return h(App); &#125;); // ES6 h =&gt; h(App); 1,在 js 函数中的var声明，其作用域是函数体的全部 1234567for(var i=0;i&lt;10;i++)&#123; var a = 'a';&#125;console.log(a);// a console.log(i) // i = 10;&lt;!-- 明明已经跳出 for 循环了，却还可以访问到 for 循环内定义的变量 a ，甚至连 i 都可以被放访问到 --&gt; 循环内变量过度共享 1234567for(var i= 0;i&lt;3;i++)&#123; setTimeout(function()&#123; console.log(i) &#125;,1000)&#125;//结果三次出来都是 3// 原因 ：循环本身及三次 timeout 回调均共享唯一的变量 i 。当循环结束执行时，i 的值为3。所以当第一个 timeout 执行时，调用的 i 当然也为 3 三，let 就是解决以上（二）里的两个问题产生的，是更完美的var .1，let 声明的变量拥有块级作用域。&emsp;也就是说用let声明的变量的作用域只是外层块，而不是整个外层函数。let 声明仍然保留了提升特性，但不会盲目提升，在示例一中，&emsp;通过将var替换为let可以快速修复问题，如果你处处使用let进行声明，就不会遇到类似的bug。2，let声明的全局变量不是全局对象的属性。&emsp;这就意味着，你不可以通过window.变量名的方式访问这些变量。&emsp;它们只存在于一个不可见的块的作用域中，这个块理论上是Web页面中运行的所有JS代码的外层块。3,形如for (let x…)的循环在每次迭代时都为x创建新的绑定。&emsp;这是一个非常微妙的区别，拿示例二来说，如果一个for (let…)循环执行多次并且循环保持了一个闭包，那么每个闭包将捕捉一个循环变量的不同值作为副本，而不是所有闭包都捕捉循环变量的同一个值。&emsp;所以示例二中，也以通过将var替换为let修复bug。&emsp;这种情况适用于现有的三种循环方式：for-of、for-in、以及传统的用分号分隔的类C循环。4 ，用let重定义变量会抛出一个语法错误123let a = \"a\";let a = \"b\";console.log(a) // 报语法错误SyntaxError 四 constconst 就是用来定义常量的， 任何的修改都是非法的。比如： &lt;!-- 只定义不赋值 --&gt; const a ; // 重复赋值 const a = 'a'; const a = 'b'; &lt;!-- 重新赋值 --&gt; const a = 'a'; a ='b'; Get 和 post 请求区别1，原理： 根据HTTP规范，GET用于信息获取 ，POST表示可能修改变服务器上的资源的请求（提交）MVC本来是存在于Desktop程序中的，M是指数据模型，V是指用户界面，C则是控制器。使用MVC的目的是将M和V的实现代码分离，从而使同一个程序可以使用不同的表现形式。 2，表面现像上面看看GET和POST的区别： ①，GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&amp;相连， 如：login.action?name=hyddd&amp;password=idontknow&amp;verify=%E4%BD%A0%E5%A5%BD。如果数据是英文字母/数字，原样发送 ，如果是空格，转换为+，如果是中文/其他字符， 则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII。 类似：https://user.qunar.com/login.jsp?ret=http%3A%2F%2Ftravel.qunar.com%2Ftravelbook%2Fnote%2Fcreate POST把提交的数据则放置在是HTTP包的包体中。 ② “GET方式提交的数据最多只能是1024字节，理论上POST没有限制，可传较大量的数据，IIS4中最大为80KB，IIS5中为100KB”？？！ ③ 在ASP中，服务端获取GET请求参数用Request.QueryString，获取POST请求参数用Request.Form。在JSP中，用request.getParameter(\\”XXXX\\”)来获取，虽然jsp中也有request.getQueryString()方法，但使用起来比较麻烦 ④ POST的安全性要比GET的安全性高 Get是向服务器发索取数据的一种请求，而Post是向服务器提交数据的一种请求，在FORM（表单）中，Method默认为”GET”，实质上，GET和POST只是发送机制不同","categories":[],"tags":[{"name":"面试总结","slug":"面试总结","permalink":"http://yoursite.com/tags/面试总结/"}]},{"title":"CDN的理解","slug":"CDN理解","date":"2017-08-27T01:45:37.000Z","updated":"2019-02-23T03:55:04.545Z","comments":true,"path":"2017/08/27/CDN理解/","link":"","permalink":"http://yoursite.com/2017/08/27/CDN理解/","excerpt":"","text":"CDN 的含义：内容分发网络和内容交付网络CDN的意图就是尽可能的减少资源在转发、传输、链路抖动等情况下顺利保障信息的连贯性。CDN就是扮演者护航者和加速者的角色，更快准狠的触发信息和触达每一个用户，带来更为极致的使用体验。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。类似分布各地的物流仓储网络，CDN网络可以将源站的内容缓存到分布全球的CDN节点，根据用户的访问IP，就近连接CDN，提高网站响应速度。 CDN 于前端优化的方案1，域名分片域名分片(Domain Sharding)技术可以突破浏览器对单一域名的最大连接数限制，有效的提高浏览器HTTP并发请求数。 插件加速第三方插件严重拖慢了网页显示？插件加速引擎能够异步或延时加载异常的插件,提高用户体验。 异步加载异步加载非必要的页面资源，加快首屏显示时间，提高用户体验。 资源内置 智能分析外链式JS和CSS资源的内容，将适合的资源嵌入到HTML页面中，减少访问时的请求数。 带宽压缩我们会帮您自动压缩传输的流量，为您节省带宽。 代码压缩去除HTML，JS，CSS内容中的非必须内容，减少资源大小，提高页面的加载速度。 DataURI智能引擎帮助页面内的静态资源URL自动改写到融合CDN网络，无需考虑动静分离即可享受实时加速和优化服务。","categories":[],"tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"http://yoursite.com/tags/计算机基础知识/"}]},{"title":"面试总结（二)","slug":"面试总结（二)","date":"2017-08-27T00:55:45.000Z","updated":"2019-02-23T03:55:04.563Z","comments":true,"path":"2017/08/27/面试总结（二)/","link":"","permalink":"http://yoursite.com/2017/08/27/面试总结（二)/","excerpt":"","text":"前端性能优化的方法（1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。 图片的延迟加载，数据的异步加载， 简单宣传页，尽量把js和css 写成内嵌式（2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存ajax请求结果，每次操作本地变量，不用请求，减少请求次数 （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。 （4） 当需要设置的样式很多时设置className而不是直接操作style。 （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。 （6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。 （7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。 什么叫优雅降级和渐进增强？优雅降级：web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效。渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 页面重构怎么操作？重构页面： 再不改面UI 页面的前提下，简化结构，添加可读性等优化，扩展的同时，还要网站前端保持一致的行为。具体体现： 表格(table)布局改为DIV+CSS 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) 对于移动平台的优化 针对于SEO进行优化 深层次的网站重构应该考虑的方面 减少代码间的耦合 让代码保持弹性 严格按规范编写代码 设计可扩展的API 代替旧有的框架、语言(如VB) 增强用户体验 通常来说对于速度的优化也包含在重构中 压缩JS、CSS、image等前端资源(通常是由服务器来解决) 程序的性能优化(如数据读写) 采用CDN来加速资源加载 对于JS DOM的优化 HTTP服务器的文件缓存","categories":[],"tags":[{"name":"面试总结","slug":"面试总结","permalink":"http://yoursite.com/tags/面试总结/"}]},{"title":"Express理解","slug":"Express理解","date":"2017-08-09T02:33:44.000Z","updated":"2019-02-23T03:55:04.547Z","comments":true,"path":"2017/08/09/Express理解/","link":"","permalink":"http://yoursite.com/2017/08/09/Express理解/","excerpt":"一，Express 快速创建程序框架的步Express快速生成框架的步骤","text":"一，Express 快速创建程序框架的步Express快速生成框架的步骤 二，Express 的理解及应用1，Express 是基于node.js平台web应用开发框架。主要用在后台数据的支持可以很快的搭建一整套网站的开发。2,以html5 离线缓存的为例:第一，用express 快速创建程序框架.├── app.js├── bin│ └── www├── package.json├── public│ ├── images│ ├── javascripts│ └── stylesheets│ └── style.css├── routes│ ├── index.js│ └── users.js└── views ├── error.hjs ├── index.hjs └── layout.hjs 然后在框架的views 创建 cookie.hjs 页面 在routes里的index.js 和users.js空间里添加路由(及页面的地址)例如 index.js为例：特别注意 设置了res.cookie(‘name’, ‘koby’, { domain: ‘.example.com’, path: ‘/admin’, secure: true });name: 类型为Stringvalue: 类型为String和Object，如果是Object会在cookie.serialize()之前自动调用JSON.stringify对其进行处理Option: 类型为对象，可使用的属性如下 domain：cookie在什么域名下有效，类型为String,。默认为网站域名 expires: cookie过期时间，类型为Date。如果没有设置或者设置为0，那么该cookie只在这个这个session有效，即关闭浏览器后，这个cookie会被浏览器删除。 httpOnly: 只能被web server访问，类型Boolean。 maxAge: 实现expires的功能，设置cookie过期的时间，类型为String，指明从现在开始，多少毫秒以后，cookie到期。 path: cookie在什么路径下有效，默认为’/‘，类型为String secure：只能被HTTPS使用，类型Boolean，默认为false signed:使用签名，类型Boolean，默认为false。express会使用req.secret来完成签名，需要cookie-parser配合使用 12345678910111213141516171819202122//后端设置cookie router.get('/storage', function(req, res, next) &#123; //基本设置 按需求设置需要的参数 在这里主要测试httpOnly 这参数的作用 res.cookie('name', 'koby', &#123;maxAge:90000000,httpOnly: true &#125;); res.render('cookie',&#123; title:'cookie',name:req.cookies.name &#125;);&#125;);//前端获取和设置等 //前提是必须先引用docCookies组件。具体的引用方式根据项目的打包工具而灵活引用$(function()&#123; $('#cookieGet').click(function(event) &#123; var name = docCookies.getItem('name'); console.log(name); var name = docCookies.setItem('name','lisi'); var name = docCookies.removeItem('name'); &#125;);&#125;)//但因为本案例是测试httpOnly的参数作用以上代码是无法获取到cookie值的。//httpOnly: true 只能后端更改和使用 前端是无法获取到的。//httpOnly: false 或是不设置这一参数。通过以上方式前端是可以获取到cookie值得。可以改变cookie。 localStorage和sessonStorage相关不错的文章localStorage：（1）特性： 域内安全、永久保存。即客户端或浏览器中来自同一域名的所有页面都可访问localStorage数据且数据除了删除否则永久保存，但客户端或浏览器之间的数据相互独立。（2）四个函数： A. localStorage.setItem 存储数据信息到本地 B. localStorage.getItem 读取本地存储的信息 C. localStorage.removeItem 删除本地存储的信息 D. localStorage.clear 清空所以存储的信息sessonStorage：（1）特性： 会话控制、短期保存。会话概念与服务器端的session概念相似，短期保存指窗口或浏览器或客户端关闭后自动消除数据。(理解为浏览关闭后再打开后为一个回话控制)（2）四个函数： A. sessionStorage.setItem 存储数据信息到本地 B. sessionStorage.getItem 读取本地存储的信息 C. sessionStorage.removeItem 删除本地存储的信息 D. sessionStorage.clear 清空所以存储的信息案例：12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&#123;&#123; title &#125;&#125;&lt;/title&gt; &lt;link rel='tylesheet' href='/stylesheets/style.css' /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&#123;&#123; title &#125;&#125;&lt;/h1&gt; &lt;p&gt;Welcome to &#123;&#123; title &#125;&#125;&lt;/p&gt; &#123;&#123;! http://blog.csdn.net/a727911438/article/details/54290931 &#125;&#125; &lt;div id=\"localStorageSet\"&gt;localStorageSet&lt;/div&gt; &lt;div id=\"localStorageGet\"&gt;localStorageGet&lt;/div&gt; &lt;div id=\"localStorageRemove\"&gt;localStorageRemove&lt;/div&gt; &lt;div id=\"localStorageClear\"&gt;localStorageClear&lt;/div&gt; &lt;div id=\"sessionStorageSet\"&gt;sessionStorageSet&lt;/div&gt; &lt;div id=\"sessionStorageGet\"&gt;sessionStorageGet&lt;/div&gt; &lt;div id=\"sessionStorageRemove\"&gt;sessionStorageRemove&lt;/div&gt; &lt;div id=\"sessionStorageClear\"&gt;sessionStorageClear&lt;/div&gt; &lt;div id=\"cookieSet\"&gt;cookieSet&lt;/div&gt; &lt;div id=\"cookieGet\"&gt;cookieGet&lt;/div&gt; &lt;script src=\"//cdn.bootcss.com/jquery/3.1.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"/javascripts/docCookies.js\"&gt;&lt;/script&gt; &lt;script src=\"/javascripts/cookie.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920$(function()&#123; $('#localStorageSet').click(function(event) &#123; localStorage.setItem('name','lisi'); &#125;); $('#localStorageGet').click(function(event) &#123; var get = localStorage.getItem('name'); alert(get); &#125;); $('#localStorageRemove').click(function(event) &#123; localStorage.removeItem('name'); &#125;); $('#localStorageClear').click(function(event) &#123; localStorage.clear(); &#125;); $('#cookieGet').click(function(event) &#123; var name = docCookies.getItem('name'); console.log(name); &#125;);&#125;)","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"原生ajax理解","slug":"原生ajax理解","date":"2017-08-04T06:50:38.000Z","updated":"2019-02-23T03:55:04.554Z","comments":true,"path":"2017/08/04/原生ajax理解/","link":"","permalink":"http://yoursite.com/2017/08/04/原生ajax理解/","excerpt":"AJAX : async javascript and xml 异步的js 和 xml客户端JS中的方法：用来向服务器端发送请求（还可以传递给服务器端数据）然后把服务器端返回的内容获取(Ajax 一般是运行在客户端的浏览器中的)xml: 可扩展的标记语言（在xml 文件中使用的标签都是自己扩展的）利用自己扩展的有规则的标记来存储相关的数据","text":"AJAX : async javascript and xml 异步的js 和 xml客户端JS中的方法：用来向服务器端发送请求（还可以传递给服务器端数据）然后把服务器端返回的内容获取(Ajax 一般是运行在客户端的浏览器中的)xml: 可扩展的标记语言（在xml 文件中使用的标签都是自己扩展的）利用自己扩展的有规则的标记来存储相关的数据 AJAX 原理AJAX通过原生的XMLHttpRequest对象发出HTTP请求，得到服务器返回的数据后，再进行处理。步骤：1，创建AJAX对象12//IE6一下不支持var xhr = new XMLHttpRequest; 2，发出http 请求1234567//发送前的基本信息配置// 配置请求的方式（get/post）// 打开一个URL 地址（配置向哪一个服务器地址发送请求// 同步还是异步：（true 代表异步，false 代表同步， 默认是true）//[username]:向服务器提供请求的用户//[userpass]:向服务器提供请求的用户密码 xhr.open(\"get\",\"/data.txt\",false，[username],[userpass]); 3，接受服务器传回的数据xhr.readyState：ajax 状态码 0,1,2,3,40:UNSENT当前的请求还没有发送1:OPEND URL 地址已经打开（发送前的参数配置已经完成）2: HEADERS_RECEIVED 响应头信息已经接受3:LOADING 主要返回的内容正在服务器端进行准备处理4:DONE 响应主体的内容已经成功返回到客户端12345xhr.onreadystatechange=function()&#123; if(xhr.readyState===4 &amp;&amp; /^2\\d&#123;2&#125;$/.test(xhr.status))&#123; var val = xhr.responseText; &#125;&#125; xhr.status : http网络状态码，描述了服务器响应内容的状态200 OR ^2\\d{2} (200或者以2开头的 ) 都代表响应主体的内容已经成功返回了301 : 永久重定向/ 永久转义302: 临时重定向/临时转移304： 本次获取的数据内容是读取缓存中的数据 400：客户端传递给服务器的参数出现错误401：无权限访问404：访问客户端的页面地址不存在500： 未知的服务器错误503： 服务器已经超负荷 4，发送请求：参数是请求主体中传递给服务器的内容1xhr.send(); AJAX可以是同步请求，也可以是异步请求。但是，大多数情况下，特指异步请求。因为同步的Ajax请求，对浏览器有“堵塞效应”。 一，XMLHttpRequest 对象 1，作用：XMLHttpRequest 对象用来在浏览器与服务器之间传送数据。例如：12345678var ajax = new XMLHttpRequest();ajax.open(\"get\",\"接口地址URL\",\"设置同步false和异步true\");//上面代码向指定的服务器网址，发出GET请求。//然后，AJAX指定回调函数，监听通信状态（readyState属性）的变化。ajax.onreadystatechange = handleStateChange;//一旦拿到服务器返回的数据，AJAX不会刷新整个网页，而是只更新相关部分，从而不打断用户正在做的事情。//虽然名字里面有XML，但是实际上，XMLHttpRequest可以报送各种数据，包括字符串和二进制，而且除了HTTP，它还支持通过其他协议传送（比如File和FTP 2, 典型用法ajax用法 二，XMLHttpRequest实例的属性2.1 readyState 是一个只读属性，用一个整数和对应的常量，表示XMLHttpRequest 请求当前所处的状态。 0，对应常量UNSENT，表示XMLHttpRequest实例已经生成，但是open()方法还没有被调用。 1，对应常量OPENED，表示send()方法还没有被调用，仍然可以使用setRequestHeader()，设定HTTP请求的头信息。 2，对应常量HEADERS_RECEIVED，表示send()方法已经执行，并且头信息和状态码已经收到。 3，对应常量LOADING，表示正在接收服务器传来的body部分的数据，如果responseType属性是text或者空字符串，responseText就会包含已经收到的部分信息。 4，对应常量DONE，表示服务器数据已经完全接收，或者本次接收已经失败了。在通信过程中，每当发生状态变化的时候，readyState属性的值就会发生改变。这个值每一次变化，都会触发readyStateChange事件。 2,2 onreadystatechangeonreadystatechange属性指向一个回调函数，当readystatechange事件发生的时候，这个回调函数就会调用，并且XMLHttpRequest实例的readyState属性也会发生变化。另外，如果使用abort()方法，终止XMLHttpRequest请求，onreadystatechange回调函数也会被调用。 只要状态改变，就触发方法执行123456789101112var xmlhttp = new XMLHttpRequest;xmlhttp.open( 'GET', 'http://example.com' , true );xmlhttp.onreadystatechange = function () &#123; if ( XMLHttpRequest.DONE != xmlhttp.readyState ) &#123; return; &#125; if ( 200 != xmlhttp.status ) &#123; return; &#125; console.log( xmlhttp.responseText );&#125;;xmlhttp.send(); 2.3 response 只读属性，返回接收到的数据（即body部分）他的类型有XMLHttpRequest.responseType 属性的值决定。如果本次请求没有成功或者数据不完整，该属性就会等于null。 2.4 responseType 类型1， ”“：字符串（默认值）2， “arraybuffer”：ArrayBuffer对象3， “blob”：Blob对象4 ，“document”：Document对象5， “json”：JSON对象6， “text”：字符串 2.5 responseTextresponseText属性返回从服务器接收到的字符串，该属性为只读。如果本次请求没有成功或者数据不完整，该属性就会等于null。responseText属性返回从服务器接收到的字符串，该属性为只读。如果本次请求没有成功或者数据不完整，该属性就会等于null。12var data = ajax.responseText;data = josn .parse(data); 2.6 responseXML responseXML属性返回从服务器接收到的Document对象，该属性为只读。如果本次请求没有成功，或者数据不完整，或者不能被解析为XML或HTML，该属性等于null。 2.7 status 属性表示请求所得到的HTTP状态码200, OK，访问正常301, Moved Permanently，永久移动302, Move temporarily，暂时移动304, Not Modified，未修改307, Temporary Redirect，暂时重定向401, Unauthorized，未授权403, Forbidden，禁止访问404, Not Found，未发现指定网址500, Internal Server Error，服务器发生错误基本上，只有2xx和304的状态码，表示服务器返回是正常状态。2.8 timeout 属性等于一个整数，表示多少毫秒后，如果请求仍然没有得到结果，就会自动终止。如果该属性等于0，就表示没有时间限制。1234567891011121314151617var xhr = new XMLHttpRequest(); xhr.ontimeout = function () &#123; console.error(\"The request for \" + url + \" timed out.\"); &#125;; xhr.onload = function() &#123; if (xhr.readyState === 4) &#123; if (xhr.status === 200) &#123; callback.apply(xhr, args); &#125; else &#123; console.error(xhr.statusText); &#125; &#125; &#125;; xhr.open(\"GET\", url, true); xhr.timeout = timeout; xhr.send(null);&#125; 2.9， 事件监听接口 onloadstart 请求发出onprogress 正在发送和加载数据onabort 请求被中止，比如用户调用了abort()方法onerror 请求失败onload 请求成功完成ontimeout 用户指定的时限到期，请求还未完成onloadend 请求完成，不管成果或失败 三 XMLHttpRequest实例的方法3.1 abort方法用来终止已经发出的HTTP请求。1234567ajax.open('GET', 'http://www.example.com/page.php', true);var ajaxAbortTimer = setTimeout(function() &#123; if (ajax) &#123; ajax.abort(); ajax = null; &#125;&#125;, 5000); 3.2 getAllResponseHeaders()getAllResponseHeaders方法返回服务器发来的所有HTTP头信息。格式为字符串，每个头信息之间使用CRLF分隔，如果没有受到服务器回应，该属性返回null。 3.3 getResponseHeader()getResponseHeader方法返回HTTP头信息指定字段的值，如果还没有收到服务器回应或者指定字段不存在，则该属性为null。 四， XMLHttpRequest实例的事件4.1 readyStateChange事件readyState属性的值发生改变，就会触发readyStateChange事件。 4.2 progress事件上传文件时，XMLHTTPRequest对象的upload属性有一个progress，会不断返回上传的进度。 4.3 load事件、error事件、abort事件 HTTP METHOD: 客户端向服务器端发送请求的方式以下请求方式不管哪一种都可以向服务器传递数据，也可以从服务器端获取到数据，而且本质意义上内有任何的区别GET: 一般应用于从服务器获取数据（给服务器的数据少，从服务器哪的数据少）12//使用gei发送请求给服务器传递内容一般使用\"URL 问号传参数的方式\" xhr.open(\"get\",\"/getList?num=12\") POST: 一般应用于向服务器推送数据123// 一般使用\"请求主体的方式\"传递给服务器xhr.open(\"post\",\"/getList\");xhr.send('&#123;\"name\":\"lisi\",\"age\":7&#125;'); PUT: 一般用于给服务器上增加资源文件（上传图片功能）DELETE： 一般应用于从服务器上删除资源HEAD: 一般只获取服务器的响应头信息 GET和POST 请求的区别：一，get 请求传递给服务器的内容存在大小限制,而post 理论上没有限制原因： get 通过URL 传参给服务器，而每个浏览器对于URL的长度存在限制，谷歌8kb,火狐7kb,IE2kb,如果URL的长度超过限制，浏览器会把超出的部分截取。二， 缓存问题get 请求会出先缓存（这个缓存不一定是304）， post 没有缓存。在项目中一般get请求不会让其出现缓存”清楚缓存”：URL 的末尾追加一个随机数// xhr.open(“get”,”/getList?num=12&amp;_=”+Math.random());三： 安全问题一般来说get不安全，而post相对安全一点。","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"面试总结(一)","slug":"面试总结(一)","date":"2017-08-03T09:26:59.000Z","updated":"2019-02-23T03:55:04.563Z","comments":true,"path":"2017/08/03/面试总结(一)/","link":"","permalink":"http://yoursite.com/2017/08/03/面试总结(一)/","excerpt":"","text":"复习一下基础1,document.write和innerHTML的区别document.write 只是重绘整个页面innerHTML 重绘页面的一部分。 2,浏览器检测通过什么？(1),navigator.userAgent(2),不同浏览器的特性，如：addEventListener. 3,javascript有哪几种数据类型？简单和复合两种简单： Number ,String,Null,Undefined, Boolean,复合：Object,Array,function 4,截取字符串 “abcdefghi” 的”fghi”;123var myvalue = \"abcdefghi\";var jiequ = myvalue.substring(myvalue.length-4,myvalue.length);console.log(jiequ) 5,运算一下结果1234567console.log(typeof(null)); //objectconsole.log(typeof(undefined)); //undefinedconsole.log(typeof(NaN)); //numberconsole.log(NaN==undefined); //falseconsole.log(NaN==NaN); //falsevar str ='23432';console.log(typeof(str++));//number 6,问执行完毕后x,y,z的值分别是多少？1234567891011var x = 1;y = z = 0;function add(n)&#123; n = n+1; //&#125;y = add(x);function add(n)&#123; n = n+3;&#125;z = add(x);console.log(x,y,z);执行完毕后的结果是：x =1; y和z 都等于 undefined,(原因是add方法没有返回值，默认是undefined) 7,阻止事件的冒泡1234function stopPP(e)&#123; var evt = e || window.event; var evt = stopPropagation?evt.stopPropation():(evt.cancelBubble=true);&#125; 8,页面导入样式时，使用 link 和import 引用样式的区别？1，link 属于XHTML标签，除了加载css 外，还能用于定义rss，定义rel 链接属性等作用。而import 是css提供的只能用于加载css.2,在页面加载时，link会同时被加载，而import 引用的css 则需要等到页面加载完毕后再加载。3，link 没有兼容问题，而import 是css2.1提出的。只在IE5以上的浏览器识别。 9，浏览器内核的理解 主要分成两部分： 1，渲染引擎： 主要负责取得页面的内容和样式。 2，js 引擎 ：解析和执行javascript 来实现网页的动态效果。 常见的内核： 1，Trident内核： IE，TT ,360,搜狗 2，Gecko内核： FF（火狐） 3，Webkit 内核： Safari 4, Chrome 使用的是Webkit 的分支 Blink 10,html5 有哪些新特性，移除了哪些元素？如何处理html5新标签的浏览器兼容问题？如何区分html和html5?新特性：图像，位置，储存，多任务等功能的增加例如：1，绘画：canvas ;2，用于媒介回放的 video 和audio 元素。3，本地离线存储 LocalStorage 长期存储数据，浏览器关闭后数据不丢失。sessionStorage 的数据在浏览器关闭后数据就会消失。4，语义化标签 内容标签：article ,footer ,header,nav ,section ;表单控件： calendar, date,time,email,url,search;5,新技术 webworker ,websocket Geolocation6,移除元素： 纯表现元素： basefont, big,center,font,s, strike,tt ,u 对可能性产生负面影响的元素： frame frameset noframes7,兼容问题：IE6~IE8支持通过document.createElement 方法产生的标签。可以利用这一特性让这些浏览器支持HTML5新标签。 支持新标签后需要添加默然的新标签样式。 比如使用成熟的框架html5shim; 8, 区分html5: DOCTYPE 声明\\新增的结构元素和功能元素 9, 新增的元素有： section ,video,progress,nav,meter, 当用户在自己的浏览器中输入一个网址，到最终看到页面和内容，发生了哪些事情？服务器的端口号：(0~65535) 一台服务器上可以发布很多的项目，而每一个项目都是一个自己对应的房间或者区域，服务器使用端口号来区分具体是哪一个项目 一般我们都把项目发布在80和443 URL/URI/URN一，URL 统一资源定位符一个完整的url : http://travel.qunar.com/travelbook/list.htm?page=1&amp;order=hot_heat&amp;month=1_2_3#bbshttp:传输协议travel.qunar.com:域名80:端口号travelbook/list.htm:请求资源文件名?page=1&amp;order=hot_heat&amp;month=1_2_3:URL问号传参–》客户端传递给服务器的内容(客户端可以把一些值传递给服务器，服务器端依然可以把一些内容传递个客户端) #bbs:URL的hash(锚点定位) URI=URL+URN 统一资源标识符(统一资源信息)URN:统一资源名称 传输协议HTTP :超文本传输协议，除了传输文本以外还可以传输其他的东西HTTPS: 更加安全的HTTPFTP:文本传输协议(应用于把项目源文件传递到服务器上)在不指定服务器端口的情况下，一般默认的端口号是：HTTP:80HTTPS:443FTP:21","categories":[],"tags":[{"name":"面试题（-）","slug":"面试题（-）","permalink":"http://yoursite.com/tags/面试题（-）/"}]},{"title":"Javascript编程同步和异步之区别","slug":"同步和异步之区别","date":"2017-07-30T14:38:17.000Z","updated":"2019-02-23T03:55:04.555Z","comments":true,"path":"2017/07/30/同步和异步之区别/","link":"","permalink":"http://yoursite.com/2017/07/30/同步和异步之区别/","excerpt":"","text":"javascript语言的执行环境是“单线程”单线程： 就是指一次只能完成一件任务。 如果有多个任务的话，就必须排队。前一个任务执行完后在执行后面的一个任务。 同步 (sync)同步：如果在函数A返回的时候，调用者就能够得到预期结果(即拿到了预期的返回值或者看到了预期的效果)，那么这个函数就是同步的。同步案例：123456789101112 while(1)&#123; // 这是一个死循环 &#125; console.log('ok') // 这句话永远都不会执行 Function fn1()&#123; Console.log(1234);&#125;Function fn2()&#123; Console.log(678);&#125;Fn1(); //第一个函数返回时，就拿到了预期的返回值：Fn2();//第二个函数返回时，就看到了预期的效果 异步(async) 每一个任务有一个或多个回调函数（callback）前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。异步：如果在函数A返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。常见的异步编程案例： 4》 在ajax 中可以使用异步编程 1》回调函数异步案例123456789101112131415161718function func1(cb)&#123; window.setTimeout(function()&#123; console.log('func111') cb(); &#125;,1000)&#125;function func2()&#123; console.log('func222')&#125;//保证先111后222func1(func2);/** 无法保证执行顺序func1()func2();*/ 上面的例子就阐明回调函数的原理，简单而言，就是把函数作为参数传给另外一个函数，在某一个任务执行完毕后在执行传进来的函数（传进来的是没有执行的函数，而不是函数执行后的值） 2》 定时器都是异步编程因为每个浏览器为定时器都有默认的最小时间。个各浏览器的最小值不一样123456var n =0;window.setTimeout(function()&#123; n++; console.log(n) //1&#125;,0)console.log(n) //0 我们设置的等待时间不一定是最后执行的时间，如果定时器之后还有其他的事情正在处理中，不管定时器的时间到没有到，都不会执行的。12345678910var n =0;window.setTimeout(function()&#123; n++; console.log(n) // b不会执行&#125;,0)console.log(n) //0while(1)&#123; n++&#125;console.log(n); // b不会执行 123456789101112var n = 0;window.setTimeout(function()&#123; n+=2; console.log(n); // 第四次&#125;,100);window.setTimeout(function()&#123; n+=5; console.log(n); // 第三次&#125;,50);console.log(n); //第一次for(var i=0;i&lt;10000;i++)&#123;&#125;;console.log(n) //第二次 当多个定时器，如果执行完成循环都到达时间了，先执行时间短的这种定时器 3》事件绑定都是异步编程12345for(var i=0;i&lt;oLis.length;i++)&#123; oLis[i].onclick = function()&#123; tabChange(i); &#125;&#125; 4》 ajax中的异步编程：AJAX中的同步：当ajax任务开始的时候（xhr.send) 一只需要到 ready sate ===4,任务才结束，此时才可以处理其他的事务。AJAX中的异步： 当ajax任务开始的时候（xhr.send) 不需要等到 ready sate ===4 依然可以做其他任务，并且当他其他任务做完后，判断一下是否到4，到达4 时做一些相关的操作。 12345678910111213141516171819202122232425262728293031323334353637383940// 异步案例：var xhr = new XMLHttpRequest;xhr.open(\"get\",\"/data.txt\",true);xhr.onreadystatechange=function()&#123; // 状态码改变 console.log(xhr.readyState)//2,3,4 &#125;xhr.send(null) //只有send()之后向服务器发送请求任务）才开始var xhr = new XMLHttpRequest;xhr.onreadystatechange=function()&#123; console.log(xhr.readyState)//1,2,3,4 &#125;xhr.open(\"get\",\"/data.txt\",true);xhr.send() //向服务器发送请求，任务开始var xhr = new XMLHttpRequest;xhr.open(\"get\",\"/data.txt\",true);xhr.send() //向服务器发送请求，任务开始xhr.onreadystatechange=function()&#123; console.log(xhr.readyState)//2,3,4 &#125;// 同步案例：var xhr = new XMLHttpRequest;xhr.open(\"get\",\"/data.txt\",false);xhr.onreadystatechange=function()&#123; console.log(xhr.readyState)//4 &#125;xhr.send(null) //var xhr = new XMLHttpRequest;xhr.open(\"get\",\"/data.txt\",false);xhr.send() //向服务器发送请求，任务开始// readystate===4了， 不会触发 onreadystatechangexhr.onreadystatechange=function()&#123; console.log(xhr.readyState)//没有任何输出 &#125; 二、事件监听 采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生还是以f1和f2为例。首先，为f1绑定一个事件（这里采用的jQuery的写法）。12345678function f1()&#123; setTimeout(function()&#123; console.log('1111'); //执行完f1 就触发done 事件 f1.trigger('done'); &#125;,1000);&#125;f1('done',f2) //当f1发生done事件，就执行f2 这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以”去耦合”（Decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。 三、Promises对象Promises对象是CommonJS工作组提出的一种规范，目的是为异步编程提供统一接口。简单说，它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。比如，f1的回调函数f2,可以写成： f1().then.f2(); function f1(){ var dfd = $.Deferred(); setTimeout(function(){ console.log('1111'); dfd.resolve(); },500); return dfd.promise; } 想想ajax调接口 的原理就明白了。","categories":[],"tags":[{"name":"前端开发","slug":"前端开发","permalink":"http://yoursite.com/tags/前端开发/"}]},{"title":"css3学习记录","slug":"css3学习记录","date":"2017-07-28T13:53:02.000Z","updated":"2019-02-23T03:55:04.549Z","comments":true,"path":"2017/07/28/css3学习记录/","link":"","permalink":"http://yoursite.com/2017/07/28/css3学习记录/","excerpt":"","text":"1, object-fitcss属性指的是：指定替换元素的内容应该如何适应到其使用的高度和宽度确定的框。语法： object-fit: fill(填写) || contain(包含) || cover(覆盖)|| none(没有) || scale-dowm(比例缩小) 等关键字来指定fill： 被替换的内容的大小，以填补该元素的内容框：对象的具体对象的大小是元素的使用宽度和高度。contain: 被替换的内容的大小，为自身宽高比不变，适应该元素的内容框的大小：它的具体对象的大小被解析为对元素的使用宽度和高度的含有约束。cover被替换的内容的尺寸却使元件的整个内容框，以保持其长宽比其具体的对象的大小被解析为针对元素的使用的宽度和高度的盖约束。none被替换的内容的尺寸却使元件的整个内容框，以保持其长宽比其具体的对象的大小被解析为针对元素的使用的宽度和高度的盖约束。scale-down内容的尺寸仿佛none或contain指定了，取将导致更小的具体对象的大小。 1,圆角12345.box_round&#123; -moz-border-radius: 30px; /* FF1+ */ -webkit-border-radius: 30px; /* Saf3+, Chrome */ border-radius: 30px; /* Opera 10.5, IE 9 */&#125; 2, 盒子阴影（box-shadow)12345-moz-box-shadow: 3px 3px 4px #ffffff; /* FF3.5+ */ -webkit-box-shadow: 3px 3px 4px #ffffff; /* Saf3.0+, Chrome */ box-shadow: 3px 3px 4px #ffffff; /* Opera 10.5, IE 9.0 */ filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=3px, OffY=3px, Color='#ffffff'); /* IE6,IE7 */ -ms-filter: \"progid:DXImageTransform.Microsoft.dropshadow(OffX=3px, OffY=3px, Color='#ffffff')\"; /* IE8 */ 四个值：含义分别为：x轴偏移值、y轴偏移值、阴影的模糊度、以及阴影颜色。IE 6~8使用其独有的滤镜，需要设置三个参数：offX（X轴偏移值）、offY（Y轴偏移值）、Color（阴影颜色）。 3, 线性渐变123456.box_gradient &#123; background-image: -moz-linear-gradient(top, #444444, #999999); /* FF3.6 */ background-image: -webkit-gradient(linear,left top, left bottom, color-stop(0, #444444),color-stop(1, #999999)); /* Saf4+, Chrome */ filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#444444', endColorstr='#999999', GradientType='0'); /* IE6,IE7 */ -ms-filter: \"progid:DXImageTransform.Microsoft.gradient(startColorstr='#444444', endColorstr='#999999',GradientType='0')\"; /* IE8 */&#125; 先看Firefox : -moz-linear-gradient(top, #444444, #999999);三个参数。第一个参数表示线性渐变的方向，top是从上到下、left是从左到右，如果定义成left top，那就是从左上角到右下角。第二个和第三个参数分别是起点颜色和终点颜色。你还可以在它们之间插入更多的参数，表示多种颜色的渐变。谷歌：-webkit-gradient(linear,left top, left bottom, color-stop(0, #444444),color-stop(1, #999999));-webkit-gradient是webkit引擎对渐变的实现，一共有五个参数。第一个参数表示渐变类型（type），可以是linear（线性渐变）或者radial（辐射渐变）。第二个参数和第三个参数，都是一对值，分别表示渐变起点和终点。这对值可以用坐标形式表示，也可以用关键值表示，比如left top（左上角）和left bottom（左下角）。第四个和第五个参数，分别是两个color-stop函数。color-stop函数接受两个参数，第一个表示渐变的位置，0为起点，0.5为中点，1为结束点；第二个表示该点的颜色。 四， 透明12345678.box_rgba &#123; background-color: #B4B490; background:transparent; filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#99B4B490',endColorstr='#99B4B490'); /* IE6,IE7 */ -ms-filter: \"progid:DXImageTransform.Microsoft.gradient(startColorstr='#99B4B490',endColorstr='#99B4B490')\"; /* IE8 */ zoom: 1; background-color: rgba(180, 180, 144, 0.6); /* FF3+, Saf3+, Opera 10.10+, Chrome */&#125; 除了IE，其他浏览器几乎都支持rgba函数。它有四个参数，前三个为一种颜色的RGB值，第四个为透明度，这里设为0.6。","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"Hogan.js了解和使用","slug":"Hogan的学习以及使用","date":"2017-07-10T06:49:31.000Z","updated":"2019-02-23T03:55:04.548Z","comments":true,"path":"2017/07/10/Hogan的学习以及使用/","link":"","permalink":"http://yoursite.com/2017/07/10/Hogan的学习以及使用/","excerpt":"","text":"Hogan 的定义hogan.js不错的网站mustache的语法 Mustache 的模板语法很简单，就那么几个，用于HTML，配置文件，源代码等。它的工作方式是(不错的外链)[http://wowubuntu.com/markdown/#blockquote]1234567&gt; * &#123;&#123;keyName&#125;&#125;&gt; * &#123;&#123;#keyName&#125;&#125; &#123;&#123;/keyName&#125;&#125;&gt; * &#123;&#123;^keyName&#125;&#125; &#123;&#123;/keyName&#125;&#125;&gt; * &#123;&#123;.&#125;&#125;//&gt; * &#123;&#123;&gt;partials&#125;&#125;&gt; * &#123;&#123;&#123;keyName&#125;&#125;&#125;&gt; * &#123;&#123;!comments&#125;&#125; 通过通过以哈希值或者对象的方式扩展模板标签。1234567891011121314 var data = &#123; \"company\": \"Apple\", \"address\": &#123; \"street\": \"1 Infinite Loop Cupertino&lt;/br&gt;\", \"city\": \"California \", \"state\": \"CA \", \"zip\": \"95014 \" &#125;, \"product\": [\"Macbook \",\"iPhone \",\"iPod \",\"iPad \"]&#125;//&#123;&#123;keyName&#125;&#125; 变量var tpl = '&lt;h1&gt;Hello &#123;&#123;company&#125;&#125;&lt;/h1&gt;';var html = Mustache.render(tpl, data);console.log( html )","categories":[],"tags":[]},{"title":"对象类型","slug":"算法题2","date":"2017-06-23T03:02:12.000Z","updated":"2019-02-23T03:55:04.561Z","comments":true,"path":"2017/06/23/算法题2/","link":"","permalink":"http://yoursite.com/2017/06/23/算法题2/","excerpt":"","text":"任务一： 根据名字取成绩已知学生成绩为哈希表stu_scores(键-&gt;学生姓名；值-&gt;学生成绩)根据学生的姓名数组stu_names，将学生成绩全部取出存入到scores数组中 //给数组scores添加数据scores.push(‘xxx’);遍历成绩数组scores，获取最高成绩，赋值给变量highest_score12345678910111213141516171819202122232425262728293031323334353637var stu_scores = &#123;'杨璐':131, '王雪':131, '韩林霖':127, '沙龙逸':123, '李鉴学':126, '韩雨萌':129, '刘帅':116, '康惠雯':114, '刘钰婷':115&#125;;var stu_names = ['杨璐', '王雪', '韩林霖', '沙龙逸', '李鉴学', '韩雨萌', '刘帅', '康惠雯', '刘钰婷'];var scores = [];//使用for循环取出成绩数组，打印所有成绩，找到做高分//获取所有学生的分数(只包含学生分数不包含学生姓名)存到scores中var highest_score = scores[0];//使用for循环找出学生成绩的最高分for (var i = 0; i &lt; stu_names.length; i++) &#123; var currentEle = stu_scores[stu_names[i]]; scores.push(currentEle); &#125;for (var i = 1; i &lt; scores.length; i++) &#123; if(highest_score&gt;scores[i])&#123; highest_score =highest_score; &#125;else&#123; highest_score = scores[i]; &#125;&#125; // console.log(scores);console.log('学生成绩的最高分:'+highest_score); 任务二 ：求最高分数已知存储10名学生的各科成绩的数组all_scores遍历all_scores获取到每个学生的各科成绩all_scores[i]遍历all_scores[i]获取到每个学生的每科成绩通过比较所有学生的所有成绩获取成绩的最高值，赋值给变量highest_score12345678910111213141516171819202122232425262728//10名同学的各科的成绩 请勿修改此句var all_scores = [[131,143,144], [131,135,144], [127,139,142], [123,148,136], [126,135,140], [129,133,138], [116,143,140], [114,142,139], [115,139,135], [116,142,129]];var highest_score = all_scores[0][0];//使用for循环求这10名学生中所有科目的最高分for (var i = 0; i &lt; all_scores.length; i++) &#123; var scores = all_scores[i]; for (var j = 0; j&lt; scores.length; j++) &#123; var arr_scores = scores[j]; console.log(arr_scores); if(highest_score&gt;arr_scores)&#123; highest_score =highest_score; &#125;else&#123; highest_score = arr_scores; &#125; &#125;&#125;// console.log(arr_scores)//打印这10名学生所有科目的最高分 console.log('这10名学生所有的最高分为：'+highest_score); 任务三： 给对象复值已知某班学生的语文成绩，展示为哈希表stu_scores根据部分学生姓名数组stu_names，获取这部分学生的成绩，以哈希表的形式存储（保存到变量stu_names_scores中），如： {‘刘帅’:116，’王雪’:120}123456789101112131415161718192021222324//某班学生的语文成绩var stu_scores = &#123;'杨璐':131, '王雪':131, '韩林霖':127, '沙龙逸':123, '李鉴学':126, '韩雨萌':129, '刘帅':116, '康惠雯':114, '刘钰婷':115&#125;;var stu_names = ['刘帅','康惠雯','沙龙逸','王雪','杨璐','李丽'];var stu_names_scores = &#123;&#125;;//获取数组stu_names中学生的成绩for (var i = 0; i &lt; stu_names.length; i++) &#123; //给对象复值 stu_names_scores[stu_names[i]] = stu_scores[stu_names[i]];&#125;//打印哈希数组stu_names_scores中学生成绩console.log('刘帅成绩：'+stu_names_scores['刘帅']);console.log('康惠雯成绩：'+stu_names_scores['康惠雯']);console.log('沙龙逸成绩：'+stu_names_scores['沙龙逸']);console.log('王雪成绩：'+stu_names_scores['王雪']);console.log('杨璐成绩：'+stu_names_scores['杨璐']); 任务四： 对象赋值案例二已知 三个变量存着数条的表情名字和图片地址，要求把三个变量合并成一变量并且转换成对象字面量的格式代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const faceDataList01 = [ &#123; title: '流口水', url: '//s.qunarzz.com/travel/bigface/1.png' &#125;, &#123; title: '膜拜', url: '//s.qunarzz.com/travel/bigface/2.png' &#125;, &#123; title: '亲亲', url: '//s.qunarzz.com/travel/bigface/3.png' &#125;, &#123; title: '色', url: '//s.qunarzz.com/travel/bigface/4.png' &#125;, &#123; title: '朕知道了', url: '//s.qunarzz.com/travel/bigface/5.png' &#125;, ]const faceDataList02 = [ &#123; title: '可爱', url: '//s.qunarzz.com/travel/bigface/32.png' &#125;, &#123; title: '白眼', url: '//s.qunarzz.com/travel/bigface/33.png' &#125;, &#123; title: '鄙视', url: '//s.qunarzz.com/travel/bigface/34.png' &#125;, &#123; title: '饥饿', url: '//s.qunarzz.com/travel/bigface/35.png' &#125;, &#123; title: '困', url: '//s.qunarzz.com/travel/bigface/36.png' &#125;, &#123; title: '惊恐', url: '//s.qunarzz.com/travel/bigface/37.png' &#125;const faceDataList03 = [ &#123; title: '抱抱', url: '//s.qunarzz.com/travel/bigface/64.png' &#125;, &#123; title: '便便', url: '//s.qunarzz.com/travel/bigface/65.png' &#125;, &#123; title: '玫瑰', url: '//s.qunarzz.com/travel/bigface/66.png' &#125;]; 分析： 第一步先合并着三个变量,也就是合并多个数组1234567891011121314151617function flatten(arr)&#123; var result = []; for (var i = 0; i &lt; arr.length; i++) &#123; result = result.concat(arr[i]) &#125; // console.log(result) var newObj = &#123;&#125; for (var i = 0; i &lt; result.length; i++) &#123; var m = result[i]; newObj[m.title] = &#123;url:m.url&#125; &#125; return newObj&#125;var result = flatten(faceDataList01,faceDataList02,faceDataList03)console.log(result) //所有数据console.log(result.亲亲.url) // 查询某一项的图片地址","categories":[],"tags":[]},{"title":"对象类型","slug":"算法题1","date":"2017-06-23T03:02:12.000Z","updated":"2019-02-23T03:55:04.561Z","comments":true,"path":"2017/06/23/算法题1/","link":"","permalink":"http://yoursite.com/2017/06/23/算法题1/","excerpt":"","text":"任务一： 不同分数段学生的个数已知10名同学的成绩数组为：all_math_scores，统计处于不同分数段学生的个数，保存到相应的变量，如下：var count_A = 0;//存储成绩140分以上的学生的个数var count_B = 0;//存储成绩在130～140分之间的学生的个数var count_C = 0;//存储成绩在130分以下的学生的个数添加for循环语句和if-else if语句，使统计结果正确123456789101112131415161718192021222324252627//10名同学的数学成绩，请勿删除var all_math_scores = [143,135,139,148,135,133,143,142,139,142];var count_A = 0;//存储成绩140分以上的学生的个数var count_B = 0;//存储成绩在130～140分之间的学生的个数var count_C = 0;//存储成绩在130分以下的学生的个数var current_aArr =[];var current_bArr =[];var current_cArr =[];//添加for循环语句完成代码for (var i = 0; i &lt; all_math_scores.length; i++) &#123; var current = all_math_scores[i]; if(current&gt;140)&#123; current_aArr.push(current); count_A = current_aArr.length; &#125;else if(130&lt; current &lt;140)&#123; current_bArr.push(current); count_B = current_bArr.length; &#125;else if(current&lt;130)&#123; current_cArr.push(current); count_c = current_cArr.length; &#125;&#125;//打印三个分数段学生的个数，请勿删除本行console.log('140分以上的学生的个数：'+count_A);console.log('130～140分之间的学生的个数：'+count_B);console.log('130分以下的学生的个数：'+count_C); 任务二 ：求最高分数已知存储10名学生的各科成绩的数组all_scores遍历all_scores获取到每个学生的各科成绩all_scores[i]遍历all_scores[i]获取到每个学生的每科成绩通过比较所有学生的所有成绩获取成绩的最高值，赋值给变量highest_score12345678910111213141516171819202122232425262728//10名同学的各科的成绩 请勿修改此句var all_scores = [[131,143,144], [131,135,144], [127,139,142], [123,148,136], [126,135,140], [129,133,138], [116,143,140], [114,142,139], [115,139,135], [116,142,129]];var highest_score = all_scores[0][0];//使用for循环求这10名学生中所有科目的最高分for (var i = 0; i &lt; all_scores.length; i++) &#123; var scores = all_scores[i]; for (var j = 0; j&lt; scores.length; j++) &#123; var arr_scores = scores[j]; console.log(arr_scores); if(highest_score&gt;arr_scores)&#123; highest_score =highest_score; &#125;else&#123; highest_score = arr_scores; &#125; &#125;&#125;// console.log(arr_scores)//打印这10名学生所有科目的最高分 console.log('这10名学生所有的最高分为：'+highest_score); 任务三： 给对象复值已知某班学生的语文成绩，展示为哈希表stu_scores根据部分学生姓名数组stu_names，获取这部分学生的成绩，以哈希表的形式存储（保存到变量stu_names_scores中），如： {‘刘帅’:116，’王雪’:120}123456789101112131415161718192021222324//某班学生的语文成绩var stu_scores = &#123;'杨璐':131, '王雪':131, '韩林霖':127, '沙龙逸':123, '李鉴学':126, '韩雨萌':129, '刘帅':116, '康惠雯':114, '刘钰婷':115&#125;;var stu_names = ['刘帅','康惠雯','沙龙逸','王雪','杨璐','李丽'];var stu_names_scores = &#123;&#125;;//获取数组stu_names中学生的成绩for (var i = 0; i &lt; stu_names.length; i++) &#123; //给对象复值 stu_names_scores[stu_names[i]] = stu_scores[stu_names[i]];&#125;//打印哈希数组stu_names_scores中学生成绩console.log('刘帅成绩：'+stu_names_scores['刘帅']);console.log('康惠雯成绩：'+stu_names_scores['康惠雯']);console.log('沙龙逸成绩：'+stu_names_scores['沙龙逸']);console.log('王雪成绩：'+stu_names_scores['王雪']);console.log('杨璐成绩：'+stu_names_scores['杨璐']);","categories":[],"tags":[]},{"title":"javascript的对象使用","slug":"JavaScript实用对象","date":"2017-05-31T03:30:37.000Z","updated":"2019-02-23T03:55:04.548Z","comments":true,"path":"2017/05/31/JavaScript实用对象/","link":"","permalink":"http://yoursite.com/2017/05/31/JavaScript实用对象/","excerpt":"","text":"【JavaScript的对象理解不多的文章】(https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects)json数据的获取，删除和赋值理解代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;script type=\"text/javascript\"&gt; var gggg = &#123; webview : &#123; dianping : '121wdwdwd ke', note : 'adcdefg', invite : 'com.www.xxxxx://inv', sharenote : 'com.www.xxxxx://?keywords=&amp;day=&amp;type=&amp;month=' &#125;, touch : &#123; dianping : '121wdwdwd ke', note : 'adcdefg', invite : 'com.www.xxxxx://inv', sharenote : 'com.www.xxxxx://?keywords=&amp;day=&amp;type=&amp;month=' &#125; &#125;; // alert(gggg.webview.dianping) function getData(p1,p2)&#123; gggg[p1][p2]; // alert(gggg[p1][p2]); &#125; function delData(p1,p2)&#123; delete gggg[p1][p2]; // alert(gggg[p1][p2]); &#125; function setData(p1,p2,new1)&#123; gggg[p1][p2] = new1; &#125; //获取json 数据 getData('touch','note'); // 删除对象里的某一项值 delData('touch','note'); //给对象里的某一项重新赋值 setData('touch','note', '12345'); getData('touch','note'); var person = &#123; name : 'aaaa', age : 18, addr : 'bj' &#125;; //kk 表示person对象里的每一项 属性 for (var kk in person) &#123; // 这里的kk 代表当前传进来的属性 console.log(\"obj.\" + kk + \" = \" + person[kk]); &#125;结果： obj.name = aaaa obj.age = 18 obj.addr = bj&lt;/script&gt;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"移动端开发","slug":"移动端开发相关文章","date":"2017-05-31T03:30:37.000Z","updated":"2019-02-23T03:55:04.561Z","comments":true,"path":"2017/05/31/移动端开发相关文章/","link":"","permalink":"http://yoursite.com/2017/05/31/移动端开发相关文章/","excerpt":"","text":"在真实项目中，设计师给我们的设计稿一般都是： 640960/6401136/750*1334手机常用尺寸 :5s以下 :320px; 6:375px; 6plus:414px;安卓：320、360、480、540、640 …在特殊情况： 设计师的设计稿是640px; 素材也是640px; 这样在iPhone6 以上展示的时候，图片不够大，这种情况下就需要单独找设计师要一张更大的图片（1280px） 12345678910@media all and(-webkit-min-device-pixel-ratio:2) and (min-width:321px)&#123; .box&#123; background:url(\"banner@big.png\") 0 0 ; &#125;&#125;@media all and (min-width:641px)&#123; .box&#123; background:url(\"banner@big.png\") 0 0 ; &#125;&#125; 在html 页面中开启打电话和发送短信功能12&lt;a href=\"tel:1234567\"&gt;立即拨打电话&lt;/a&gt;&lt;a href=\"sms:1234567\"&gt;立即发送短信&lt;/a&gt; 如果需要禁止自动识别邮箱，可以再原来的基础上增加“email= no”12// 忽略自动转换识别为电话，调取拨号键&lt;meta name=\"format-detaction\" content=\"telephone=no,email = no\"/&gt; 一， 响应式布局解决方案：1&gt;流式布局法： 容器和或者盒子的宽度一般都不写固定的值，而是使用百分比（相对于视口区域的百分比）2&gt;其余样式：字体，高度， margin / padding 等等都是按照设计稿上标注尺寸的一半来设置3&gt; 对于有些屏幕尺寸下，我们设置的固定值看起来不是特别好的好看的话，使用@media 进行微调整 如何做响应式布局开发?只要当前页面需要在移动端访问，必然加12 一，rem相关不错的文章链接记载1,rem 使用相关的链接2.rem 使用相关链接 二，页面引用的js代码如下：1，页面一进去就执行一次12//设计图宽度为750px document.documentElement.style.fontSize = document.documentElement.clientWidth / 7.5 + 'px'; 2, 在页面内来回切换横屏和竖屏需要多次执行12345678910111213141516//设计图宽度为750px(function(doc, win) &#123; var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function() &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; docEl.style.fontSize = document.documentElement.clientWidth / 7.5 + 'px'; &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false);&#125;)(document, window); 12345678910111213(function () &#123; var winW = document.documentElement.clientWidth, desW = 640, htmlFont = winW / desW * 100; if (winW &gt;= 640) &#123;//当屏幕的宽度大于设计稿的宽度是，整个区域最宽640 $('.musicBox').css(&#123;//可在css中写 width: desW, margin: \"0 auto\" &#125;); window.htmlFont = 100; return; &#125; window.htmlFont = htmlFont;//将变量转为全局变量传递出函数作用域 document.documentElement.style.fontSize = htmlFont + \"px\";//设置html根元素的字体大小&#125;)();","categories":[],"tags":[]},{"title":"事件总结","slug":"事件知识点","date":"2017-05-15T08:48:00.000Z","updated":"2019-02-23T03:55:04.553Z","comments":true,"path":"2017/05/15/事件知识点/","link":"","permalink":"http://yoursite.com/2017/05/15/事件知识点/","excerpt":"","text":"什么是事件事件分为两部分：1》行为本身:浏览器天生就赋予其的行为:onclick,onmouseover,(onmouserenter),onmouseout(onmouseleave),onmousemove,onmousedown,onmouseup,onmousewheel(鼠标滚轮滚动的行为)，onscroll(滚动条滚动行为)，onresize(window.onresize浏览器窗口的大小改变事件)onload, onunload,onfocus(文本框获取焦点行为), onblur(文本框失去焦点行为), onkeydown,onkeyup(键盘的按下和抬起行为)…2》事件绑定：给元素的某一个行为绑定方法1234567891011121314151617181920212223var oDiv = document.getElementById('div');//DOM0 级绑定 onclick 这个行为定义在当前元素的私有属性 都是在冒泡阶段触发的// 只能给一个元素的某一个行为绑定一次方法，第二次绑定的会把前面的覆盖掉.还提供了一些DOM0级没有的方法。oDiv.onclick = function()&#123; console.log(111)&#125;oDiv.onclick = function()&#123; console.log(222)&#125;//222// DOM2级事件绑定 addEventListener 这个属性定义在当前元素所属EventTarget这个类的的原型上的.(IE6~8不兼容)//oDiv通过原型链一直找到EventTarget这个内置类原型上的addEventListener方法实现。//优势：可以给某一个元素的同一个行为绑定多个”不同“的方法(如果方法相同，就只留一个)，Dom0中的行为类型，我们用Dom2一样可以绑定。// 当行为触发，会按照绑定方法的顺序执行// 执行方法中的this是当前被绑定事件的元素本身oDiv.addEventListener(\"click\",function()&#123; console(111) &#125;,false);oDiv.addEventListener(\"click\",function()&#123; console(222) &#125;,false); // 111 //222 移除事件绑定 removeEventListener(“”,fn1,false);移除DOM2事件绑定 的时候必须保证三个参数：行为，方法，在那个阶段，一点都不能错， 一般我们都使用实名函数绑定 change 事件主要针对 input , select textarea 这类元素， 监听他们的值得变化。 一，事件流(事件默认传播机制)1，事件流包含事件捕获和冒泡。 进行顺序是 事件捕获阶段、处于目标阶段、事件冒泡阶段。2，事件捕获（event capturing）：通俗的理解就是，当鼠标点击或者触发dom事件时，浏览器会从根节点开始由外到内进行事件传播，即点击了子元素，如果父元素通过事件捕获方式注册了对应的事件的话，会先触发父元素绑定的事件。3，事件冒泡（dubbed bubbling）：与事件捕获恰恰相反，事件冒泡顺序是由内到外进行事件传播，直到根节点。4，dom标准事件流的触发的先后顺序为：先捕获再冒泡，即当触发dom事件时，会先进行事件捕获，捕获到事件源之后通过事件传播进行事件冒泡。不同的浏览器对此有着不同的实现，IE10及以下不支持捕获型事件，所以就少了一个事件捕获阶段，IE11、Chrome 、Firefox、Safari等浏览器则同时存在。 事件冒泡与捕获用于事件绑定的方法addEventListener、attachEvent介绍 1，addEventListener(event, listener, useCapture) addEventListener(event, listener, useCapture) ·参数定义：event—（事件名称，如click，不带on），listener—事件监听函数，useCapture—是否采用事件捕获进行事件捕捉， 默认为false，即采用事件冒泡方式 true则在捕获阶段发生 addEventListener在 IE11、Chrome 、Firefox、Safari等浏览器都得到支持。 removeEventListener(event,listener,false) 2，attachEvent(event,listener) 默认只能在冒泡阶段发生，行为需要添加on参数定义：event—（事件名称，如onclick，带on），listener—事件监听函数。attachEvent主要用于IE浏览器，并且仅在IE10及以下才支持，IE11已经废了这个方法了。detachEvent 移除3,和标准浏览器的事件池机制对比 顺序问题：执行后的结果是混乱的 重复问题： IE6~8可以重复绑定同一个方法多次 this问题： IE6~8当方法执行的时候，方法中的this不是当前的元素box,而是window。 demo介绍 案例一：事件触发顺序是由内到外的，这就是事件冒泡，虽然只点击子元素，但是它的父元素也会触发相应的事件，其实这是合理的，因为子元素在父元素里面，点击子元素也就相当于变相的点击了父元素. 事件传播—event.stopPropagation() ； 案例二: 是捕获 有外到内的，注意必须给每一级元素绑定事件采用true 捕获方式，只给触发捕获的子元素采用捕获是不起作用。 事件委托/事件代理利用事件的冒泡传播机制(触发当前某个元素的每个行为，他父级所有元素的相关行为都会触发)，如果一个容器中有很多的元素都要绑定点击事件，就没有必要一个个的绑定额，只需要给最外层容器绑定一个点击事件即可，在执行这个方法的时候，通过事件源的区分来进行不同的操作委托在JQuery中已经得到了实现，即通过$(selector).on(event,childSelector,data,function,map)实现委托，一般用于动态生成的元素，当然JQuery也是通过原声的js去实现的，下面举一个简单的栗子，通过js实现通过parent元素给child元素注册click事件12345678910111213141516var outer = document.getElementById(\"outer\"), inner = document.getElementById(\"inner\"), center = document.getElementById(\"center\");document.body.onclick = function(e)&#123; e=e||window.event; console.log(e.target.id);&#125;;var parent = document.getElementById(\"parent\");var child = document.getElementById(\"child\");parent.onclick = function(e)&#123; if(e.target.id == \"child\")&#123; console.log(\"您点击了child元素\") &#125;&#125; 二， 事件处理程序主要包含：1，html事件处理程序2，DOM 0 事件处理程序： this作用域是当前DOM3， DOM 2 事件处理程序： addEventListener()和 removeEventListener();4, IE 事件处理程序 ：attachEvent()和 detachEvent() this作用域是window5, 跨浏览器事件处理程序： 三 ，事件的对象和对象的兼容问题1》事件对象本身的获取存在兼容问题:标准浏览器中是浏览器给方法传递的参数，只需要定义形参e就可以获取到;在IE6~8中浏览器不会给方法传递参数，如果需要就要到window.event中获取查找。123456oDiv.onclick = function(e)&#123; e = e||window.event; e.type :存储的是当前鼠标触发的行为类型\"click\" e.clientX /e.clientY : 当鼠标触发点距离当前屏幕的左上角的x/y轴坐标 event.target: 事件源，代表当前触发事件的元素; 有兼容问题IE6~8 使用e.srcElement&#125; 1，事件对象是用来记录一些事件发生时的相关信息的对象。事件对象只有事件发生时才会产生，并且只能是事件处理函数内部访问，在所有事件处理函数运行结束后，事件对象就被销毁2》》target 属性可以是注册事件时的元素，或者它的子元素。通常用于比较 event.target 和 this 来确定事件是不是由于冒泡而触发的。经常用于事件冒泡时处理事件委托简单来说：event.target: 事件源，代表当前触发事件的元素，可以通过当前元素对象的一系列属性来判断是不是我们想要的元素1e.target = e.target||e.srcElement; 3》对象的属性和方法主要包含： 1&gt; event.type：获取事件的类型 2&gt; event.pageX 和 event.pageY：获取鼠标当前相对于页面的坐标(也就是触发点距离body坐上角的x/y坐标轴) 通过这2个属性，可以确定元素在当前页面的坐标值，鼠标相对于文档的左边缘的位置（左边）与 （顶边）的距离，简单来说是从页面左上角开始,即是以页面为参考点,不随滑动条移动而变化 也有兼容问题在IE6~8 中没有这个属性，可以通过使用clientY+滚动条卷去的高度获取也可以12e.pageX = e.pageX ||(e.clientX+(document.documentElemrnt.scrollLeft||document.body.scrollLeft))e.pageY = e.pageY ||(e.clientX+(document.documentElemrnt.scrollTop||document.body.scrollTop)) 4》 event.preventDefault() 方法：阻止默认行为 也兼容问题1234e.preventDefault ? e.preventDefault() : e.returnValue = false;// 和上述的代码是一样的效果都是在阻止默认的行为return false; 4&gt; event.which：获取在鼠标单击时，单击的是鼠标的哪个键5&gt; event.currentTarget : 在事件冒泡过程中的当前DOM元素,冒泡前的当前触发事件的DOM对象, 等同于this..this和event.target都是dom对象如果要使用jquey中的方法可以将他们转换为jquery对象。比如this和$(this)的使用、event.target和$(event.target)的使用； 四: 键盘事件123456789101112var input1 = document.getElementById(\"input1\")input1 onkeyup = function(e)&#123; e = e||window.event; //keyboardEvent //e.keyCode:当前键盘上每一个键对应的值 // 空格键:(space) --&gt;32 //回退键:(Backspace) --&gt;8 //回车键:(Enter) --&gt;13 //删除键:(delete) --&gt;46 //四个方向键： 左(37) 上（38）右 (39) 下(40) console.log(e.keyCode)&#125; window.onload = function(){} 和$(function(){}) 区别：window.onload = function(){} //当页面中的所有资源都加载完成才执行后面的函数，并且在一个页面中只能用一次，多次的话后面的会把前面的覆盖掉。原理： 采用了DOM0级事的onload 事件件绑定，所以只能绑定一次 jQuery: $(document).ready(function(){}) === $(function(){})只要当页面的HTML 结构加载完成就会执行对应的函数，并且在同一个页面中可以出现多次。原理：采用了BOM2级的事件绑定，绑定的行为是DOM2 中新增的那个DOMContentLoaded 事件池概念： 1》 事件池是用来存储当前元素行为绑定的方法的(浏览器自带的)","categories":[],"tags":[{"name":"js 基础","slug":"js-基础","permalink":"http://yoursite.com/tags/js-基础/"}]},{"title":"Array引用类型详解","slug":"Array引用类型详解","date":"2017-05-09T08:40:08.000Z","updated":"2019-02-23T03:55:04.545Z","comments":true,"path":"2017/05/09/Array引用类型详解/","link":"","permalink":"http://yoursite.com/2017/05/09/Array引用类型详解/","excerpt":"","text":"Array对象 &emsp; 一，定义 ：用于在一个变量里面存储多个值。 创建Array对象的语法 12var arr = new Array(size);//size是期望数组元素的个数。var arr = Array[]; 二，Array对象属性 属性 描述 constructor 返回创建此对象的数组函数的引用 length 设置或返回数组中元素的数目 prototype 使您有能力向对象添加属性和方法 二，Array对象方法 方法 描述 concat() 连接两个或是更多的数组，并返回结果 join() 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分割 pop() 删除并返回数组的最后个元素 push() 向数组的末尾添加一个或是多个元素并返回新的长度 reverse() 颠倒数组中的元素顺序 shift() 删除并返回数组的第一个元素 slice() 从某一个原有的数组中中返回选定的数组 sort() 对数组进行排序 splice() 删除元素，并向数组添加新元素 toSoure() 返回数组的源代码 toString() 把数组转换成字符串，并返回结果 toLocaleString() 把数组转换成本地数组，并返回结果 unshift() 向数组的开头添加一个或更多元素，并返回新数组的长度。 volueOf() 返回数组对象的原始值","categories":[],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://yoursite.com/tags/js基础/"}]},{"title":"对象类型","slug":"对象类型","date":"2017-05-09T03:02:12.000Z","updated":"2019-02-23T03:55:04.557Z","comments":true,"path":"2017/05/09/对象类型/","link":"","permalink":"http://yoursite.com/2017/05/09/对象类型/","excerpt":"","text":"对象类型可以创建并使用的对象有三种：本地对象和内置对象和诉诸对象。 本地对象本地对象简单来说就是定义的类（引用类型）它包括： Object Function Array String String 对象是 String 原始类型的对象表示法，它是以下方式创建的： 1var oStringObject = new String(\"hello world\"); String 对象的 valueOf() 方法和 toString() 方法都会返回 String 类型的原始值： 1alert(oStringObject.valueOf() == oStringObject.toString()); //输出 \"true\" length 属性String 对象具有属性 length，它是字符串中的字符个数： 12var oStringObject = new String(\"hello world\");alert(oStringObject.length); //输出 \"11\" charAt() 和 charCodeAt() 方法 首先，两个方法 charAt() 和 charCodeAt() 访问的是字符串中的单个字符。这两个方法都有一个参数，即要操作的字符的位置。 concat() 方法接下来是 concat() 方法，用于把一个或多个字符串连接到 String 对象的原始值上。该方法返回的是 String 原始值，保持原始的 String 对象不变： 1234var oStringObject = new String(\"hello \");var sResult = oStringObject.concat(\"world\");alert(sResult); //输出 \"hello world\"alert(oStringObject); //输出 \"hello \" indexOf() 和 lastIndexOf() 方法indexOf() 开头起始值0 和 lastIndexOf()从尾部开始 方法返回的都是指定的子串在另一个字符串中的位置，如果没有找不到子串，则返回 -1。 localeCompare() 方法 slice() 和 substring() 转换大小写 toLowerCase() toLocaleLowerCase() toUpperCase() toLocaleUpperCase() Boolean Number Number处理数值的专用方法： toFixed() 方法返回的是具有指定位数小数的数字的字符串表示。例如： 12var oNumberObject = new Number(68);alert(oNumberObject.toFixed(2)); //输出 \"68.00\" 在这里，toFixed() 方法的参数是 2，说明应该显示两位小数。该方法返回 “68.00”，空的字符串位由 0 来补充。对于处理货币的应用程序，该方法非常有用。toFixed() 方法能表示具有 0 到 20 位小数的数字，超过这个范围的值会引发错误。 Date RegExp Error EvalError RangeError ReferenceError SyntaxError TypeError URIError引用类型通常叫做类（class）。 Object.create() 创建一个新的对象，但是还要把proObj 作为这个对象的原型语法：Object.create(proObj)","categories":[],"tags":[]},{"title":"面向对象","slug":"面向对象","date":"2017-05-08T11:37:01.000Z","updated":"2019-02-23T03:55:04.562Z","comments":true,"path":"2017/05/08/面向对象/","link":"","permalink":"http://yoursite.com/2017/05/08/面向对象/","excerpt":"","text":"面向对象对象定义为属性的无序集合，每个属性存放一个原始值，对象或函数。通用说定义是基于代码的名词（人，地点或事物)的表示。 类：每个对象都有类定义，可以把类看做对象的配方。类不仅要定义对象的接口（开发者访问的属性和方法），还要定义对象的内部工作（是属性和方法发挥作用的代码）编译器和解释程序都根据类的说明构建函数。 JS 中所有的类都是函数数据类型的，它通过new执行变成一个类，但是它本身也是一个普通的函数JS 中所有实例都是对象数据类型的实例：程序实用类创建对象时，生成的对象叫作类的实例。面向对象语言的要求1，封装：把相关的信息（无论数据或方法）储存在对象中的能力.(简单理解就是工厂模式又叫做函数封装)2，聚焦：把一个对象储存在另一个对象中的能力3，继承：子类继承父类中的属性和方法。4，多态：当前方法多种形态。（后台语言中：多态包含：重载和重写）重载： 后台里面的重载是：两个方法名相同，但是参数不相同，根据参数不同调用不同的方法123456789101112131415public void sum(int num1,int num2)&#123;//=&gt;CODE&#125; public void sum(int num1)&#123;//=&gt;CODE&#125; public void sum(int num1,string str)&#123;//=&gt;CODE&#125; sum(12,23)sum(12)sum(12,'aa') JS 中不存在重载，方法名一样，后面的会把前面的覆盖掉,最后只保留一个。Js 中有一个操作类似重载但不是重载:同一个方法名，可以根据传递参数的不一样，实现不同的功能12345678function sum(num)&#123; if(typeof num === 'undefined')&#123; return 0 ; &#125; return num;&#125;sum(100);sum() 重写：子类重写父类的方法 Object对象具有下列属性： constructor 构造函数 对创建对象函数的引用（指针）。对于Object对象，该指针指向原始的Object()函数。 Prototype 对该对象的对象原型的引用。对于所有的对象他都默认返回Object对象的一个实例。 Object对象还具有的几个方法: hasOwnProperty(property) 判断对象是否有某个特定的属性。必须用字符串指定该属性。（例如，o.hasOwnProperty(“name”) IsPrototypeOf(object) 判断该对象是否为另一个对象的原型。 PropertyIsEnumerable 判断给定的属性是否可以用 for…in 语句进行枚举。 ToString() 返回对象的原始字符串表示。对于 Object 对象，ECMA-262 没有定义这个值，所以不同的 ECMAScript 实现具有不同的值。 ValueOf() 返回最适合该对象的原始值。对于许多对象，该方法返回的值都与 ToString() 的返回值相同。 对象的应用对象的创建和销毁都在 JavaScript 执行过程中发生的。1，声明和实例化对象的创建方式是用关键字 new 后面跟上实例化的类的名字。1var oObject = new object();//创建了Object类的一个实例，并把它储存到变量oObject中。 2，对象引用在前面的章节中，我们介绍了引用类型的概念。在 ECMAScript 中，不能访问对象的物理表示，只能访问对象的引用。每次创建对象，存储在变量中的都是该对象的引用，而不是对象本身。3，对象的废除把对象的所有引用都设置为null，可以强制性地废除对象。例如：12var oObject = new Object();oObject = null; 注意：废除对象的所有引用时要当心。如果一个对象有两个或更多引用，则要正确废除该对象，必须将其所有引用都设置为 null。4,早绑定和晚绑定所谓的绑定就是对象的接口与对象实例结合在一起。早绑定：指在实例化对象之前定义它的属性和方法。晚绑定：指的是编译器或解释程序在运行前，不知道对象的类型。使用晚绑定，无需检查对象的类型，只需要检查对象是否支持属性和方法即可。 一，单例模式1， 对象数据类型的作用： 把描述同一个事物(同一个对象)的属性和方法放在一个内存空间下，起到了，分组的作用，这样不同事物之间的属性即使属性名相同，相互也不会发生冲突。 1&gt;我们把这分组编写代码的模式叫做“单例模式”。 2&gt; 在单例模式中我们把person1或者person2 也叫做“命名空间”12345678910var person1 =&#123; name:'张三'， age:34&#125;var person2 =&#123; name:'lisi'， age:24&#125;person1.name;person2.name; 3&gt; 单例模式是一种项目开发中经常使用的模式，因为项目中我们可以使用单例模式来进行我们的“模块开发” 4&gt; 模块开发： 对于一个项目来说比较大的项目，需要多人协作的开发，我们一般情况下会根据当前项目的需求划分几个功能的版块 每个人负责一部分，同时开发，最后在进行合并 12345678910111213141516171819202122var untils = &#123; //公共模块 select:function()&#123; console.log(123) &#125;&#125;;var tabRender=&#123; change:function()&#123; untils.select(); // 在自己命名空间下调用其他命名空间的方法 &#125;&#125;var searchRender=&#123; change:function()&#123; this.cliclEvent() //在自己的命名空间下调用自己命名空间下的方法 &#125; serch:function()&#123; &#125; cliclEvent:function()&#123; &#125;&#125;searchRender.change(); 工厂模式又叫函数的封装 :指 把实现同一件事情的相同代码放到一个函数中，以后如果再想实现这个功能，不需要重新的编写这些代码，只需要执行当前函数即可–”函数的封装“。函数封装的特性： 低耦合高内聚： 减少页面中的冗余代码，提高代码的重复利用率。12345678910111213function creatJsPerson(name,age)&#123; var obj = &#123;&#125;; obj.name= name; obj.age = age; obj.writeJs = function()&#123; console.log(\"my name is\" + this.name + \"I can write js 啦~~~\") &#125; return obj;&#125;var p1 = creatJsPerson(\"张三\",23);p1.writeJs();var p2 = creatJsPerson(\"李四\",33);p1.writeJs(); 构造函数模式 目的是为了创建一个自定义类，并且创建这个类的实例123456789101112function CreatJsPerson(name,age)&#123; this.name= name; this.age = age; this.writeJs = function()&#123; console.log(\"my name is\" + this.name + \"I can write js 啦~~~\") &#125;&#125;var p1 = new creatJsPerson(\"张三\",23);p1.writeJs();var p2 = new creatJsPerson(\"张三\",23);p2.writeJs();console.log(p1.writeJs === p2.writeJs) //false 构造函数和工厂模式的区别?1,执行的时候：工厂模式就是普通函数执行creatJsPerson();构造函数模式： new CreatJsPerson() 通过new执行 这就是一个类;而函数执行的返回值(p1)就是CreatJsPerson这个类的一个实例。2，在函数代码执行的时候相同： 都是形成一个私有作用域，然后形参，预解释 代码从上向下执行。不同： 1&gt;在代码执行前，不用自己在手动的创建对象了。浏览器会默认创建一个对象数据类型的值(这个对象数据类型的值就是我们当前的实例) 接下来代码从上到下执行，以当前的实例为执行的主体(this代表的就是当前实例) 然后分别把属性名和属性值赋值给当前的实例 2&gt;浏览器会默认的把创建的实例返回3，在构造函数模式中，类中（函数体中）出现的this.xxx=xxx 中的this是当前类的一个实例。4， p1和p2 都是CreatJsPerson 这个类的实例，所以我们都拥有writeJs 这个方法，但是不同实例之间的方法是不一样的。 在类中给实例增加的属性(this.xxx = xxx) 属于当前实例的私有属性，实例和实例之间是单独的个体，所以私有的属性之间是不相等的。 1console.log(p1.writeJs === p2.writeJs) //false 5, 在构造函数模式中new Fn（） 执行，如果Fn 不需要传递参数的话，后面的小括号可以省略123function Fn()&#123;&#125;var f1 = new Fn; 6， this 问题 :在类中出现的this.xxx = xxx 中的this都是当前类的实例。而某一个属性值(方法),方法中的this需要看方法执行的时候，前面是有否”.” 才能知道this是谁。12345678910function Fn()&#123; this.x = 100; this.getX = function()&#123; console.log(this.x); &#125;&#125;var f1 = new Fn;f1.getX();var ss = f1.getX;ss() 7, 类有普通函数的一面，当函数执行的时候，var num 其实只是当前形成的私有作用域内的私有变量而已，他和我们这个f1实例没有任何关系；只有在this.xxx = xxx才相当于给f1这个实例增加私有属性和方法，才和f1 有关系。123456789function Fn()&#123; var num =10; this.x = 100; this.getX = function()&#123; console.log(this.x) &#125;&#125;var f1 = new Fn;console.log(f1.num); 基于构造函数模式的原型模式:解决方法或者属性公有的问题,把实例之间的相同的属性和方法提取成公有的属性和方法即想让谁公有就把它放在CreateJsPerson.prototype上即可。12345678910function CreatJsPerson(name,age)&#123; this.name= name; this.age = age;&#125;CreatJsPerson.prototype.writeJs = function()&#123; console.log(\"my name is\" + this.name + \"I can write js 啦~~~\") &#125;var p1 = new creatJsPerson(\"张三\",23);var p2 = new creatJsPerson(\"张三\",23);console.log(p1.writeJs === p2.writeJs) //false 一：1&gt; 每一个函数数据类型（普通函数，类）都有一个天生自带的属性：prototype(原型)并且这个属性是一个对象数据类型的值2&gt; 并且在prototype上浏览器天生给他加了一个属性constructor(构造函数)，属性值是当前函数（类）本身。3&gt;每一个对象数据类型(普通的对象，实例，prototype…)也天生自带一个属性：proto: 属性值是当前实例所属的原型（prototype) 123456789101112function Fn()&#123; this.x = 100;&#125;Fn.prototype.getX = function ()&#123; console.log(this.x);&#125;;var f1 = new Fn;var f2 = new Fn;console.log(Fn.prototype.constructor === Fn);//二：Object是js中所有对象数据类型的基类（最顶层的类）// 1, f1 instanceof object ===true ,因为f1 通过__proto__可以向上一级查找，不管多少级，最后总能找到Object//2,在Object.prototype上没有__proto__这个属性 三：原型链模式f1.hasOwnProperty(“x”); hasOwnProperty是f1 的一个属性，但是我们发现f1 的私有属性和方法并没有这个方法，那如何处理的呢？1&gt; 通过，对象名.属性的方式获取属性值的时候，首先在对象的私有的属性上进行查找，如果私有属性中存在这个属性，则获取的是私有的属性。2&gt; 如果私有的没有，则通过proto找到所属类的原型(类的原型上定义的属性和方法都是当前实例公有的属性和方法)，原型上存在的话，获取的是公有的属性值;3&gt; 如果原型上也没有，则继续通过原型上的proto继续向上查找，一直找到Object.prototype为止…// –&gt; 这种查找的机制就是我们的”原型链模式“123f1.getX ===f2.getX //truef1.__proto__.getX === f2.getX //truef1.getX === Fn.prototype.getX // true 4&gt; 在原型模式中，this常用的有两种情况：在类中this.xxx =xxx;this 就是当前类的实例某一个方法中的this主要看在执行的时候，前面是谁this 就是谁第一：需要先确定this的指向（this是谁）；第二： 把this替换成对应的代码；第三：按照原型链查找机制，一步一步的查找结果。12345678910111213141516171819202122232425262728293031323334353637383940414243function Fn()&#123; this.x = 100; this.y = 200; this.getX = function()&#123; console.log(this.y); &#125;&#125;Fn.prototype = &#123; constructor:Fn, y:300, getX: function()&#123; console.log(this.x); &#125;, getY:function()&#123; console.log(this.y) &#125;&#125;var f = new Fn;f.getX(); console.log(f.x);f.__proto__.getX(); // this是f._proto__ ,console.log(f.__proto__.x) 直接查找原型链上的，//跳过了私有方法所以公有方法和object基类上也没有x变量，所以最终的只是undefined。f.prototype.getX() f.getY() f.__proto__.getY() // 在内置类的原型上扩展我们的数组去重方法Array.prototype.myUnique = function ()&#123; var obj =&#123;&#125;; for (var i=0;i&lt;this.length;i++)&#123; var cur = this[i]; if(obj[cu]==cur)&#123; this[i]=this[this.length-1]; this.length-- ; i--; continue; &#125; obj[cur] =cur &#125; obj =null; return this; // 返回去重后的数组&#125;;var ary = [];ary.myUnique();Array.prototype.myUnique() prototype.x=100 和prototype={x=100} 的区别？1234567891011121314151617181920212223function A() &#123;&#125;A.prototype.x = 10;var a1 = new A();A.prototype.y = 30;var a2 = new A();alert(a1.x);alert(a1.y);alert(a2.x);alert(a2.y);function B() &#123;&#125;B.prototype.x = 10;var a1 = new A();B.prototype = &#123; x: 20, y: 30&#125;;var a2 = new B();alert(a1.x);alert(a1.y);alert(a2.x);alert(a2.y); 区别在于： A 的原型指的是function A (){}这个函数默天生自带的prototype，A.prototype.y = 30; 只是在原有的原型上新增加了一个属性名为y,属性值是30 的属性。 所以结果a1 和 a2 两个实例指向同一个原型内存。 B 会形成两个不同的内存空间，B.prototype.x = 10; 开辟的内存空间里面有x =10, 而且赋给了实例a1，这个内存空间不能销毁，而保留。 B.prototype = { x: 20, y: 30}; 则是B.prototype得到的又是一个对象数据类型的，所以就会又新开辟一个内存空间来存放B的代码内容所以结果是a1 和 a2 指向不同的内存地址。实例a1 的内存里面没有y 的属性和值，只有x =10;实例a2 指的内存里面有：x:20;y:30; 批量设置原型上的公有属性和方法1， 起一个别名的方式 12345678910function Fn()&#123; this.x = 100;&#125;var pro = Fn.Prototype;pro.getX = function()&#123;&#125;;pro.getY=function()&#123;&#125; 2, 重构原型对象的方式:自己新开辟一个堆内存，存储我们公有的属性和方法，原来的内存如果没有被占用，浏览器就会销毁，如果有变量占用就不会销毁。1》 只有浏览器天生给Fn.prototype开辟的堆内存里面才有constructor,而我们自己开辟的这个堆内存内没有这个属性。这样的constructor指向就不在是Fn而是Object了。console.log(f.constructor) // Object为了和原来的保持一致，我们需要手动的增加constructor的指向Fn12345678910111213function Fn()&#123; this.x = 100;&#125;Fn.prototype=&#123; constructor:Fn, //需要手动的增加constructor的指向Fn a:function()&#123; &#125;; b:function()&#123; &#125;&#125;var f = new Fn; 2》用这种方式给内置类增加公有的属性1234567Array.prototype=&#123; constructor:Array, unique:function()&#123; &#125;&#125;console.dir(Array.prototype) 我们这种方式会把之前的已经存在于原型上的属性和方法给替换调，所以这种方法修改内置类是不起作用的，浏览器会自动疲敝掉。但是可以通过这中方法来一个一个的修改内置类的方法,通过下述方式在数组的原型上增加方法，如果方法名和原来的内置的重复了。就会把原来的内置方法覆盖掉。需要在内置类上增加属性和方法，命名就需要加特殊的前缀。123456Array.prototype.sort = function()&#123; console.log('ok');&#125;var arr = [1,2,3,4,5,6,2,4,5,7,8,,45,8,6];arr.sort();console.log(arr)","categories":[],"tags":[]},{"title":"锋利的JQuery总结（一）","slug":"锋利的JQuery总结","date":"2017-05-04T03:34:16.000Z","updated":"2019-02-23T03:55:04.562Z","comments":true,"path":"2017/05/04/锋利的JQuery总结/","link":"","permalink":"http://yoursite.com/2017/05/04/锋利的JQuery总结/","excerpt":"","text":"一，JQuery的环境配置1,JQuery分为压缩版和非压缩版2,$=JQuery3,$(document).ready(function(){});相当于$(function(){});4,//注释用5,DOM对象与JQuery对象的相互转换 DOM对象转成jQuery对象 用$()把DOM对象包装起来就变成jQuery对象了。例如：12var v = document.getElementById('v');var $v = $(v);即可 jQuery对象转换成DOM对象有两种方法即:[index]和.get(index) ① jQuery是数组对象可以通过[index]的方法来得到相对应的DOM对象。 例如：12var $v = $('#v');var v =$v[0]; ②jQuery本身提供的.get(index)方法得到相应的DOM对象12var $v = ('#v');var v = $v.get(0); DOM对象才能使用DOM的方法，jQuery对象是不能使用DOM中的方法。6,与其他JS库冲突的解决(主要是$符号谁生效的问题) 【1】在其他库之后导入 使用前：先调用jQuery.noconflict();——$会被释放给jQuery库。 【2】在其他库之前导入 就直接使用$()就好N了。 二, jQuery选择器1, Css是找到元素后添加样式，jQuery是找到元素后添加行为。2, jQuery选择器的优势 【1】简洁的书写 【2】支持CSS1到CSS3的选择器 【3】完善的处理机制，即使元素不存在也不会像JS一样报错3, 判断某元素是否存在的方法 if($(‘#tt’).length&gt;0)或者if($(“#tt”)[0]) 不是要用if($(‘#tt’)!=null),因为永远不为空 4, 原生JS中查找或获取元素的方法123getElementById(\"id\") //如 id=\"one\"getElementByName(\"name\") //如多选按钮的 name=\"check\"getElementByTag(\"tagname\") //如&lt;a&gt;、&lt;span&gt;等html标签 5, 选择器的分类 基本选择器 层次选择器 过滤选择器 表单选择器 6, 基本选择器 $(‘#div’) id选择器 $(‘.div’) class选择器 $(‘p’) 标签选择器 $(‘*’) 选择所有元素 $(“div,span,.myclass”) 组合 7、层次选择器 $(“div span”) 选择div中 span后代元素 $(“div &gt;span”) 选择div中span的子元素 $(“.one + div”)选one的下一个div元素————相当于$(“.one”).next(“div”) $(“#two ~ div”) 选id为two的后面所有兄弟元素————相当于$(“#two”).nextAll(“div”); 8、过滤选择器 $(“ div:first”) 所有div元素中第一个div $(“ div:last”) 所有div元素中最后一个div $(“ input:not(.myclass)”) 不是 class为myclass 的元素 $(“ input:even”) 索引为偶数的input $(“ input:odd”)索引为奇数的input $(“input:eq(1)”) 索引为1的input——————index从0开始 $(“input:gt(1)”) 索引大于1的input $(“input :lt(1)”) 索引小于1的input $(“:header”) 所有的 …… $(“div:animated”) 正在执行动画的 $(“div:contains(‘我’)”) 含有文本‘我’的div $(“div:empty”) 空的div $(“ div :has(p)”) 含有的 $(“div:parent”) 含有子元素的 $(“:hidden”) 所有不可见元素 $(“div:visible”) 所有的可见的 $(“ div[id]”) 拥有id属性的 $(“ div[title=test]”) title为test的 $ (“div [title!=test]”) title不为test的 $(“ div[title^=test]”) title以“test”开头的div $ (“div [title$=test]”) title以“test”结束的div $(“ div[title*=test]”) title含有test的div $(“div[id][title$=test]”) 组合多条件选择 :nth-child(index/even/odd/equation) ————————index从1开始 :first-child :last-child :only-child $(“#form1 :enabled”) id为“form1”的表单内所有可用的元素 $(“#form2:disable”) $(“input:checked”) 所有被选中的元素 $(“select:selected”) 所有被选中的元素 $(“:input”) 所有 元素 $(“:text”) 所有单行文本框 $(“:password”) 所有密码框 $(“:radio”) 所有单选框 $(“:checkbox”) 所有复选框 $(“:submit”) 所有的提交按钮 $(“:image”) 所有图像按钮 $(“:reset”) 所有重置按钮 $(“:button”) 所有按钮 $(“:file”) 所有上传域 $(“:hidden”) 所有不可见元素 9、.click()事件中添加return false 可以使链接不跳转 10、添加与去除样式 removeClass() addClass() //这两个可以用一个 toggleClass() 代替 11、要时刻记住，如果用户禁用了javascript后，你的页面是不能正常处理 12、toggle()方法交替一组鼠标点击的动作 hover()方法交替一组鼠标滑过的动作 13、end() 方法可以返回到上一个可以操作的元素 14 .closest(selector) :从元素本身开始，在DOM 树上逐级向上级元素匹配，并返回最先匹配的祖先元素。 selector: 匹配元素的选择器字符串。，例如:标签ul，li, p, div ….; class ,id 等。 .closest( selector [, context ] ) context 如果提供这个参数，那么在这个DOM元素内查找匹配的元素，可以使用这个参数减小查找范围，如果在这个在这个DOM元素内没有查找到匹配的元素，那么返回空的jQuery对象。可选参数 .closest( jQuery object )jQuery object 类型: jQuery 一个用于匹配元素的jQuery对象。 .closest( element )element 类型: Element 一个用于匹配元素的DOM元素。 15, .index() 匹配的元素中搜索给定元素的索引值，从0开始计数。","categories":[],"tags":[]},{"title":"git 基础","slug":"git-基础","date":"2017-04-21T02:46:31.000Z","updated":"2019-02-23T03:55:04.550Z","comments":true,"path":"2017/04/21/git-基础/","link":"","permalink":"http://yoursite.com/2017/04/21/git-基础/","excerpt":"","text":"Git是什么是一个免费的、分布式的版本控制工具，或是一个强调了速度快的源代码管理工具。 git安装1，查看是否安装git 命令： git 介绍一下Git的基本命令和操作1,Git通常有两种方式来进行初始化:git clone: 这是较为简单的一种初始化方式 当你已经有一个远程的Git版本库，只需要在本地克隆一份，例如’git clone git://github.com/someone/some_project.git some_project’命令就是将’git://github.com/someone/some_project.git’这个URL地址的远程版 本库完全克隆到本地some_project目录下面git init和git remote： 这种方式稍微复杂一些，当你本地创建了一个工作目录，你可以进入这个目录， 使用’git init’命令进行初始化，Git以后就会对该目录下的文件进行版本控制， 这时候如果你需要将它放到远程服务器上，可以在远程服务器上创建一个目录，并把 可访问的URL记录下来， 此时你就可以利用’git remote add’命令来增加一个远程服务器端， 例如’git remote add origin git://github.com/someone/another_project.git’这条命令就会增加URL地址为’git: //github.com/someone/another_project.git’，名称为origin的远程服务器，以后提交代码的时候只需要使用 origin别名即可 2,Git的基本命令git init 初始化克隆仓库的命令格式为 git clone [url] 案例：git clone git://github.com/schacon/grit.gitgit status 检查当前文件状态git diff 查看这次修改的内容和之前版本的内容(命令行内比较) ;git df (是调图形界面比较)git add . 添加已修改文件(添加和修改的)git add . -A(所有修改和添加删除的文件)git diff –cached (添加后在比较时命令)git commit -m ‘initial project version’ 提交已修改的文件’ 备注主要需改的内容 ‘git log 查看提交历史git pull origin master 获取远程别人提交的代码git push origin master 把自己的代码推送到远程服务器。 查看分支命令git branch //列出所有本地分支git branch -r //列出所有远程分支git remove -v (查看所有项目)// 列出所有本地分支和远程分支git branch -a 查看远程的所有分支名 新建分支命令创建新分支的前提是切回master分支获取最新的master(git pull origin master)创建本地分支：git branch “分支名”/master (还在本分支上)切换分支： git checkout [name] （git co - 返回上一个分支）创建新分支并立即切换到新分支： git checkout -b [name]推送到远程： git push 删除分支【git 删除本地分支】git branch -d（分支名）【git 删除远程分支】git push origin –delete [分支名] (origin 后面有空格)git branch -dr [remote/branch] 合并分支命令前提是切回master分支获取最新的master(git pull origin master)然后在切回当前分支执行(git merge master)1, git checkout master2, git pull origin master3, git checkout - (返回当前分支)4, git merge master(合并)5, git pull6, git push 撤销修改第一种没有提交到暂存区1，git status2,git checkout – file可以丢弃工作区的修改：`javascriptgit checkout – 文件名 //把工作区的修改全部撤销第二种 已经提交到暂存区，需要撤销 但是还好没有Git commit, 撤销步骤1，git reset HEAD 文件名（. 代表所有文件）2，git checkout – 文件名（同上） 删除文件1，删除工作区文件，并且将这次删除放入暂存区git rm [file1][file2]…2，rm 文件名 改名文件，并且将这个改名放入暂存区git mv [file-original] [file-renamed]","categories":[],"tags":[{"name":"工具使用技巧","slug":"工具使用技巧","permalink":"http://yoursite.com/tags/工具使用技巧/"}]},{"title":"my hexo 笔记","slug":"markdown使用说明","date":"2017-04-17T09:38:18.000Z","updated":"2019-10-20T13:56:07.607Z","comments":true,"path":"2017/04/17/markdown使用说明/","link":"","permalink":"http://yoursite.com/2017/04/17/markdown使用说明/","excerpt":"看到一篇不错的文章手把手教你使用Hexo + Github Pages搭建个人独立博客hexo常用的命令","text":"看到一篇不错的文章手把手教你使用Hexo + Github Pages搭建个人独立博客hexo常用的命令 相关知识:1.MaHua是什么?一个在线编辑markdown文档的编辑器 向Mac下优秀的markdown编辑器mou致敬 Markdown 简明语法Markdown是一种轻量级的标记语言，语法简单，可以排出简洁的表现界面。 一，列表 支持表格、代码块、LaTeX数学公式、目录 可以很方便的插入到 Gmail、Evernote 很容易转为 HTML 、PDF 文件 可以自定义 css 文件，写出更直观优雅的笔记 注：按照Markdown标准语法描述，如果你的 Markdown文本未能正确显示，很可能是在标记符号和文本间忘了保留一个字符的空格123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 二，标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 结果 ：一级标题二级标题三级标题四级标题五级标题六级标题三，图片和链接在 Markdown 中，链接用 显示文本的语法描述，例如：简书可以用类似的语法描述图片（前面多了一个 ! ）： 四, 引用 在引用的文字前加&gt;即可。123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果如下： 这是引用的内容 这是引用的内容 这是引用的内容 五、加粗和斜体，删除线1234**两个连续星号包围一段文本，就把这段加粗啦***两个单独星号包围一段文本，就让文本倾斜咯*_或者用下划线来倾斜_~~删除线~~ 效果： 这是加粗的文字** 这是倾斜的文字`**这是斜体加粗的文字***这是加删除线的文字 这里需要注意，也被用于描述列表，为区别开，倾斜中的 和文本间不能留有空格。 六、表格 dog bird cat foo foo foo bar bar bar baz baz baz 绘制表格 需要在前后均保留一行空白。由-|-|- 的结构分割表头和表身，请注意上述代码中的:，控制了单列表格的对齐方向。（也可以用 | - | - | - | 的结构，显得更加整洁） 七、分页线和换行 三个以上的 -可以描绘一根分页线 （注意前后要空行） 不分段换行：行末加两个空格，直接回车分段换行：两个或多个回车（用空行来换行） 八、代码块行内代码用 int sum = b + c这里用两个`将 int sum = b+c描述为一段将背景标红的行内代码。 行内代码用 int sum = b + c 行内代码用 int sum = b + c 又被上下的 12段前空一行，缩进4个空格，然后书写代码，也可以自动转为代码块。此外，还可以自定义 css 文件，以 ```ruby 的开头描述“这是一段 ruby 代码”，不同的描述可以适配不同的高亮。（ Raysonte代码高亮示例） 详情查看高级详情查看1234567891011121314151617Zepto(function($)&#123; // 点击穿透 var $close = $('#closePopup'); var $popup = $('#popupLayer'); var $under = $('#underLayer'); var $mask = $('#bgMask'); $close.on('tap', function(e)&#123; $popup.hide(); $mask.hide(); &#125;); $under.on('tap', function()&#123; alert('underLayer clicked'); &#125;); &#125;); 2.代码html展示实验123456789&lt;div class=\"powered-by\"&gt;由 &lt;a class=\"theme-link\" href=\"https://hexo.io\"&gt;Hexo&lt;/a&gt; 强力驱动&lt;/div&gt;&lt;div class=\"theme-info\"&gt;主题 -&lt;a class=\"theme-link\" href=\"https://github.com/iissnan/hexo-theme-next\"&gt;NexT.Pisces&lt;/a&gt;&lt;/div&gt; 3.纯文本展示1234567$ cd d:/hexo$ npm install hexo-cli -g$ hexo init blog$ cd blog$ npm install$ hexo g # 或者hexo generate$ hexo s # 或者hexo server，可以在http://localhost:4000/ 查看","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/tags/javaScript/"}]}]